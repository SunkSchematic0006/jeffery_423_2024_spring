<h2> CSE 423 Lab #8: PunY Test Coverage </h2>

Turnin: your test case contributions on Canvas in a .zip file.
<p>

You are welcome to share test cases across teams for
this lab. Your grade will be based on whether the instructor thinks
your submitted work represents at least two hours of effort.
<p>

The purpose of this week's lab is to produce a test suite (henceforth named
tests/ and includable in your future HW submissions) for the PunY
language. The test suite is a directory hierarchy containing source .py files
that you can use as test input, and any data files that they run on.  Your
goal is: cover the Python language syntax.  You have three kinds of tests
(lexical, syntax, and semantic);
each test should have a prefix of either lex, syn, or sem.  You also have
three categories of expected diagnostics, placed in subdirectories of tests/:

<p>

<ul>
<li> for things that are legal, put them in tests/puny
<li> for things that are Python but not in PunY, put them in tests/python
<li> for things that are illegal, put them in tests/errors
</ul>

<p>
Example 423 project directory structure after this lab:
<pre>
   your_423_project/
      ... your makefile and all your compiler source files, plus subdirectory:
      tests/
         ...your testrunner.sh (or .py etc.), plus three subdirectories:
         errors/
	    {lex,syn,sem}*.py; test-cases that should be errors
	 puny/
	    {lex,syn,sem}*.py; test-cases that should pass
	 python/
	    {lex,syn,sem}*.py; test-cases for Python-not-PunY errors
</pre>


<p>

For this lab you are assembling a suite of test cases, and your compiler is
expected to print either "No errors" or print a lexical, syntax, or semantic
error message (with filename, and line number, and offending character or
token).

<h4> 1. Download one or more starting points </h4>

<ol>
<li> Of course you can start by reorganizing any tests you've already written
<li> For example, we can start with the cse107 tests, and maybe write "hinted"
     versions of some or all of those tests.
<li> Before you go writing 1,000 new test cases, or programs that generate
test cases, look for what you can find available for free on the internet.
<li> For Python there should be a lot. For PunY, there will be none. But if you
     look on some Python tutorial websites, many of their toy examples might be
     good PunY tests.
</ol>

<h4> 2. Establish Lexical Coverage </h4>

Check whether your tests/puny directory has tests that use every terminal
symbol that is legal under PunY.  If not, construct new tests lex1.py through
lexN.py until you have a test that uses each terminal symbol.  Produce as
many
lexical error tests as you can think of. At the very least, for each regex
that is bounded by beginning and ending characters, you should have tests
where the ending characters are missing.

<h4> 3. Establish Syntactic Coverage </h4>

Check whether your tests/puny directory has tests that use every rule
in your grammar that is legal under puny.  If not construct new tests
syn1.py through synN.py until you have a test that uses each grammar rule.
Provide as many error tests as you can think of. For each production rule
that includes terminal symbols, can you make a test case that would use
that production rule, except it is missing an expected terminal symbol?


<h4> 4. Establish Semantic Coverage </h4>

Develop tests for all possible data types on each operator.  Develop tests
that check for bad function calls, including wrong number of arguments,
incorrect parameter types, or incorrect return type.

<h4> 5. Write a testrunner script </h4>

Write a script (in any language; bash or python are examples) that runs
your compiler on all your tests. Run it and redirect your output to a file.
Examine that output to look for problems.
<p>

It is usual to save/record the expected output for each test that you add,
and to re-test your compiler on all tests whenever you make changes. You
can diff these regression tests against expected output and tell when a
test output has become broken by a change to your compiler.

<p>

Note: we looked at "import X as Y" and "import X" semantics.
They do not introduce symbols into the global symbol table, they
introduce symbols into the module symbol table.
