<H1> Dr. J's Compiler and Translator Design Lecture Notes </h1>

<table>
<tr align=top>
<td>
<ul>
<li> <A href="intro">Introduction</A>
<ul>
<li> <A href="#1">Lecture 1</A> (<A href="445-1.pptx">pptx</A>)
</ul>
<li> <A href="#lexical">Lexical Analysis</A>
<ul>
<li> <A href="#2">Lecture 2</A> (<A href="445-2.pptx">pptx</A>)
<li> <A href="#3">Lecture 3</A> (<A href="445-3.pptx">pptx</A>)
<li> <A href="#4">Lecture 4</A>
<li> <A href="#5">Lecture 5</A>
<li> <A href="#6">Lecture 6</A>
<li> <A href="#7">Lecture 7</A>
<br>
&nbsp; <br>
&nbsp; <br>
&nbsp; <br>
</ul>
</ul>
</td>
<td align=top>
<ul>
<li> <A href="#syntax">Syntax Analysis</A>
<ul>
<li> <A href="#8">Lecture 8</A>
<li> <A href="#9">Lecture 9</A>
<li> <A href="#10">Lecture 10</A>
<li> <A href="#11">Lecture 11</A>
<li> <A href="#12">Lecture 12</A>
<li> <A href="#13">Lecture 13</A>
</ul>
<li> <A href="#semantic">Semantic Analysis</A>
<ul>
<li> <A href="#14">Lecture 14</A>
<li> <A href="#15">Lecture 15</A>
<li> <A href="#16">Lecture 16</A>
<li> <A href="#17">Lecture 17</A>
</ul>
</ul>
</td>
<td align=top>
<ul>
<li> <A href="#codegen">Intermediate Code Generation</A>
<ul>
<li> <A href="#18">Lecture 18</A>
<li> <A href="#19">Lecture 19</A>
<li> <A href="#20">Lecture 20</A>
<li> <A href="#21">Lecture 21</A>
<li> <A href="#22">Lecture 22</A>
</ul>
<li> <A href="finalcode">Final Code Generation</A>
<ul>
<li> <A href="#23">Lecture 23</A>
<li> <A href="#24">Lecture 24</A>
<li> <A href="#25">Lecture 25</A>
<li> <A href="#26">Lecture 26</A>
<br>
&nbsp; <br>
</ul>
</td>
</tr>
</table>

<p>
<font size=1> <A name=1>lecture #1</A> began here</font>
<p>

<A name="intro">
<h3>Why study compilers?</h3>
</a>

Computer scientists study compiler construction for the
following reasons:

<ul>
<li> Writing a compiler gives experience with large-scale
applications development. Your compiler may be the largest
program you write as a student.  Experience working with really big
data structures and complex interactions between algorithms will
help you out on your next big programming project.

<li> Compiler writing is one of the shining triumphs of CS theory.
It demonstrates the value of theory over the impulse to just "hack up"
a solution.

<li> Compiler writing is a basic element of programming language research.
Many language researchers write compilers for the languages they design.

<li> Many applications have similar properties to one or more phases of
a compiler, and compiler expertise and tools can help an application
programmer working on other projects besides compilers.
</ul>

CS 445 is labor intensive. This is a good thing: there is no way to
learn the skills necessary for writing big programs without this kind
of labor-intensive experience.

<h3> Some Tools we will use </h3>

Labs and lectures will discuss all of these, but if you do not know them
already, the sooner you go learn them, the better.

<dl>
<dt> C and "make".
<dd> If you are not expert with these yet, you will be a lot closer
     by the time you pass this class.
<dt> lex and yacc
<dd> These are compiler-writers tools, but they are useful for other
     kinds of applications, almost anything with a complex file format
     to read in can benefit from them.
<dt> gdb
<dd> If you do not know a source-level debugger well, start learning.
      You will need one to survive this class.
<dt> e-mail
<dd> Regularly e-mailing your instructor is a crucial part of class
     participation.  If you aren't asking questions, you aren't doing
     your job as a student.
<dt> web
<dd> This is where you get your lecture notes, homeworks, and labs,
     and turnin all your work.
<dt> virtual environment
<dd> We have a 3D video game / chat tool available that can help us
     handle questions when one of us is not on campus.
</dl>

<h3> Compilers - What Are They and What Kinds of Compilers are Out There? </h3>

The purpose of a compiler is: to translate a program in some language (the
<i>source language</i>) into a lower-level language (the <I>target
language</i>).  The compiler itself is written in some language, called
the <i>implementation language</i>.  To write a compiler you have to be
very good at programming in the implementation language, and have to
think about and understand the source language and target language.<p>

There are several major kinds of compilers:

<dl>
<dt> Native Code Compiler
<dd> Translates source code into hardware (assembly or machine code)
     instructions.  Example: gcc.

<dt> Virtual Machine Compiler
<dd> Translates source code into an abstract machine code, for execution
     by a virtual machine interpreter.  Example: javac.

<dt> JIT Compiler
<dd> Translates virtual machine code to native code.  Operates within
     a virtual machine. Example: Sun's HotSpot java machine.

<dt> Preprocessor
<dd> Translates source code into simpler or slightly lower level source code,
     for compilation by another compiler.  Examples: cpp, m4.

<dt> Pure interpreter
<dd> Executes source code on the fly, without generating machine code.
     Example: Lisp.
</dl>


<h3> Phases of a Compiler </h3>

<dl>
<dt>Lexical Analysis:</dt>
<dd>Converts a sequence of characters into words, or <I>tokens</i></dd>
<dt>Syntax Analysis:</dt>
<dd>Converts a sequence of tokens into a <I>parse tree</i></dd>
<dt>Semantic Analysis:</dt>
<dd>Manipulates parse tree to verify symbol and type information</dd>
<dt>Intermediate Code Generation:</dt>
<dd>Converts parse tree into a sequence of intermediate code instructions</dd>
<dt>Optimization:</dt>
<dd>Manipulates intermediate code to produce a more efficient program</dd>
<dt>Final Code Generation:</dt>
<dd>Translates intermediate code into final (machine/assembly) code</dd>
</dl>


<H3> Example of the Compilation Process </h3>

Consider the example statement; its translation to machine code
illustrates some of the issues involved in compiling.
<table border><tr><pre>
position = initial + rate * 60
</pre></table>
30 or so characters, from a single line of source code, are first
transformed by lexical analysis into a sequence of 7 tokens.  Those
tokens are then used to build a tree of height 4 during syntax analysis.
Semantic analysis may transform the tree into one of height 5, that
includes a type conversion necessary for real addition on an integer
operand.  Intermediate code generation uses a simple traversal
algorithm to linearize the tree back into
a sequence of machine-independent three-address-code instructions.

<table border><tr><pre>
t1 = inttoreal(60)
t2 = id<sub>3</sub> * t1
t3 = id<sub>2</sub> + t2
id<sub>1</sub> = t3
</pre></table>

Optimization of the intermediate code allows the four instructions to
be reduced to two machine-independent instructions.  Final code generation
might implement these two instructions using 5 machine instructions, in
which the actual registers and addressing modes of the CPU are utilized.
<table border><tr><pre>
MOVF	id<sub>3</sub>, R2
MULF	#60.0, R2
MOVF	id<sub>2</sub>, R1
ADDF	R2, R1
MOVF	R1, id<sub>1</sub>
</pre></table>

<h3> Announcements </h3>

<h4> Reading! </h4>

Read Sections 3-5 of the Flex manual,
<A href="http://flex.sourceforge.net/manual/">Lexical Analysis With Flex</A>.
<p>

Also please make sure you read the class lecture notes and the related
sections of the text. Please ask questions about
whatever is not totally clear.  You can <em>Ask Questions</em> in class,
via e-mail, or in the CS Forums.

<p>

Note: although the whole course's lecture notes are ALL available to you up
front, I generally revise each lecture's notes, making additions,
corrections and adaptations to this year's homeworks, the night before each
lecture.  The best time to print hard copies of the lecture notes is one
day at a time, right before the lecture is given.  Or just read online.
<p>

<p>
<A name="lexical">
<font size=1> <A name=2>lecture #2</A> began here</font>
</A>
<p>


<h3> Overview of Lexical Analysis </h3>

A lexical analyzer, also called a <em>scanner</em>, typically has the
following functionality and characteristics.

<ul>

<li> Its primary function is to convert from a (often very long) sequence of
characters into a (much shorter, perhaps 10X shorter) sequence of tokens.
This means less work for subsequent phases of the compiler.

<li> The scanner must Identify and Categorize specific character sequences
into tokens.  It must know whether every two adjacent characters in the file
belong together in the same token, or whether the second character must be
in a different token.

<li> Most lexical analyzers discard comments &amp; whitespace. In most
languages these characters serve to separate tokens from each other, but
once lexical analysis is completed they serve no purpose.  On the other
hand, the exact line # and/or column # may be useful in reporting errors,
so some record of what whitespace has occurred may be retained.  <em>Note:</em>
in some languages, even popular ones, whitespace is significant.

<li> Handle lexical errors (illegal characters, malformed tokens) by
reporting them intelligibly to the user.

<li> Efficiency is crucial; a scanner may perform elaborate input buffering

<li> Token categories can be (precisely, formally) specified using regular
expressions, e.g.
<pre>
	 IDENTIFIER=[a-zA-Z][a-zA-Z0-9]*
</pre>

<li> Lexical Analyzers can be written by hand, or implemented automatically
using finite automata.
</ul>

<h3> What is a "token" ?</h3>

In compilers, a "token" is:

<ol>
<li> a single word of source code input (a.k.a. "lexeme")
<li> an integer code that refers to a single word of input
<li> a set of lexical attributes computed from a single word of input
</ol>

Programmers think about all this in terms of #1. Syntax checking uses
#2. Error reporting, semantic analysis, and code generation require #3.  In
a compiler written in C, for each token you allocate a C struct to store (3)
for each token.

<h4> Worth Mentioning </h4>

Here are the names of several important tools closely related to
compilers. You should learn those of these terms that you don't already know.

<dl>
<dt> interpreter
<dd> a language processor program that translates and executes source
code directly, without compiling it ot machine code.
<dt> assembler
<dd> a translator from human readable (ASCII text) files of machine
instructions into the actual binary code (object files) of a machine.
<dt> linker
<dd> a program that combines (multiple) object files to make an executable.
     Converts names of variables and functions to numbers (machine addresses).
<dt> loader
<dd> Program to load code.  On some systems, different executables start at
     different base addresses, so the loader must patch the executable with
     the actual base address of the executable.
<dt> preprocessor
<dd> Program that processes the source code before the compiler sees it.
     Usually, it implements macro expansion, but it can do much more.
<dt> editor
<dd> Editors may operate on plain text, or they may be wired into the rest
     of the compiler, highlighting syntax errors as you go, or allowing
     you to insert or delete entire syntax constructs at a time.
<dt> debugger
<dd> Program to help you see what's going on when your program runs.
     Can print the values of variables, show what procedure called what
     procedure to get where you are, run up to a particular line, run
     until a particular variable gets a special value, etc.
<dt> profiler
<dd> Program to help you see where your program is spending its time, so
     you can tell where you need to speed it up.
</dl>


<h4> Auxiliary data structures </h4>

You were presented with the phases of the compiler, from lexical and syntax
analysis, through semantic analysis, and intermediate and final code 
generation.  Each phase has an input and an output to the next phase.
But there are a few data structures
we will build that  survive across multiple phases: the literal table,
the symbol table, and the error handler.

<dl>
<dt> lexeme table
<dd> a table that stores lexeme values, such as strings and variable
     names, that may occur in many places.  Only one copy of each
     unique string and name needs to be allocated in memory.
<dt> symbol table
<dd> a table that stores the names defined (and visible with) each
     particular scope.  Scopes include: global, and procedure (local).
     More advanced languages have more scopes such as class (or record)
     and package.
<dt> error handler
<dd> errors in lexical, syntax, or semantic analysis all need a common
     reporting mechanism, that shows where the error occurred (filename,
     line number, and maybe column number are useful).
</dl>

<h4> Reading Named Files in C using <code>stdio</code> </h4>

In this class you are opening and reading files.  Hopefully this is review
for you; if not, you will need to learn it quickly.  To do any "standard
I/O" file processing, you start by including the header:

<pre>
#include &lt;stdio.h&gt;
</pre>
This defines a data type <code>(FILE *)</code> and gives prototypes for
relevant functions.  The following code opens a file using a string filename,
reads the first character (into an int variable, not a char, so that it can
detect end-of-file; EOF is not a legal char value).
<pre>
   FILE *f = fopen(filename, "r");
   int i = fgetc(f);
   if (i == EOF) /* empty file... */
</pre>


<h3> Command line argument handling and file processing in C </h3>
The following example is from Kernighan & Ritchie's "The C Programming
Language", page 162.
<A name="sample.c">
<pre>
#include &lt;stdio.h&gt;

/* cat: concatenate files, version 1 */
int main(int argc, char *argv[])
{
   FILE *fp;
   void filecopy(FILE *, FILE *);

   if (argc == 1)
      filecopy(stdin, stdout);
   else
      while (--argc > 0)
         if ((fp = fopen(*++argv, "r")) == NULL) {
            printf("cat: can't open %s\n", *argv);
            return 1;
            }
         else {
            filecopy(fp, stdout);
            fclose(fp);
            }
   return 0;
}

void filecopy(FILE *ifp, FILE *ofp)
{
   int c;

   while ((c = getc(ifp)) != EOF)
      putc(c, ofp);
}
</pre>

<em> Warning: while using and adapting the above code is fair game in this
class, the yylex() function is very different than the filecopy() function!
It takes no parameters!  It returns an integer every time it finds a token!
So if you "borrow" from this example, delete filecopy() and write yylex()
from scratch.  Multiple students have fallen into this trap before you.
</em>

<h3> A Brief Introduction to Make </h3>

It is not a good idea to write a large program like a compiler as a single
source file.  For one thing, every time you make a small change, you would
need to recompile the whole program, which will end up being many thousands
of lines.  For another thing, parts of your compiler may be generated by
"compiler construction tools" which will write separate files.  In any case,
this class will require you to use multiple source files, compiled
separately, and linked together to form your executable program. This
would be a pain, except we have "make" which takes care of it for us.

Make uses an input file named "makefile", which stores in ASCII text form
a collection of rules for how to build a program from its pieces.  Each
rule shows how to build a file from its source files, or dependencies.
For example, to compile a file under C:
<pre>
foo.o : foo.c
	gcc -c foo.c
</pre>
The first line says to build foo.o you need foo.c, and the second line,
which <em><b>must</b></em> being with a tab, gave a command-line to
execute whenever foo.o should be rebuilt, i.e. when it is missing or
when foo.c has been changed and need to be recompiled.
<p>
The first rule in the makefile is what "make" builds by default, but
note that make dependencies are recursive: before it checks whether
it needs to rebuild foo.o from foo.c it will check whether foo.c needs
to be rebuilt using some other rule.  Because of this post-order
traversal of the "dependency graph", the first rule in your makefile
is usually the last one that executes when you type "make".  For a
C program, the first rule in your makefile would usually be the
"link" step that assembles objects files into an executable as in:
<pre>
compiler: foo.o bar.o baz.o
	gcc -o compiler foo.o bar.o baz.o
</pre>

There is a lot more to "make" but we will take it one step at a time.
This
<A href="http://developers.sun.com/solaris/articles/make_utility.html">
article on Make</A>
may be useful to you.  You can find other useful on-line documentation
on "make" (manual page, Internet reference guides, etc) if you look.


<h3> A couple finer points for <A href="hw1.html">HW#1</A> </h3>

<li> extern vs. #include: when do you use the one, when the other?
<li> public interface to yylex(): no, you can't add your own parameters


<h3> Regular Expressions </h3>

The notation we use to precisely capture all the variations that a given
category of token may take are called "regular expressions" (or, less
formally, "patterns".  The word "pattern" is really vague and there are
lots of other notations for patterns besides regular expressions).
Regular expressions are a shorthand notation
for sets of strings.  In order to even talk about "strings" you have
to first define an <em>alphabet</em>, the set of characters which can
appear.

<ol>
<li> Epsilon (&epsilon;) is a regular expression denoting the set
     containing the empty string
<li> Any letter in the alphabet is also a regular expression denoting
     the set containing a one-letter string consisting of that letter.
<li> For regular expressions r and s, <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; r | s<br>
     is a regular expression denoting the union of r and s
<li> For regular expressions r and s, <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; r s<br>
     is a regular expression denoting the set of strings consisting of
     a member of r followed by a member of s
<li> For regular expression r, <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; r*<br>
     is a regular expression denoting the set of strings consisting of
     zero or more occurrences of r.
<li> You can parenthesize a regular expression to specify operator
     precedence (otherwise, alternation is like plus, concatenation
     is like times, and closure is like exponentiation)
</ol>

Although these operators are sufficient to describe all regular languages,
in practice everybody uses extensions:

<ul>
<li> For regular expression r, <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; r+<br>
     is a regular expression denoting the set of strings consisting of
     one or more occurrences of r.  Equivalent to rr*
<li> For regular expression r, <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; r?<br>
     is a regular expression denoting the set of strings consisting of
     zero or one occurrence of r.  Equivalent to r|&epsilon;
<li> The notation [abc] is short for a|b|c.  [a-z] is short for a|b|...|z.
     [^abc] is short for: any character other than a, b, or c.
</ul>


<h4> What is a "lexical attribute" ? </h4>

A lexical attribute is a piece of information about a token.  These typically
include:

<table>
<tr><td> category <td> an integer code used to check syntax
<tr><td> lexeme <td> actual string contents of the token
<tr><td> line, column, file <td> where the lexeme occurs in source code
<tr><td> value <td> for literals, the binary data they represent
</table>


<h4> Avoid These Common Bugs in Your Homeworks! </h4>

<ol>
<li> yytext or yyinput were not declared global
<li> main() does not have its required argc, argv parameters!
<li> main() does not call yylex() in a loop or check its return value
<li> getc() EOF handling is missing or wrong!  check EVERY all to getc() for EOF!
<li> opened files not (all) closed! file handle leak!
<li> end-of-comment code doesn't check for */
<li> yylex() is not doing the file reading
<li> yylex() does not skip multiple spaces, mishandles spaces at the front
     of input, or <em>requires</em> certain spaces in order to function OK
<li> extra or bogus output not in assignment spec
<li> = instead of ==
</ol>

<h3> Some Regular Expression Examples </h3>

In a previous lecture we saw regular expressions, the preferred notation for
specifying patterns of characters that define token categories.  The best
way to get a feel for regular expressions is to see examples.  Note that
regular expressions form the basis for pattern matching in many UNIX tools
such as grep, awk, perl, etc. <p>

What is the regular expression for each of the different lexical items that
appear in C programs?  How does this compare with another, possibly simpler
programming language such as BASIC?

<!--This is the first of many things where BASIC is somewhat easier 
to deal with than C.-->

<table border>
<tr> <th> lexical category <th> BASIC <th> C </tr>
<tr> <td> operators <td> the characters themselves <td>      For operators that are regular expression operators we need mark them
     with double quotes or backslashes to indicate you mean the character,
     not the regular expression operator.  Note several operators have a
     common prefix. The lexical analyzer needs to look ahead to tell
     whether an = is an assignment, or is followed by another = for example.
 </tr>
<tr> <td> reserved words <td> the concatenation of characters; case insensitive <td>
     Reserved words are also matched by the regular expression for identifiers,
     so a disambiguating rule is needed.
</tr>

<tr>
<td> identifiers <td> no _; $ at ends of some; 2 significant letters!?; case insensitive <td> [a-zA-Z_][a-zA-Z0-9]*
</tr>

<tr>
<td> numbers <td> ints and reals, starting with [0-9]+ <td> 0x[0-9a-fA-F]+ etc.
</tr>

<tr> <td> comments <td> REM.* <td> C's comments are tricky regexp's

<tr> <td> strings <td> almost ".*"; no escapes <td> escaped quotes

<tr> <td> what else?

</table>

<p>
<font size=1> <A name=3>lecture #3</A> began here</font>
<p>

<h3> <tt>lex(1)</tt> and <tt>flex(1)</tt> </h3>

These programs generally take a lexical specification given in a .l file
and create a corresponding C language lexical analyzer in a file named
lex.yy.c.  The lexical analyzer is then linked with the rest of your compiler.
<p>

The C code generated by lex has the following public interface.  Note the
use of global variables instead of parameters, and the use of the prefix
yy to distinguish scanner names from your program names.  This prefix is
also used in the YACC parser generator.
<pre>
FILE *yyin;	/* set this variable prior to calling yylex() */
int yylex();	/* call this function once for each token */
char yytext[];	/* yylex() writes the token's lexeme to an array */
                /* note: with flex, I believe extern declarations must read
                   extern char *yytext;
                 */
int yywrap();   /* called by lex when it hits end-of-file; see below */
</pre>
<p>

The .l file format consists of a mixture of lex syntax and C code fragments.
The percent sign (%) is used to signify lex elements.  The whole file is
divided into three sections separated by %%:
<pre>
   header
%%
   body
%%
   helper functions
</pre>
<p>

The header consists of C code fragments enclosed in %{ and %} as well as
macro definitions consisting of a name and a regular expression denoted
by that name.  lex macros are invoked explicitly by enclosing the
macro name in curly braces.  Following are some example lex macros.
<pre>
letter		[a-zA-Z]
digit		[0-9]
ident		{letter}({letter}|{digit})*
</pre>
<p>

The body consists of of a sequence of regular expressions for different
token categories and other lexical entities.  Each regular expression can
have a C code fragment enclosed in curly braces that executes when that
regular expression is matched.  For most of the regular expressions this
code fragment (also called a <em>semantic action</em> consists of returning
an integer that identifies the token category to the rest of the compiler,
particularly for use by the parser to check syntax.  Some typical regular
expressions and semantic actions might include:

<pre>
" "		{ /* no-op, discard whitespace */ }
{ident}		{ return IDENTIFIER; }
"*"		{ return ASTERISK; }
"."		{ return PERIOD; }
</pre>

You also need regular expressions for lexical errors such as unterminated
character constants, or illegal characters.
<p>

The helper functions in a lex file typically compute lexical attributes,
such as the actual integer or string values denoted by literals.  One
helper function you have to write is yywrap(), which is called when lex
hits end of file.  If you just want lex to quit, have yywrap() return 1.
If your yywrap() switches yyin to a different file and you want lex to continue
processing, have yywrap() return 0.  The lex or flex library (-ll or -lfl)
have default yywrap() function which return a 1, and flex has the directive
<code>%option noyywrap</code> which allows you to skip writing this function.

<h3> A Short Comment on Lexing C Reals </h3>

C float and double constants have to have at least one digit, either
before or after the required decimal.  This is a pain:
<pre>
([0-9]+.[0-9]* | [0-9]*.[0-9]+) ...
</pre>

You might almost be happier if you wrote

<pre>
([0-9]*.[0-9]*)    { return (strcmp(yytext,".")) ? REAL : PERIOD; }
</pre>

You-all know C's ternary e1 ? e2 : e3 operator, don't ya? Its an if-then-else
expression, very slick.

<h3> Lex extended regular expressions </h3>

Lex further extends the regular expressions with several helpful operators.
Lex's regular expressions include:

<dl>
<dt> c
<dd> normal characters mean themselves
<dt> \c
<dd> backslash escapes remove the meaning from most operator characters.
     Inside character sets and quotes, backslash performs C-style escapes.
<dt> "s"
<dd> Double quotes mean to match the C string given as itself.
     This is particularly useful for multi-byte operators and may be
     more readable than using backslash multiple times.
<dt> [s]
<dd> This character set operator matches any one character among those in s.
<dt> [^s]
<dd> A negated-set matches any one character not among those in s.
<dt> .
<dd> The dot operator matches any one character except newline: [^\n]
<dt> r*
<dd> match r 0 or more times.
<dt> r+
<dd> match r 1 or more times.
<dt> r?
<dd> match r 0 or 1 time.
<dt> r{m,n}
<dd> match r between m and n times.
<dt> r<sub>1</sub>r<sub>2</sub>
<dd> concatenation. match r<sub>1</sub> followed by r<sub>2</sub>
<dt> r<sub>1</sub>|r<sub>2</sub>
<dd> alternation. match r<sub>1</sub> or r<sub>2</sub>
<dt> (r)
<dd> parentheses specify precedence but do not match anything
<dt> r<sub>1</sub>/r<sub>2</sub>
<dd> lookahead.  match r<sub>1</sub> when r<sub>2</sub> follows, without
     consuming r<sub>2</sub>
<dt> ^r
<dd> match r only when it occurs at the beginning of a line
<dt> r$
<dd> match r only when it occurs at the end of a line
</dl>





<!--
<h3> Introductory Comments on BASIC </h3>

We are doing (a large subset of) TRS-80 Color Computer Extended BASIC.
Compared with last semester, you will get more help from me on getting
started with each assignment, and be asked to do a little more.

<li>  The main language reference manuals are on our class web page
<A href="http://www.cs.uidaho.edu/~jeffery/courses/445/">
http://www.cs.uidaho.edu/~jeffery/courses/445/</A>

<li> I am writing my own commentary on it 
<A href="http://www.cs.uidaho.edu/~jeffery/courses/445/basic.html">
http://www.cs.uidaho.edu/~jeffery/courses/445/basic.html</A>
where most of your formal specifications will appear.

<li> I have made a start at some pseudocode
<A href="http://www.cs.uidaho.edu/~jeffery/courses/445/basic.icn">
http://www.cs.uidaho.edu/~jeffery/courses/445/basic.icn</A>
for the "interpreter loop" that will wrap around your compiler.
-->


<h3> Lexical Attributes and Token Objects </h3>

Besides the token's category, the rest of the compiler may need several
pieces of information about a token in order to perform semantic analysis,
code generation, and error handling.  These are stored in an object instance
of class Token, or in C, a struct.  The fields are generally something like:

<pre>
struct token {
   int category;
   char *text;
   int linenumber;
   int column;
   char *filename;
   union literal value;
}
</pre>

The union literal will hold computed values of integers, real numbers, and
strings.  <em>In your homework assignment, I am requiring you to compute
column #'s; not all compilers require them, but they are easy.  Also: in
our compiler project we are not worrying about optimizing our use of memory,
so am not requiring you to use a union</em>.

<h3> Flex Manpage Examplefest </h3>

To read a UNIX "man page", or manual page, you type "man <em>command</em>" 
where command is the UNIX program or library function you need information
on.  Read the man page for man to learn more advanced uses ("man man").
<p>

It turns out the flex man page is intended to be pretty complete, enough
so that we can draw our examples from it. Perhaps what you should figure
out from these examples is that flex is actually... flexible.  The first
several examples use flex as a filter from standard input to standard
output.


<UL>
<li> sneaky string removal tool:
<pre>
           %%
           "zap me"
</pre>
<li> excess whitespace trimmer
<pre>
           %%
           [ \t]+        putchar( ' ' );
           [ \t]+$       /* ignore this token */
</pre>
<li> sneaky string substitution tool:

<pre>
           %%
           username    printf( "%s", getlogin() );
</pre>
</ul>


<ul>
<li> Line Counter/Word Counter

<pre>
                   int num_lines = 0, num_chars = 0;

           %%
           \n      ++num_lines; ++num_chars;
           .       ++num_chars;

           %%
           main()
                   {
                   yylex();
                   printf( "# of lines = %d, # of chars = %d\n",
                           num_lines, num_chars );
                   }
</pre>


<li> Toy compiler example

<pre>
           /* scanner for a toy Pascal-like language */

           %{
           /* need this for the call to atof() below */
           #include &lt;math.h&gt;
           %}

           DIGIT    [0-9]
           ID       [a-z][a-z0-9]*

           %%

           {DIGIT}+    {
                       printf( "An integer: %s (%d)\n", yytext,
                               atoi( yytext ) );
                       }

           {DIGIT}+"."{DIGIT}*        {
                       printf( "A float: %s (%g)\n", yytext,
                               atof( yytext ) );
                       }

           if|then|begin|end|procedure|function        {
                       printf( "A keyword: %s\n", yytext );
                       }

           {ID}        printf( "An identifier: %s\n", yytext );

           "+"|"-"|"*"|"/"   printf( "An operator: %s\n", yytext );

           "{"[^}\n]*"}"     /* eat up one-line comments */

           [ \t\n]+          /* eat up whitespace */

           .           printf( "Unrecognized character: %s\n", yytext );

           %%

           main( argc, argv )
           int argc;
           char **argv;
               {
               ++argv, --argc;  /* skip over program name */
               if ( argc &gt; 0 )
                       yyin = fopen( argv[0], "r" );
               else
                       yyin = stdin;

               yylex();
               }
</pre>

</ul>


<h3> On the use of character sets (square brackets) in lex and similar tools </h3>

A student recently sent me an example regular expression for comments that read:
<pre>
   COMMENT [/*][[^*/]*[*]*]]*[*/]
</pre>
One problem here is that square brackets are not parentheses, they do not nest,
they do not support concatenation or other regular expression operators. They
mean exactly: "match any one of these characters" or for ^: "match any one
character that is not one of these characters".  Note also that you
<em>can't</em> use ^ as a "not" operator outside of square brackets: you
can't write the expression for "stuff that isn't */" by saying (^ "*/")


<p>
<font size=1> <A name=4>lecture #4</A> began here</font>
<p>

<A name=finiteautomata
<h3> Finite Automata </h3>
</A>

A finite automaton (FA) is an abstract, mathematical machine, also known as a
finite state machine, with the following components:

<ol>
<li> A set of states S
<li> A set of input symbols E (the alphabet)
<li> A transition function move(state, symbol) : new state(s)
<li> A start state S0
<li> A set of final states F
</ol>

The word <em>finite</em> refers to the set of states: there is a fixed size
to this machine.  No "stacks", no "virtual memory", just a known number of
states.  The word <em>automaton</em> refers to the execution mode: there is
no instruction set, there is no sequence of instructions, there is just a
hardwired short loop that executes the same instruction over and over:

<pre>
   while ((c=getchar()) != EOF) S := move(S, c);
</pre>

<!--
<h3> <A href="http://www.cs.uidaho.edu/~jeffery/courses/445/hw1/">Sample Solution for Homework #1</A> </h3>-->

<h3> DFAs </h3>

The type of finite automata that is easiest to understand and simplest to
implement (say, even in hardware) is called a deterministic finite automaton
(DFA).  The word <em>deterministic</em> here refers to the return value of
function move(state, symbol), which goes to at most one state.

Example:
<p>
<pre>
S = {s0, s1, s2}
E = {a, b, c}
move = { (s0,a):s1; (s1,b):s2; (s2,c):s2 }
S0 = s0
F = {s2}
</pre>
<p>

Finite automata correspond in a 1:1 relationship to transition diagrams;
from any transition diagram one can write down the formal automaton in
terms of items #1-#5 above, and vice versa.  To draw the transition diagram
for a finite automaton:
<ul>
<li> draw a circle for each state s in S; put a label inside the circles
     to identify each state by number or name
<li> draw an arrow between S<sub>i</sub> and S<sub>j</sub>, labeled with x
     whenever the transition says to move(S<sub>i</sub>, x) : S<sub>j</sub>
<li> draw a "wedgie" into the start state S0 to identify it
<li> draw a second circle inside each of the final states in F
</ul>

<h3> The Automaton Game </h3>

If I give you a transition diagram of a finite automaton, you can hand-simulate
the operation of that automaton on any input I give you.


<h4> DFA Implementation </h4>

The nice part about DFA's is that they are efficiently implemented
on computers.  What DFA does the following code correspond to?  What
is the corresponding regular expression?  You can speed this code
fragment up even further if you are willing to use goto's or write
it in assembler.

<pre>
state := S0
for(;;)
   switch (state) {
   case 0: 
      switch (input) {
         'a': state = 1; input = getchar(); break;
         'b': input = getchar(); break;
	 default: printf("dfa error\n"); exit(1);
         }
   case 1: 
      switch (input) {
         EOF: printf("accept\n"); exit(0);
	 default: printf("dfa error\n"); exit(1);
         }
      }
</pre>


<h4> Deterministic Finite Automata Examples </h4>

A lexical analyzer might associate different final states with different
token categories:<p>
<img src="http://www.cs.uidaho.edu/~jeffery/courses/445/fa-tokens.gif">
<p>


C Comments:<p>
<img src="http://www.cs.uidaho.edu/~jeffery/courses/445/fa-ccomment.gif">
<p>



<h4> Nondeterministic Finite Automata (NFA's)</h4>

Notational convenience motivates more flexible machines in which function
move() can go to more than one state on a given input symbol, and some
states can move to other states even without consuming an input symbol
(&epsilon;-transitions).
<p>

Fortunately, one can prove that for any NFA, there is an equivalent DFA.
They are just a notational convenience. So, finite automata help us get
from a set of regular expressions to a computer program that recognizes
them efficiently.

<h4> NFA Examples </h4>

&epsilon;-transitions make it simpler to merge automata:<p>
<img src="http://www.cs.uidaho.edu/~jeffery/courses/445/fa-eps.gif">
<p>

multiple transitions on the same symbol handle common prefixes:<p>
<img src="http://www.cs.uidaho.edu/~jeffery/courses/445/fa-less.gif">
<p>

factoring may optimize the number of states.  Is this picture OK/correct?<p>
<img src="http://www.cs.uidaho.edu/~jeffery/courses/445/fa-less2.gif">
<p>


<h4> C Pointers, malloc, and your future </h4>

For most of you success as a computer scientist may boil down to whether you can
master the concept of dynamically allocated memory.  In C this means pointers and
the malloc() family of functions.  Here are some tips:

<ul>
<li> Draw "memory box" pictures of your variables.  Pencil and paper
     understanding of memory leads to correct running programs.
<li> Always initialize local pointer variables.  Consider this code:
<pre>
void f() {
   int i = 0;
   struct tokenlist *current, *head;
   ...
   foo(current)
}
</pre>

Here, <code>current</code> is passed in as a parameter to foo, but it is a
pointer that hasn't been pointed at anything. I cannot tell you how many
times I personally have written bugs myself or fixed bugs in student code,
caused by reading or writing to pointers that weren't pointing at anything
in particular.  Local variables that weren't initialized point at random
garbage. If you are lucky this is a coredump, but you might not be lucky,
you might not find out where the mistake was, you might just get a wrong answer.
This can all be fixed by

<pre>
   struct tokenlist *current = NULL, *head = NULL;
</pre>

<LI> Avoid this common C bug:
<pre>
struct token *t = (struct token *)malloc(sizeof(struct token *)));
</pre>
This compiles, but causes coredumps during program execution.  Why?

<li> Check your malloc() return value to be sure it is not NULL.
Sure, modern programs will "never run out of memory".  Wrong. malloc() can return
NULL even on big machines.  Operating systems often place limits on memory
so as to protect themselves from runaway programs or hacker attacks.
</ul>


<h4> Regular expression examples </h4>

Can you draw an NFA corresponding to the following?

<pre>
(a|c)*b(a|c)*

(a|c)*|(a|c)*b(a|c)*

(a|c)*(b|&epsilon;)(a|c)*
</pre>

<h4> Regular expressions can be converted automatically to NFA's </h4>

Each rule in the definition of regular expressions has a corresponding
NFA; NFA's are <i>composed</i> using &epsilon; transitions.  This is called
"Thompson's construction" <!--(Louden pg. 64, ASU Algorithm 3.3-->).
We will work
examples such as (a|b)*abb in class and during lab.

<ol>
<li> For &epsilon;, draw two states with a single &epsilon; transition.
     <br><img src="http://www.cs.uidaho.edu/~jeffery/courses/445/fa-th2.gif">
<li> For any letter in the alphabet, 
     draw two states with a single transition labeled with that letter.
     <br><img src="http://www.cs.uidaho.edu/~jeffery/courses/445/fa-th1.gif">
<li> For regular expressions r and s, draw r | s
     by adding a new start state with &epsilon; transitions to the start
     states of r and s, and a new final state with &epsilon; transitions
     from each final state in r and s.
     <br><img src="http://www.cs.uidaho.edu/~jeffery/courses/445/fa-th4.gif">
<li> For regular expressions r and s, draw rs
     by adding &epsilon; transitions from the final states of r to the
     start state of s.
     <br><img src="http://www.cs.uidaho.edu/~jeffery/courses/445/fa-th3.gif">
<li> For regular expression r, draw r*
     by adding new start and final states, and &epsilon; transitions
<ul>
	<li> from the start state to the final state,
	<li> from the final  state back to the start state,
	<li> from the new start to the old start and from the old final
            states to the new final state.
</ul>
     <br><img src="http://www.cs.uidaho.edu/~jeffery/courses/445/fa-th5.gif">
<li> For parenthesized regular expression (r) you can use the NFA for r.
</ol>

<p>
<font size=1> <A name=5>lecture #5</A> began here</font>
<p>


<h4> NFA's can be converted automatically to DFA's </h4>

In: NFA N<br>
Out: DFA D<br>
Method: Construct transition table Dtran (a.k.a. the "move function").
Each DFA state is a set of
NFA states. Dtran simulates in parallel all possible moves N can make
on a given string.
<p>

Operations to keep track of sets of NFA states:
<p>
<dl>
<dt>&epsilon;_closure(s)</dt>
<dd> set of states reachable from state s via &epsilon;</dd>
<dt>&epsilon;_closure(T)</dt>
<dd> set of states reachable from any state in set T via &epsilon;</dd>
<dt>move(T,a)</dt>
<dd> set of states to which there is an NFA transition from states in T on symbol a</dd>
</dl>
<p>

NFA to DFA Algorithm:
<p>
<pre>
Dstates := {&epsilon;_closure(start_state)}
while T := unmarked_member(Dstates) do {
	mark(T)
	for each input symbol a do {
		U := &epsilon;_closure(move(T,a))
		if not member(Dstates, U) then
			insert(Dstates, U)
		Dtran[T,a] := U
	}
}
</pre>

<h3> Practice converting NFA to DFA </h3>

OK, you've seen the algorithm, now can you use it?<p>
<img src="http://www.cs.uidaho.edu/~jeffery/courses/445/nfadfa.gif">
<p>
...
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
...did you get:<p>
<img src="http://www.cs.uidaho.edu/~jeffery/courses/445/nfadfa2.gif">
<p>
<br>
<br>
<br>
<br>
OK, how about this one: <p>
<img src="http://www.cs.uidaho.edu/~jeffery/courses/445/nfadfa3.gif">
<p>


<!--
<h2> Some Remarks (BASIC)</h2>

<ul>
<li> Color BASIC has two-letter identifiers.  We are doing Extended Color
     BASIC, so we will allow longer identifier names.  But in the current
     assignment #2 you will only be tested on short variable names.
<li> Whether we return the same or a different category for integer constants
     and for line numbers depends very much on the grammar we use to parse
     our language,
     and whether it can understand what's going on with the
     line numbers if it doesn't have two categories.  My instinct tells me
     we will probably need either a token for newline characters or will
     need to detect line numbers as distinct from normal integer constants.
     Before we can answer that question, we need to learn about syntax!
</ul>
-->


<h3> Lexical Analysis and the Literal Table </h3>

In many compilers, the memory management components of the compiler interact
with several phases of compilation, starting with lexical analysis.

<p>

<ul>
<li> Efficient storage is necessary to handle large input files.
<li> There is a colossal amount of duplication in lexical data:
     variable names, strings and other literal values duplicate frequently
<li> What token type to use may depend on previous declarations.
</ul>
<p>
A hash table or other efficient data structure can avoid this duplication.
The software engineering design pattern to use is called the "flyweight".


<h3> Major Data Structures in a Compiler </h3>

<dl>
<dt> token
<dd> contains an integer category, lexeme, line #, column #, filename...
     We could build these into a link list, but instead we'll use them
     as leaves in a tree structure.
<dt> syntax tree
<dd> contains grammar information about a sequence of related tokens.
     leaves contain lexical information (tokens).  internal nodes
     contain grammar rules and pointers to tokens or other tree nodes.
<dt> symbol table
<dd> contains variable names, types, and information needed to generate
     code for a name (such as its address, or constant value).  Look ups
     are by name, so we'll need a hash table.
<dt> intermediate & final code
<dd> We'll need link lists or similar structures to hold sequences of machine
     instructions
</dl>


<h3> Literal Table: Usage Example </h3>

Example abbreviated from [ASU86]: Figure 3.18, p. 109.  Use "install_id()"
instead of "strdup()" to avoid duplication in the lexical data.

<pre>
%{
/* #define's for token categories LT, LE, etc.
%}

white	[ \t\n]+
digit   [0-9]
id	[a-zA-Z_][a-zA-Z_0-9]*
num     {digit}+(\.{digit}+)?

%%

{ws}	{ /* discard */ }
if	{ return IF; }
then	{ return THEN; }
else	{ return ELSE; }
{id}	{ yylval.id = install_id(); return ID; }
{num}   { yylval.num = install_num(); return NUMBER; }
"&lt;"	{ yylval.op = LT; return RELOP; }
"&gt;"	{ yylval.op = GT; return RELOP; }

%%

install_id()
{
   /* insert yytext into the literal table */
}

install_num()
{
   /* insert (binary number corresponding to?) yytext into the literal table */
}
</pre>

So how would you implement a literal table using a hash table?  We will see
more hash tables when it comes time to construct the symbol tables with which
variable names and scopes are managed, so you had better become fluent.


<h3> Constructing your Token inside yylex() </h3>

A student recently asked if it was OK to allocate a token structure
inside main() after yylex() returns the token.  This is not OK because
in the next phase of your compiler, you are not calling yylex(), the
automatically generated parser will call yylex().  There is a way for
the parser to grab your token if you've stored it in a global variable,
but there is not a way for the parser to build the token structure itself.


<A name="syntax"><h2> Syntax Analysis </h2></A>

<em>Parsing</em> is the act of performing syntax analysis to verify an input
program's compliance with the source language.  A by-product of this process
is typically a tree that represents the structure of the program.

<p>
<font size=1> <A name=6>lecture #6</A> began here</font>
<p>
<h3> Context Free Grammars </h3>

A context free grammar G has:

<ul>
<li> A set of terminal symbols, T
<li> A set of nonterminal symbols, N
<li> A start symbol, s, which is a member of N
<li> A set of production rules of the form A -> w,
     where A is a nonterminal and w is a string of terminal and 
     nonterminal symbols.
</ul>

A context free grammar can be used to <em>generate</em> strings in the
corresponding language as follows:
<pre>let X = the start symbol s
while there is some nonterminal Y in X do
   apply any one production rule using Y, e.g. Y -> w
</pre>
When X consists only of terminal symbols, it is a string of the language
denoted by the grammar.  Each iteration of the loop is a
<em>derivation step</em>.  If an iteration has several nonterminals
to choose from at some point, the rules of derviation would allow any of these
to be applied.  In practice, parsing algorithms tend to always choose the
leftmost nonterminal, or the rightmost nonterminal, resulting in strings
that are <em>leftmost derivations</em> or <em>rightmost derivations</em>.

<h3> Context Free Grammar Examples </h3>

Well, OK, so how much of the <!--BASIC--> C language grammar can we come up
with in class today?  Start with expressions, work on up to statements, and
work there up to entire functions, and programs.

<p>
<font size=1> <A name=7>lecture #7</A> began here</font>
<p>

<h3> Context Free Grammar Example (from BASIC) </h3>

How many terminals and non-terminals does the grammar below use?
Compared to the little grammar we started last time, how does this rate?
What parts make sense, and what parts seem bogus?

<pre>
Program : Lines
Lines   : Lines Line
Lines   : Line
Line    : INTEGER StatementList
StatementList : Statement COLON StatementList
StatementList : Statement
Statement: AssignmentStatement
Statement: IfStatement
<em> REMark: ... BASIC has many other statement types </em>

AssignmentStatement : Variable ASSIGN Expression
Variable : IDENTIFIER
<em> REMark: ... BASIC has at least one more Variable type: arrays </em>

IfStatement: IF BooleanExpression THEN Statement
IfStatement: IF BooleanExpression THEN Statement ELSE Statement

Expression: Expression PLUS Term
Expression: Term
Term      : Term TIMES Factor
Term      : Factor
Factor    : IDENTIFIER
Factor    : LEFTPAREN Expression RIGHTPAREN
<em> REMark: ... BASIC has more expressions </em>
</pre>


<h3> Grammar Ambiguity </h3>

The grammar

<pre>
E -> E + E
E -> E * E
E -> ( E )
E -> ident
</pre>

allows two different derivations for strings such as "x + y * z".
The grammar is ambiguous, but the semantics of the language dictate
a particular operator precedence that should be used.  One way to
eliminate such ambiguity is to rewrite the grammar. For example,
we can force the precedence we want by adding some nonterminals and
production rules.

<pre>
E -> E + T
E -> T
T -> T * F
T -> F
F -> ( E )
F -> ident
</pre>

Given the arithmetic expression grammar from last lecture:
<p>

How can a program figure that x + y * z is legal?<br>
How can a program figure out that x + y (* z) is illegal?
<p>

<h3> A brief aside on casting your mallocs </h3>

<li> If you don't put a prototype for malloc(), C thinks it returns an int.
<pre>
#include &lt;stdlib.h&gt;
</pre>
includes prototypes for malloc(), free(), etc.  malloc() returns a void *.
<br><br>

<li> void * means "pointer that points at nothing", or "pointer that points
     at anything".  You need to cast it to what you are really pointing at,
     as in:
<pre>
union lexval *l = (union lexval *)malloc(sizeof(union lexval));
</pre>
Note the stupid duplication of type information; no language is perfect!
Anyhow, always cast your mallocs.  The program may work without the cast,
but you need to fix every warning, so you don't accidentally let a serious
one through.<br><br>


<h3> Recursive Descent Parsing </h3>

Perhaps the simplest parsing method, for a large subset of context free
grammars, is called recursive descent.  It is simple because the algorithm
closely follows the production rules of nonterminal symbols.

<ul>
<li> Write 1 procedure per nonterminal rule
<li> Within each procedure, a) match terminals at appropriate positions,
     and b) call procedures for non-terminals.
<li> Pitfalls:
<ol><li> left recursion is FATAL
<li> must distinguish between several
     production rules, or potentially, one has to
     try all of them via <em>backtracking</em>.
</ol>
</ul>


<h4> Recursive Descent Parsing Example #1</h4>

Consider the grammar we gave above.  There will be functions for
E, T, and F.  The function for F() is the "easiest" in some sense: based
on a single token it can decide which production rule to use.  The
parsing functions return 0 (failed to parse) if the nonterminal in
question cannot be derived from the tokens at the current point.
A nonzero return value of N would indicate success in parsing using
production rule #N.

<pre>
int F()
{
   int t = yylex();
   if (t == IDENT) return 6;
   else if (t == LP) {
      if (E() && (yylex()==RP) return 5;
      }
   return 0;
}
</pre>

Comment #1: if F() is in the middle of a larger parse of E() or T(), F()
may succeed, but the subsequent parsing may fail. The parse may have
to <em>backtrack</em>, which would mean we'd have to be able to put
tokens back for later parsing.  Add a memory (say, a gigantic array or
link list for example) of already-parsed tokens
to the lexical analyzer, plus backtracking logic to E() or T() as needed.
The call to F() may get repeated following a different production rule
for a higher nonterminal.
<p>

Comment #2: in a real compiler we need more than "yes it parsed" or
"no it didn't": we need a parse tree if it succeeds, and we need a
useful error message if it didn't.
<p>

Question: for E() and T(), how do we know which production rule to try?
Option A: just blindly try each one in turn.
Option B: look at the first (current) token, only try those rules that
start with that token (1 character lookahead).  If you are lucky, that
one character will uniquely select a production rule. If that is always
true through the whole grammar, no backtracking is needed.
<p>


Question: how do we know which rules start with whatever token we are
looking at?  Can anyone suggest a solution, or are we stuck?

<p>
<font size=1> <A name=8>lecture #8</A> began here</font>
<p>



<h3> Removing Left Recursion </h3>


<pre>
E -> E + T | T
T -> T * F | F
F -> ( E ) | ident
</pre>

We can remove the left recursion by introducing new nonterminals
and new production rules.

<pre>
E  -> T E'
E' -> + T E' | &epsilon;
T  -> F T'
T' -> * F T' | &epsilon;
F  -> ( E ) | ident
</pre>

Getting rid of such <em>immediate left recursion</em> is not enough, one must
get rid of indirect left recursion, where two or more nonterminals are
mutually left-recursive.
One can rewrite <em>any</em> CFG to remove left recursion (Algorithm 4.1). 

<pre>
for i := 1 to n do
   for j := 1 to i-1 do begin
      replace each A<sub>i</sub> -&gt; A<sub>j</sub> gamma with productions
      A<sub>i</sub> -&gt; delta<sub>1</sub>gamma | delta<sub>2</sub>gamma
      end
   eliminate immediate left recursion
</pre>

<h3> Removing Left Recursion, part 2 </h3>

Left recursion can be broken into three cases
<p>
<h4>case 1: trivial</h4>

<pre>
A : A &alpha; | &beta;
</pre>

The recursion must always terminate by A finally deriving &beta; so you
can rewrite it to the equivalent
<pre>
A : &beta; A'
A' : &alpha; A' | &epsilon;
</pre>

Example:
<pre>
E : E op T | T
</pre>
can be rewritten
<pre>
E : T E'
E' : op T E' | &epsilon;
</pre>

<h4>case 2: non-trivial, but immediate</h4>

In the more general case, there may be multiple recursive productions
and/or multiple non-recursive productions.
<pre>
A : A &alpha;<sub>1</sub> | A &alpha;<sub>2</sub> | ... | &beta;<sub>1</sub> | &beta;<sub>2</sub>
</pre>

As in the trivial case, you get rid of left-recursing A and introduce an A'

<pre>
A :  &beta;<sub>1</sub> A' | &beta;<sub>2</sub> A' | ...
A' : &alpha;<sub>1</sub> A' | &alpha;<sub>2</sub> A' | ... | &epsilon;
</pre>


<h4> case 3: mutual recursion </h4>

<ol>
<li> Order the nonterminals in some order 1 to N.
<li> Rewrite production rules to eliminate all
     nonterminals in leftmost positions that refer to a "previous" nonterminal.
     When finished, all productions' right hand symbols start with a terminal
     or a nonterminal that is numbered equal or higher than the nonterminal
     no the left hand side.
<li> Eliminate the direct left recusion as per cases 1-2.
</ol>


<h4> Left Recursion Versus Right Recursion: When does it Matter? </h4>

A student came to me once with what they described as an operator precedence
problem where 5-4+3 was computing the wrong value (-2 instead of 4).  What
it really was, was an associativity problem due to the grammar:
<pre>
E : T + E | T - E | T
</pre>

The problem here is that right recursion is forcing right associativity, but
normal arithmetic requires left associativity.  Several solutions are:
(a) rewrite the grammar to be left recursive, or (b) rewrite the grammar
with more nonterminals to force the correct precedence/associativity,
or (c) if using YACC or Bison, there are "cheat codes" we will discuss later
to allow it to be majorly ambiguous and specify associativity separately
(look for %left and %right in YACC manuals).


<h3> Recursive Descent Parsing Example #2</h3>

The grammar

<pre>
S -> A B C
A -> a A
A -> <em>&epsilon;</em>
B -> b
C -> c
</pre>

maps to pseudocode like the following. (:= is an assignment operator)

<pre>
procedure S()
  if A() & B() & C() then succeed # matched S, we win
end

procedure A()
  if yychar == a then { # use production 2
     yychar := scan()
     return A()
     }
  else
     succeed # production rule 3, match &epsilon;
end

procedure B()
   if yychar == b then {
      yychar := scan()
      succeed
      }
   else fail
end

procedure C()
   if yychar == c then {
      yychar := scan()
      succeed
      }
   else fail
end
</pre>



<h3> Backtracking? </h3>


Could your current token begin more than one of your possible production rules?
Try all of them, remember and reset state for each try.
<pre>
S -> cAd
A -> ab
A -> a
</pre>

<em>Left factoring</em> can often solve such problems:

<pre>
S -> cAd
A -> a A'
A'-> b
A'-> (&epsilon;)
</pre>

One can also perform left factoring <!--(Algorithm 4.2)--> to reduce or
eliminate the lookahead or backtracking needed to tell which production rule
to use.  If the end result has no lookahead or backtracking needed, the
resulting CFG can be solved by a "predictive parser" and coded easily in a
conventional language.  If backtracking is needed, a recursive descent
parser takes more work to implement, but is still feasible.

As a more concrete example:

<pre>
S -> <b>if</b> E <b>then</b> S
S -> <b>if</b> E <b>then</b> S<sub>1</sub> else S<sub>2</sub>
</pre>

can be factored to:

<pre>
S -> <b>if</b> E <b>then</b> S S'
S'-> else S<sub>2</sub> | &epsilon;
</pre>

<h3> Some More Parsing Theory </h3>

Automatic techniques for constructing parsers start with computing some
basic functions for symbols in the grammar.  These functions are useful
in understanding both recursive descent and bottom-up LR parsers.

<h3> First(a) </h3>

First(a) is the set of terminals that begin strings derived from a,
which can include &epsilon;.

<ol>
<li> First(X) starts with the empty set.
<li> if X is a terminal, First(X) is {X}.
<li> if X -> &epsilon; is a production, add &epsilon; to First(X).
<li> if X is a non-terminal and X -> Y<sub>1</sub> Y<sub>2</sub> ... Y<sub>k</sub> is a production,
     add First(Y<sub>1</sub>) to First(X).
<li><pre>for (i = 1; if Y<sub>i</sub> can derive &epsilon;; i++)
        add First(Y<sub>i+1</sub>) to First(X)
</pre>
</ol>


<h3> First(a) examples </h3>

by the way, this stuff is all in section 4.3 in your text.
<p>
Last time we looked at an example with E, T, and F, and + and *.
The first-set computation was not too exciting and we need more
examples.

<pre>
stmt : if-stmt | OTHER
if-stmt:  IF LP expr RP stmt else-part
else-part: ELSE stmt | &epsilon;
expr: IDENT | INTLIT
</pre>

What are the First() sets of each nonterminal?


<h3> Follow(A) </h3>

Follow(A) for nonterminal A is the set of terminals that can appear
immediately to the right of A in some sentential form S -> aAxB...
To compute Follow, apply these rules to all nonterminals in the grammar:

<ol>
<li> Add $ to Follow(S)
<li> if A -> aBb then add First(b) - &epsilon; to Follow(B)
<li> if A -> aB or A -> aBb where &epsilon; is in First(b), then add
     Follow(A) to Follow(B).
</ol>

<p>
<font size=1> <A name=9>lecture #9</A> began here</font>
<p>

<h3> Last time: Follow() Example </h3>

For the grammar:

<pre>
stmt : if-stmt | OTHER
if-stmt:  IF LP expr RP stmt else-part
else-part: ELSE stmt | &epsilon;
expr: IDENT | INTLIT
</pre>

we got pretty muddy on the Follow() function, for even this simple grammar.
It helps if you follow the algorithm, instead of just "eyeballing it".

<pre>
For all non-terminals X in the grammar do
   1. if X is the start symbol, add $ to Follow(X)
   2. if N -&gt; &alpha;X&beta; then add First(&beta;) - &epsilon; to Follow(X)
   3. if N -&gt; &alpha;X or N -&gt; &alpha;X&beta; where &epsilon; is in
       First(&beta;) then add Follow(N) to Follow(X)
</pre>

Since the algorithm depends on First(), what are First sets again?
<pre>
First(stmt) = {IF, OTHER}
First(if-stmt) = {IF}
First(else-part) = {ELSE, &epsilon;}
First(expr) = {IDENT, INTLIT}
</pre>


Because each non-terminal has three steps, and our toy grammar has
4 non-terminals, there are 12 steps.
When you just apply these twelve steps, brute force, it is clear
that the statement of what to do to compute them was not an algorithm,
it was only a declarative specification, and there is an ordering needed
in order to compute the result.
<pre>
   1. stmt is the start symbol, add $ to Follow(stmt)
   2. if N -&gt; &alpha; stmt &beta; then add First(&beta;) - &epsilon; to Follow(stmt)
	---- add First(else-part)-&epsilon; to Follow(stmt)
   3. if N -&gt; &alpha; stmt or N -&gt; &alpha; stmt &beta; where &epsilon;
	 is in First(&beta;) then add Follow(N) to Follow(stmt)
	---- add Follow(else-part) to Follow(stmt)
   4. if-stmt is not the start symbol (noop)
   5. if N -&gt; &alpha;if-stmt&beta; then add First(&beta;) - &epsilon; to Follow(if-stmt)
	---- n/a
   6. if N -&gt; &alpha;if-stmt or N -&gt; &alpha;if-stmt&beta; where &epsilon; is in
       First(&beta;) then add Follow(N) to Follow(if-stmt)
	---- add Follow(stmt) to Follow(if-stmt)
   7. else-part is not the start symbol (noop)
   8. if N -&gt; &alpha;else-part&beta; then add First(&beta;) - &epsilon; to Follow(else-part)
	---- n/a
   9. if N -&gt; &alpha;else-part or N -&gt; &alpha;else-part&beta; where &epsilon; is in
       First(&beta;) then add Follow(N) to Follow(else-part)
	--- add Follow(if-stmt) to Follow(else-part)
   10. expr is not the start symbol (noop)
   11. if N -&gt; &alpha;expr&beta; then add First(&beta;) - &epsilon; to Follow(expr)
	---- add RP to Follow(expr)
   12. if N -&gt; &alpha;expr or N -&gt; &alpha;expr&beta; where &epsilon; is in
       First(&beta;) then add Follow(N) to Follow(expr)
	---- n/a
</pre>

What is the dependency graph? Does it have any cycles?  If it has cycles,
you will have to iterate to a fixed point.
<pre>
Follow(stmt) depends on Follow(else-part)
Follow(if-stmt) depends on Follow(stmt)
Follow(else-part) depends on Follow(if-stmt)
</pre>
If I read this right, there is a 3-way mutual recursion cycle.




<h3> On resizing arrays in C </h3>

The sval attribute in homework #2 is a perfect example of a problem which a
BCS major might not be expected to manage, but a CS major should be able to
do by the time they graduate.  This is not to encourage any of you to consider
BCS, but rather, to encourage you to learn how to solve problems like these.
<p>

The problem can be summarized as: step through yytext, copying each piece
out to sval, removing doublequotes and plusses between the pieces, and
evaluating CHR$() constants.<p>

Space allocated with malloc() can be increased in size by realloc().
realloc() is awesome.  But, it COPIES and MOVES the old chunk of
space you had to the new, resized chunk of space, and frees the old
space, so you had better not have any other pointers pointing at
that space if you realloc(), and you have to update your pointer to
point at the new location realloc() returns.

<pre>
i = 0; j = 0;
while (yytext[i] != '\0') {
   if (yytext[i] == '\"') {
      /* copy string into sval */
      i++;
      while (yytext[i] != '\"') {
         sval[j++] = yytext[i++];
         }
      }
   else if ((yytext[i] == 'C') || (yytext[i] == 'c')) {
      /* handle CHR$(...) */
      i += 5;
      k = atoi(yytext + i);
      sval[j++] = k;           /* might check for 0-255 */
      while (yytext[i] != ')') i++;
      }
   /* else we can just skip it */
   i++;
}
sval[j] = '\0'; /* NUL-terminate our string */
</pre>

There is one more problem: how do we allocate memory for sval, and how big
should it be?

<ul>
<li> Solution #1: sval = malloc(strlen(yytext)+1) is very safe, but wastes
     space.
<li> Solution #2: you could malloc a small amount and grow the array as
     needed.
<pre>
sval = strdup("");
...
sval = appendstring(sval, yytext[i]); /* instead of sval[j++] = yytext[i] */
</pre>
where the function appendstring could be:
<pre>
char *appendstring(char *s, char c)
{
    i = strlen(s);
    s = realloc(s, i+2);
    s[i] = c;
    s[i+1] = '\0';
    return s;
}
</pre>
Note: it is very inefficient to grow your array one character at
a time; in real life people grow arrays in large chunks at a time.

<li> Solution #3: use solution one and then shrink your array when you
find out how big it actually needs to be.
<pre>
sval = malloc(strlen(yytext)+1);
/* ... do the code copying into sval; be sure to NUL-terminate */
sval = realloc(sval, strlen(sval)+1);
</ul>

<p>
<font size=1> <A name=10>lecture #10</A> began here</font>
<p>


<A name=yacc>
<h3> YACC </h3>
</A>

YACC ("yet another compiler compiler") is a popular tool which originated at
AT&T Bell Labs.  YACC takes a context free grammar as input, and generates a
parser as output.  Several independent, compatible implementations (AT&amp;T
yacc, Berkeley yacc, GNU Bison) for C exist, as well as many implementations
for other popular languages.  <p>

YACC files end in .y and take the form
<pre>
declarations
%%
grammar
%%
subroutines
</pre>
The declarations section defines the terminal symbols (tokens) and
nonterminal symbols. The most useful declarations are:
<dl>
<dt> %token a
<dd> declares terminal symbol a; YACC can generate a set of #define's
that map these symbols onto integers, in a y.tab.h file. <em><b> Note: don't
#include your y.tab.h file from your grammar .y file, YACC generates the
same definitions and declarations directly in the .c file, and including
the .tab.h file will cause duplication errors.</b></em>
<dt> %start A
<dd> specifies the start symbol for the grammar (defaults to nonterminal
     on left side of the first production rule).
</dl>
<p>
The grammar gives the production rules, interspersed with program code
fragments called semantic actions that let the programmer do what's
desired when the grammar productions are reduced.  They follow the
syntax
<pre>
A : body ;
</pre>
Where body is a sequence of 0 or more terminals, nonterminals, or semantic
actions (code, in curly braces) separated by spaces.  As a notational
convenience, multiple production rules may be grouped together using the
vertical bar (|).


<h3> Bottom Up Parsing </h3>

Bottom up parsers start from the sequence of terminal symbols and work
their way back up to the start symbol by repeatedly replacing grammar
rules' right hand sides by the corresponding non-terminal.  This is
the reverse of the derivation process, and is called "reduction".
<p>

Example. For the grammar
<pre>
(1)	S->aABe
(2)	A->Abc
(3)	A->b
(4)	B->d
</pre>
the string "abbcde" can be parsed bottom-up by the following reduction
steps:
<pre>
abbcde
aAbcde
aAde
aABe
S
</pre>


<h3> Handles </h3>

Definition: a <em>handle</em> is a substring that
<ol>
<li> matches a right hand side of a production rule in the grammar and
<li> whose reduction to the nonterminal on the left hand side of that
     grammar rule is a step along the reverse of a rightmost derivation.
</ol>

<A name=shiftreduce>
<h3> Shift Reduce Parsing </h3>     
</A>

A shift-reduce parser performs its parsing using the following structure
<pre>
<u>Stack</u>					<u>Input</u>
$						w$
</pre>
At each step, the parser performs one of the following actions.
<ol>
<li> Shift one symbol from the input onto the parse stack
<li> Reduce one handle on the top of the parse stack. The symbols
     from the right hand side of a grammar rule are popped of the
     stack, and the nonterminal symbol is pushed on the stack in their place.
<li> Accept is the operation performed when the start symbol is alone
     on the parse stack and the input is empty.
<li> Error actions occur when no successful parse is possible.
</ol>


<h4> The YACC Value Stack </h4>

<ul>
<li> YACC's parse stack contains only "states"
<li> YACC maintains a parallel set of values
<li> $ is used in semantic actions to name elements on the value stack
<li> $$ denotes the value associated with the LHS (nonterminal) symbol
<li> $n denotes the value associated with RHS symbol at position n.
<li> Value stack typically used to construct the parse tree
<li> Typical rule with semantic action: A : b C d { $$ = tree(R,3,$1,$2,$3); }
<li> The default value stack is an array of integers
<li> The value stack can hold arbitrary values in an array of unions
<li> The union type is declared with %union and is named YYSTYPE
</ul>


<h4> Getting Lex and Yacc to talk </h4>

YACC uses a global variable named yylval, of type YYSTYPE, to receive
lexical information from the scanner.  Whatever is in this variable
each time yylex() returns to the parser will get copied over to the
top of the value stack when the token is shifted onto the parse stack.
<p>

You can either declare that struct token may appear in the %union,
and put a mixture of struct node and struct token on the value stack,
or you can allocate a "leaf" tree node, and point it at your struct
token.  Or you can use a tree type that allows tokens to include
their lexical information directly in the tree nodes.  If you have
more than one %union type possible, be prepared to see type conflicts
and to declare the types of all your nonterminals. <p>

Getting all this straight takes some time; you can plan on it.  Your best
bet is to draw pictures of how you want the trees to look, and then make the
code match the pictures.  No pictures == "Dr. J will ask to see your
pictures and not be able to help if you can't describe your trees."

<h3> Declaring value stack types for terminal and nonterminal symbols </h3>

Unless you are going to use the default (integer) value stack, you will
have to declare the types of the elements on the value stack.  Actually,
you do this by declaring which
union member is to be used for each terminal and nonterminal in the
grammar.
<p>
Example: in the cocogram.y that I gave you we could add a %union declaration
with a union member named treenode:
<pre>
%union {
  nodeptr treenode;
}
</pre>

This will produce a compile error if you haven't declared a nodeptr type
using a typedef, but that is another story.  To declare that a nonterminal
uses this union member, write something like:
<pre>
%type < treenode > function_definition
</pre>

Terminal symbols use %token to perform the corresponding declaration.
If you had a second %union member (say struct token *tokenptr) you
might write:
<pre>
%token < tokenptr > SEMICOL
</pre>


<h3> Announcements </h3>

<li> Having trouble debugging your grammar?  "bison -v" generates a .output
     file that gives the gory details of conflicts and such.

<p>
<font size=1> <A name=11>lecture #11</A> began here</font>
<p>


<h3> Conflicts in Shift-Reduce Parsing </h3>

"Conflicts" occur when an ambiguity in the grammar creates a situation
where the parser does not know which step to perform at a given point
during parsing.  There are two kinds of conflicts that occur.

<dl>
<dt> shift-reduce
<dd> a shift reduce conflict occurs when the grammar indicates that
     different successful parses might occur with either a shift or a reduce
     at a given point during parsing.  The vast majority of situations where
     this conflict occurs can be correctly resolved by shifting.
<dt> reduce-reduce
<dd> a reduce reduce conflict occurs when the parser has two or more
     handles at the same time on the top of the stack.  Whatever choice
     the parser makes is just as likely to be wrong as not.  In this case
     it is usually best to rewrite the grammar to eliminate the conflict,
     possibly by factoring.
</dl>

Example shift reduce conflict:
<pre>
S->if E then S
S->if E then S else S
</pre>
<P>
In many languages two nested "if" statements produce a situation where
an "else" clause could legally belong to either "if".  The usual rule
(to shift) attaches the else to the nearest (i.e. inner) if statement.
<p>

Example reduce reduce conflict:
<pre>
(1)	S -> id LP plist RP
(2)	S -> E GETS E
(3)	plist -> plist, p
(4)	plist -> p
(5)	p -> id
(6)	E -> id LP elist RP
(7)	E -> id
(8)	elist -> elist, E
(9)	elist -> E
</pre>
By the point the stack holds ...id LP id<br>
the parser will not know which rule to use to reduce the id: (5) or (7).

<h3> Further Discussion of Reduce Reduce and Shift Reduce Conflicts </h3>

The following grammar, based loosely on our expression grammar from
last time, illustrates a reduce reduce conflict, and how you have to
exercise care when using epsilon productions.  Epsilon productions
were helpful for some of the grammar rewriting methods, such as removing
left recursion, but used indiscriminately, they can cause much trouble.

<pre>
T : F | F T2 ;
T2 : p F T2 | ;
F : l T r | v ;
</pre>

The reduce-reduce conflict occurs after you have seen an F.  If the next
symbol is a p there is no question of what to do, but if the next symbol
is the end of file, do you reduce by rule #1 or #4 ?
<p>

A slightly different grammar is needed to demonstrate a shift-reduce conflict:

<pre>
T : F g;
T : F T2 g;
T2 : t F T2 ;
T2 : ;
F : l T r ;
F : v ;
</pre>

This grammar is not much different than before, and has the same problem,
but the surrounding context (the "calling environments") of F cause the
grammar to have a shift-reduce instead of reduce-reduce.  Once again,
the trouble is after you have seen an F and dwells on the question of
whether to reduce the epsilon production, or instead to shift, upon
seeing a token g.
<p>

The .output file generated by "bison -v" explains these conflicts in
considerable detail.  Part of what you need to interpret them are the
concepts of "items" and "sets of items" discussed below.


<A name=precedence>
<h4> YACC precedence and associativity declarations </h4>
</A>

YACC headers can specify precedence and associativity rules for otherwise
heavily ambiguous grammars.  Precedence is determined by increasing order
of these declarations.  Example:

<pre>
%right ASSIGN
%left PLUS MINUS
%left TIMES DIVIDE
%right POWER
%%
expr: expr ASSIGN expr
    | expr PLUS expr
    | expr MINUS expr
    | expr TIMES expr
    | expr DIVIDE expr
    | expr POWER expr
    ;
</pre>

<A name=yyerror>
<h4> YACC error handling and recovery </h4>
</A>
<ul>
<li> Use special predefined token <code>error</code> where errors expected
<li> On an error, the parser pops states until it enters one that has an
     action on the error token.
<li> For example: statement: error ';' ;
<li> The parser must see 3 good tokens before it decides it has recovered.
<li> yyerrok tells parser to skip the 3 token recovery rule
<li> yyclearin throws away the current (error-causing?) token
<li> yyerror(s) is called when a syntax error occurs (s is the error message)
</ul>

<p>
<font size=1> <A name=12>lecture #12</A> began here</font>
<p>

<h3> Improving YACC's Error Reporting </h3>

yyerror(s) overrides the default error message, which usually just says either
"syntax error" or "parse error", or "stack overflow".
<p>

You can easily add information in your own yyerror() function, for example
GCC emits messages that look like:
<pre>
goof.c:1: parse error before '}' token
</pre>
using a yyerror function that looks like
<pre>
void yyerror(char *s)
{
   fprintf(stderr, "%s:%d: %s before '%s' token\n",
	   yyfilename, yylineno, s, yytext);
}
</pre>
<p>

You could instead, use the error recovery mechanism to produce better messages.
For example
<pre>
lbrace : LBRACE | { error_code=MISSING_LBRACE; } error ;
</pre>
Where LBRACE is an expected token {<br>
This uses a global variable error_code to pass parse information to yyerror().
<p>
Another related option is to call yyerror() explicitly with a better message
string, and tell the parser to recover explicitly:
<pre>
package_declaration: PACKAGE_TK error
	{ yyerror("Missing name"); yyerrok; } ;
</pre>
<p>

But, using error recovery to perform better error reporting runs against
conventional wisdom that you should use error tokens very sparingly.
What information from the parser determined we had an error in the first
place?  Can we use that information to produce a better error message?


<h3> LR Syntax Error Messages: Advanced Methods </h3>

The pieces of information that YACC/Bison use to determine that there
is an error in the first place are the parse state (yystate) and the
current input token (yychar). These are exactly the pieces of information
one might use to produce better diagnostic error messages without
relying on the error recovery mechanism and mucking up the grammar
with a lot of extra production rules that feature the <code>error</code> token.
<p>

Even just the parse state is enough to do pretty good error messages.
yystate is not part of YACC's public interface, though, so you may
have to play some tricks to pass it as a parameter into yyerror() from
yyparse().  Say, for example:
<pre>
#define yyerror(s) __yyerror(s,yystate)
</pre>

Inside __yyerror(msg, yystate) you can use a switch statement or a global
array to associate messages with specific parse states.  But, figuring
out which parse state means which syntax error message would be by trial
and error.
<p>

A tool called Merr is available that let's you generate this yyerror
function from examples: you supply the sample syntax errors and messages,
and Merr figures out which parse state integer goes with which message.
Merr also uses the yychar (current input token) to refine the diagnostics
in the event that two of your example errors occur on the same parse state.
See the <A href="http://unicon.sf.net/merr/">Merr</A> web page.

<p>
<font size=1> <A name=13>lecture #13</A> began here</font>
<p>

<!--
There are test cases posted on the class website.  If you create additional
test cases, turn them in (say, in a subdirectory test/ in your tar file).
Extra credit will be awarded to the best suite of test cases.-->


<h3> LR vs. LL vs. LR(0) vs. LR(1) vs. LALR(1) </h3>

The first char ("L") means input tokens are read from the left
(left to right).  The second char ("R" or "L") means parsing
finds the rightmost, or leftmost, derivation.  Relevant
if there is ambiguity in the grammar.  (0) or (1) or (k) after
the main lettering indicates how many lookahead characters are
used.  (0) means you only look at the parse stack, (1) means you
use the current token in deciding what to do, shift or reduce.
(k) means you look at the next k tokens before deciding what
to do at the current position.


<h3> LR Parsers </h3>

LR denotes a class of bottom up parsers that is capable of handling virtually
all programming language constructs.  LR is efficient; it runs in linear time
with no backtracking needed.  The class of languages handled by LR is a proper
superset of the class of languages handled by top down "predictive parsers".
LR parsing detects an error as soon as it is possible to do so.  Generally
building an LR parser is too big and complicated a job to do by hand, we use
tools to generate LR parsers.
<p>


The LR parsing algorithm is given below.<!--See Figure 4.29 for a schematic.-->
<pre>
ip = first symbol of input
repeat {
   s = state on top of parse stack
   a = *ip
   case action[s,a] of {
      SHIFT s': { push(a); push(s') }
      REDUCE A->beta: {
         pop 2*|beta| symbols; s' = new state on top
         push A
         push goto(s', A)
         }
      ACCEPT: return 0 /* success */
      ERROR: { error("syntax error", s, a); halt }
      }
   }
</pre>



<!--
<h3> Little-known Mysteries of the BASIC Language </h3>

<ul>
<li> BASIC has arrays.  They default to a size of 11 elements.
     Other array sizes are specified via a DIM statement, as in:<br>
     10 DIM A(100)
<li> BASIC has three versions of every variable name (number, string, array)
<li> Variables in BASIC are preinitialized to 0.
<li> PRINT statements have multiple arguments (implicit concatenation?)
<li> PRINT statements can have commas or semicolons between their arguments
<li> Some of our tests have syntax errors; others use features (e.g. graphics)
     that are beyond our scope. Extra credit, but only if you catch up first.
<li> cocogram.y is not infallible, you are to fix it, and then brag about it
<li> Jimenez' COCO emulator is how I test what should and should not work.
</ul>
-->

<p>

<H3>Constructing SLR Parsing Tables: </H3>

<P>
<DFN>Definition: An LR(0) item of a grammar G is a production
of G with a dot at some position of the RHS.</DFN>
<P>
Example: The production A-&gt;aAb gives the items: 
<P>
A -&gt; . a A b<br>
A -&gt; a . A b<br>
A -&gt; a A . b<br>
A -&gt; a A b .
<P>
Note: A production A-&gt; &epsilon; generates
only one item:
<P>
A -&gt; .
<P>
Intuition: an item A-&gt; &alpha; . &beta; denotes:
<OL>
<LI>&alpha; - we have already seen a string
derivable from &alpha;
<LI>&beta; - we hope to see a string derivable
from &beta;
</OL>

<H3>Functions on Sets of Items </H3>

<P>
<DFN>Closure: if I is a set of items for a grammar G, then closure(I)
is the set of items constructed as follows:</DFN>
<OL>
<LI><DFN>Every item in I is in closure(I).</DFN>
<LI><DFN>If A-&gt;</DFN>&alpha; . <DFN>B</DFN>&beta;<DFN>
is in closure(I) and B-&gt;</DFN>&gamma;<DFN>
is a production, then add B-&gt; .</DFN>&gamma;<DFN>
to closure(I).</DFN> 
</OL>

<P>
These two rules are applied repeatedly until no new items can
be added.
<P>
Intuition: If A -&gt; &alpha; . B &beta; is in
closure(I) then we hope to see a string derivable from B in the
input. So if B-&gt; &gamma; is a production,
we should hope to see a string derivable from &gamma;.
Hence, B-&gt;.&gamma; is in closure(I).<BR>

<P>
Goto: if I is a set of items and X is a grammar symbol, then goto(I,X)
is defined to be:
<P>
goto(I,X) = closure({[A-&gt;&alpha;X.&beta;] | [A-&gt;&alpha;.X&beta;]
is in I})
<P>
Intuition: 
<UL>
<LI>[A-&gt;&alpha;.X&beta;]
is in I =&gt; we've seen a string derivable
from &alpha;; we hope to see a string derivable
from X&beta;.
<LI>Now suppose we see a string derivable from X
<LI>Then, we should &quot;goto&quot; a state where we've seen
a string derivable from &alpha;X, and where
we hope to see a string derivable from &beta;.
The item corresponding to this is [A-&gt;&alpha;X.&beta;] 
</UL>


<UL>
<LI>Example: Consider the grammar
</UL>

<PRE>
<FONT SIZE=3>	E -&gt; E+T | T
	T -&gt; T*F | F
	F -&gt; (E) | id 
</font></pre>

&nbsp;
&nbsp;
&nbsp;
&nbsp;
&nbsp;
&nbsp;
&nbsp;
Let I = {[E -&gt; E . + T]} then:
<pre><font size=3>        goto(I,+) = closure({[E -&gt; E+.T]})
		  = closure({[E -&gt; E+.T], [E -&gt; .T*F], [T -&gt; .F]})
		  = closure({[E -&gt; E+.T], [E -&gt; .T*F], [T -&gt; .F], [F-&gt; .(E)], [F -&gt; .id]})
		  = { [E -&gt; E + .T],[T -&gt; .T * F],[T -&gt; .F],[F -&gt; .(E)],[F -&gt; .id]}</FONT>
</PRE>

<H3>The Sets of Items Construction</H3>

<OL>
<LI>Given a grammar G with start symbol S, construct the augmented
grammar by adding a special production S'-&gt;S where S' does
not appear in G.
<LI>Algorithm for constructing the canonical collection of LR(0)
items for an augmented grammar G': 
</OL>

<P>
<FONT SIZE=3 FACE="Courier New"></FONT>
<PRE>
<TT>	begin
	   C := { closure({[S' -&gt; .S]}) };
</TT>	   <TT>repeat
	      for each set of items I in C:
		  for each grammar symbol X:
   		     if goto(I,X) != 0 and goto(I,X) is not in C then
		 	 add goto(I,X) to C;
	   until no new sets of items can be added to C;
	   return C;
	end<BR>
</TT>
</PRE>


<P>
<DFN>Valid Items: an item A -&gt; </DFN>&beta;<DFN><SUB>
1</SUB>. </DFN>&beta;<DFN> <SUB>2</SUB>
 is valid for a viable prefix </DFN>&alpha;<DFN>
</DFN>&beta;<DFN><SUB> 1  </SUB>if
there is a derivation:</DFN>
<PRE>
<FONT SIZE=3 FACE="Courier New">S' =&gt;<SUP>*</SUP><SUB>rm</SUB> </FONT>&alpha;<FONT SIZE=3 FACE="Courier New">A</FONT>&omega;<FONT SIZE=3 FACE="Courier New"> =&gt;<SUP>*</SUP><SUB>rm</SUB></FONT>&alpha; &beta;<SUB><FONT SIZE=3 FACE="Courier New">1</FONT></SUB>&beta;<SUB><FONT SIZE=3 FACE="Courier New"> 2</FONT></SUB>&omega;
</PRE>

<P>
Suppose A -&gt; &beta;<SUB>1</SUB>.&beta; <sub>2</sub> is valid for &alpha;&beta;<SUB>1</SUB>,
and &alpha;B<SUB>1</SUB> is on the parsing
stack
<OL>
<LI>if &beta;<SUB>2</SUB> != &epsilon;,
we should shift
<LI>if &beta;<SUB>2</SUB> = &epsilon;,
A -&gt; &beta;<SUB>1</SUB> is the handle,
and we should reduce by this production 
</OL>

<P>
Note: two valid items may tell us to do different things for the
same viable prefix. Some of these conflicts can be resolved using
lookahead on the input string. 
<H3>Constructing an SLR Parsing Table</H3>

<OL>
<LI>Given a grammar G, construct the augmented grammar by adding
the production S' -&gt; S.
<LI>Construct C = {I<SUB>0</SUB>, I<SUB>1</SUB>, &#133; I<SUB>n</SUB>},
the set of sets of LR(0) items for G'.
<LI>State I is constructed from I<SUB>i</SUB>, with parsing action
determined as follows:
<UL>
<LI>[A -&gt; &alpha;.aB] is in
I<SUB>i</SUB>, where a is a terminal; goto(I<SUB>i</SUB>,a) = I<SUB>j</SUB>
: set action[i,a] = &quot;shift j&quot;
<LI>[A -&gt; &alpha;.] is in
I<SUB>i</SUB> : set action[i,a] to &quot;reduce A -&gt; x&quot;
for all a e FOLLOW(A), where A != S'
<LI>[S' -&gt; S] is in I<SUB>i</SUB> :
set action[i,$] to &quot;accept&quot; 
</UL>

<LI>goto transitions constructed as follows: for all non-terminals:
if goto(I<SUB>i</SUB>, A) = I<SUB>j</SUB>, then goto[i,A] = j
<LI>All entries not defined by (3) &amp; (4) are made &quot;error&quot;.
If there are any multiply defined entries, grammar is not SLR.
<LI>Initial state S<SUB>0</SUB> of parser: that constructed from
I<SUB>0</SUB> or [S' -&gt; S] 
</OL>

<P>

<P>
Example:
<PRE>
<FONT SIZE=3>	S -&gt; aABe		FIRST(S) = {a}		FOLLOW(S) = {$}
	A -&gt; Abc		FIRST{A} = {b}		FOLLOW(A) = {b,d}
	A -&gt; b			FIRST{B} = {d}		FOLLOW{B} = {e}
	B -&gt; d			FIRST{S'}= {a}		FOLLOW{S'}= {$}
</FONT>I<SUB>0</SUB><FONT FACE="Courier New"> = closure([S'-&gt;.S]
   = closure([S'-&gt;.S],[S-&gt;.aABe])
goto(I<SUB>0</SUB>,S) = closure([S'-&gt;S.]) = I<SUB>1
</SUB>goto(I<SUB>0</SUB>,a) = closure([S-&gt;a.Abe])
	    = closure([S-&gt;a.Abe],[A-&gt;.Abc],[A-&gt;.b]) = I<SUB>2
</SUB>goto(I<SUB>2</SUB>,A) = closure([S-&gt;aA.Be],[A-&gt;A.bc])
	    = closure([S-&gt;aA.Be],[A-&gt;A.bc],[B-&gt;.d]) = I<SUB>3
</SUB>goto(I<SUB>2</SUB>,B) = closure([A-&gt;b.]) = I<SUB>4
</SUB>goto(I<SUB>3</SUB>,B) = closure([S-&gt;aAB.e]) = I<SUB>5
</SUB>goto(I<SUB>3</SUB>,b) = closure([A-&gt;Ab.c]) = I<SUB>6
</SUB>goto(I<SUB>3</SUB>,d) = closure([B-&gt;d.]) = I<SUB>7
</SUB>goto(I<SUB>5</SUB>,e) = closure([S-&gt;aABe.]) = I<SUB>8
</SUB>goto(I<SUB>6</SUB>,c) = closure([A-&gt;Abc.]) = I<SUB>9</SUB></FONT>
</PRE>




<h3> On Tree Traversals </h3>

Trees are classic data structures.  Trees have nodes and edges, so they are
a special case of graphs.  Tree edges are directional, with roles "parent"
and "child" attributed to the source and destination of the edge.
A tree has the property that every node has zero or one parent.  A node
with no parents is called a root.  A node with no children is called a leaf.
A node that is neither a root nor a leaf is an "internal node".  Trees have
a size (total # of nodes), a height (maximum count of nodes from root to a leaf),
and an "arity" (maximum number of children in any one node).
<p>

Parse trees are k-ary, where there is a
variable number of children bounded by a value k determined by the grammar.
You may wish to consult your old data structures book, or look at some books
from the library, to learn more about trees if you are not totally
comfortable with them.

<p>
<pre>
#include &lt;stdarg.h&gt;

struct tree {
   short label;			/* what production rule this came from */
   short nkids;			/* how many children it really has */
   struct tree *child[1];	/* array of children, size varies 0..k */
};

struct tree *alctree(int label, int nkids, ...)
{
   int i;
   va_list ap;
   struct tree *ptr = malloc(sizeof(struct tree) +
                             (nkids-1)*sizeof(struct tree *));
   if (ptr == NULL) {fprintf(stderr, "alctree out of memory\n"); exit(1); }
   ptr-&gt;label = label;
   ptr-&gt;nkids = nkids;
   va_start(ap, nkids);
   for(i=0; i &lt; nkids; i++)
      ptr-&gt;child[i] = va_arg(ap, struct tree *);
   va_end(ap);
   return ptr;
}
</pre>
<P>

Besides a function to allocate trees, you need to write one or more recursive
functions to visit each node in the tree, either top to bottom (preorder),
or bottom to top (postorder).  You might do many different traversals on the
tree in order to write a whole compiler: check types, generate machine-
independent intermediate code, analyze the code to make it shorter, etc.
You can write 4 or more different traversal functions, or you can write
1 traversal function that does different work at each node, determined by
passing in a function pointer, to be called for each node.

<pre>
void postorder(struct tree *t, void (*f)(struct tree *))
{
   /* postorder means visit each child, then do work at the parent */
   int i;
   if (t == NULL) return;

   /* visit each child */
   for (i=0; i &lt; t-&gt; nkids; i++)
      postorder(t->child[i], f);

   /* do work at parent */
   f(t);
}
</pre>

You would then be free to write as many little helper functions as you
want, for different tree traversals, for example:
<pre>
void printer(struct tree *t)
{
   if (t == NULL) return;
   printf("%p: %d, %d children\n", t, t->label, t->nkids);
}
</pre>

<p>
<font size=1> <A name=14>lecture #14</A> began here</font>
<p>

<h3> Comment on ECTOScript: Best Grammar Options </h3>

<ul>
<li> elastic.y yacc grammar wasn't actionscripty enough
<li> found one more ecmascript grammar, <A href="scriptonite.y">scriptonite's</A>, once a again, not a yacc grammar
<li> options for hw3 are: switch to antlr or sablecc, trim lexical stuff
       from antlr/sablecc grammar and use bison, or derive yacc grammar from
sections 11-14 of
<A href="http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf">the ECMA 262 standard</A>

</ul>
If we produce a working yacc/bison grammar by either method, we will probably
be able to post it for some minor degree of internet fame.


<A name="semantic">
<h3> Semantic Analysis </h3>
</A>

Semantic ("meaning") analysis refers to a phase of compilation in which the
input program is studied in order to determine what operations are to be
carried out.  The two primary components of a classic semantic analysis
phase are variable reference analysis and type checking.  These components
both rely on an underlying symbol table.
<p>

What we <em>have</em> at the start of semantic analysis is a syntax tree that
corresponds to the source program as parsed using the context free grammar.
Semantic information is added by annotating grammar symbols with
<em>semantic attributes</em>, which are defined by <em>semantic rules</em>.
A semantic rule is a specification of how to calculate a semantic attribute
that is to be added to the parse tree.
<p>
So the input is a syntax tree...and the output is the same tree, only
"fatter" in the sense that nodes carry more information. 
Another output of semantic analysis are error messages detecting many
types of semantic errors.
<p>

Two typical examples of semantic analysis include:
<dl>
<dt> variable reference analysis
<dd> the compiler must determine, for each use of a variable, which
     variable declaration corresponds to that use.  This depends on
     the semantics of the source language being translated.
<dt> type checking
<dd> the compiler must determine, for each operation in the source code,
     the types of the operands and resulting value, if any.
</dl>
<p>

Notations used in semantic analysis:<br>
<dl>
<dt> <strong><u>syntax-directed definitions</u></strong> </dt>
<dd> high-level (<em>declarative</em>) specifications of semantic rules </dd>
<dt> <strong><u>translation schemes</u></strong> </dt>
<dd> semantic rules and the order in which they get evaluated </dd>
</dl>
<p>

In practice, attributes get <em>stored</em> in parse tree nodes, and the
semantic rules are evaluated either (a) during parsing (for easy rules) or
(b) during one or more (sub)tree traversals.
<p>


<h3> Two Types of Attributes:</h3>
<dl>
<dt> synthesized
<dd> attributes computed from information contained within one's children.
     These are generally easy to compute, even on-the-fly during parsing.
<dt> inherited
<dd> attributes computed from information obtained from one's parent or siblings
     These are generally harder to compute.  Compilers may be able to jump
     through hoops to compute some inherited attributes during parsing,
     but depending on the semantic rules this may not be possible in general.
     Compilers resort to tree traversals to move semantic information around
     the tree to where it will be used.
</dl>


<h3> Attribute Examples </h3>

<h4> Isconst and Value </h4>

Not all expressions have constant values; the ones that do may allow
various optimizations.

<table border>
<tr>
<th> CFG	<th> Semantic Rule
</tr>
<tr>
<td>
E<sub>1</sub> : E<sub>2</sub> + T
<td>
E<sub>1</sub>.isconst = E<sub>2</sub>.isconst && T.isconst<br>
if (E<sub>1</sub>.isconst)<br>
&nbsp;&nbsp;&nbsp; E<sub>1</sub>.value = E<sub>2</sub>.value + T.value<br>
</tr>
<tr>
<td>
E : T
<td>
E.isconst = T.isconst<br>
if (E.isconst)<br>
&nbsp;&nbsp;&nbsp; E.value = T.value<br>
</tr>
<tr>
<td>
T : T * F
<td>
T<sub>1</sub>.isconst = T<sub>2</sub>.isconst && F.isconst<br>
if (T<sub>1</sub>.isconst)<br>
&nbsp;&nbsp;&nbsp; T<sub>1</sub>.value = T<sub>2</sub>.value * F.value<br>
</tr>
<tr>
<td>
T : F
<td>
T.isconst = F.isconst<br>
if (T.isconst)<br>
&nbsp;&nbsp;&nbsp; T.value = F.value<br>
</tr>
<tr>
<td>
F : ( E )
<td>
F.isconst = E.isconst<br>
if (F.isconst)<br>
&nbsp;&nbsp;&nbsp; F.value = E.value<br>
</tr>
<tr>
<td>
F : ident
<td>
F.isconst = FALSE<br>
</tr>
<tr>
<td>
F : intlit
<td>
F.isconst = TRUE<br>
F.value = intlit.ival<br>
<td>
</tr>
</table>

<p>
<font size=1> <A name=15>lecture #15</A> began here</font>
<p>

<h3> Questions ? </h3>


<h3> Symbol Table Module </h3>

Symbol tables are used to resolve names within name spaces. Symbol
tables are generally organized hierarchically according to the
scope rules of the language.  Although initially concerned with simply
storing the names of various that are visible in each scope, symbol
tables take on additional roles in the remaining phases of the compiler.
In semantic analysis, they store type information.  And for code generation,
they store memory addresses and sizes of variables.
<p>

<dl>
<dt> mktable(parent)
<dd> creates a new symbol table, whose scope is local to (or inside) parent
<dt> enter(table, symbolname, type, offset)
<dd> insert a symbol into a table
<dt> lookup(table, symbolname)
<dd> lookup a symbol in a table; returns structure pointer including type and offset.  lookup operations are often <em>chained</em> together progressively from most local scope on out to global scope.
<dt> addwidth(table)
<dd> sums the widths of all entries in the table.  ("widths" = #bytes, sum of
   widths = #bytes needed for an "activation record" or "global data section").
   Worry not about this method until code generation you wish to implement.
<dt>enterproc(table, name, newtable)
<dd> enters the local scope of the named procedure
</dl>

<h3> Variable Reference Analysis </h3>

The simplest use of a symbol table would check:

<ul>
<li> for each variable, has it been declared?  (undeclared error)
<li> for each declaration, is it already declared? (redeclared error)
</ul>


<h4> Reading Tree Leaves </h4>

In order to work with your tree, you must be able to tell, preferably
trivially easily, which nodes are tree leaves and which are internal nodes,
and for the leaves, how to access the lexical attributes.
<p>
Options:
<ol>
<li> encode in the parent what the types of children are
<li> encode in each child what its own type is (better)
</ol>
How do you do option #2 here?
<p>
Perhaps the best approach to all this is to unify the tokens and parse tree
nodes with something like the following, where perhaps an nkids value of -1
is treated as a flag that tells the reader to use
lexical information instead of pointers to children:

<pre>
struct node {
int code;		/* terminal or nonterminal symbol */
int nkids;
union {
   struct token { ...  } leaf;
   struct node *kids[9];
   }u;
} ;
</pre>

There are actually nonterminal symbols with 0 children (nonterminal with
a righthand side with 0 symbols) so you don't necessarily want to use
an nkids of 0 is your flag to say that you are a leaf.



<h4> Type Checking </h4>

Perhaps the primary component of semantic analysis in many traditional
compilers consists of the type checker.  In order to check types, one first
must have a representation of those types (a type system) and then one must
implement comparison and composition operators on those types using the
semantic rules of the source language being compiled.  Lastly, type checking
will involve adding (mostly-) synthesized attributes through those parts of
the language grammar that involve expressions and values.

<h4> Type Systems </h4>

Types are defined recursively according to rules defined by the source
language being compiled. A type system might start with rules like:

<ul>
<li> Base types (int, char, etc.) are types
<li> Named types (via typedef, etc.) are types
<li> Types composed using other types are types, for example:
    <ul>
    <li> array(T, indices) is a type. In some
         languages indices always start with 0, so array(T, size) works.
    <li> T1 x T2 is a type (specifying, more or
         less, the tuple or sequence T1 followed by T2;
	 x is a so-called cross-product operator).
    <li> record((f1 x T1) x (f2 x T2) x ... x (fn x Tn)) is a type
    <li> in languages with pointers, pointer(T) is a type
    <li> (T<sub>1</sub> x ... T<sub>n</sub>) -> T<sub>n+1</sub> is a
         type denoting a function mapping parameter types to a return type
    </ul>
<li> In some language type expressions may contain variables whose values
     are types.
</ul>

In addition, a type system includes rules for assigning these types
to the various parts of the program; usually this will be performed
using attributes assigned to grammar symbols.

<p>
<font size=1> <A name=16>lecture #16</A> began here</font>
<p>

<h3> Midterm Exam Review </h3>

The Midterm will cover lexical analysis, finite automatas, context free
grammars, syntax analysis, and parsing.  Sample problems:

<ol>
<li> Write a regular expression for numeric quantities of U.S. money
     that start with a dollar sign, followed by one or more digits.
     Require a comma between every three digits, as in $7,321,212.
     Also, allow but do not require a decimal point followed by two
     digits at the end, as in $5.99
<li> Use Thompson's construction to write a non-deterministic finite
     automaton for the following regular expression, an abstraction
     of the expression used for real number literal values in C.<pre>
     (d+pd*|d*pd+)(ed+)? </pre>
<li> Write a regular expression, or explain why you can't write a
     regular expression, for Modula-2 comments which use (* *) as
     their boundaries.  Unlike C, Modula-2 comments may be nested,
     as in (* this is a (* nested *) comment *)
<li> Write a context free grammar for the subset of C expressions
     that include identifiers and function calls with parameters.
     Parameters may themselves be function calls, as in f(g(x)),
     or h(a,b,i(j(k,l)))
<li> What are the FIRST(E) and FOLLOW(T) in the grammar: <pre>
     E : E + T | T
     T : T * F | F
     F : ( E ) | <b>ident</b></pre>
<li> What is the &epsilon;-closure(move({2,4},b)) in the following NFA?
     That is, suppose you might be in either state 2 or 4 at the time
     you see a symbol b: what NFA states might you find yourself in
     after consuming b?<br> (<em>automata to be written on the board</em>)
</ol>

Q: What <em>else</em> is likely to appear on the midterm?
<p>

A: questions that allow you to demonstrate that you know the difference
   between an DFA and an NFA, questions about lex and flex and tokens
   and lexical attributes, questions about context free grammars:
   ambiguity, factoring, removing left recursion, etc.


<h3> On the mysterious TYPE_NAME </h3>

The C language typedef construct is an example where all the beautiful
theory we've used up to this point breaks down.  Once a typedef is
introduced (which can first be recognized at the syntax level), certain
identifiers should be legal type names instead of identifiers.  To make
things worse, they are still legal variable names: the lexical analyzer
has to know whether the syntactic context needs a type name or an
identifier at each point in which it runs into one of these names. This
sort of feedback from syntax or semantic analysis back into lexical
analysis is not un-doable but it requires extensions added by hand to
the machine generated lexical and syntax analyzer code.
<p>
<pre>
typedef int foo;
foo x;                    /* a normal use of typedef... */
foo foo;                  /* try this on gcc! is it a legal global? */
void main() { foo foo; }  /* what about this ? */
</pre>
<p>

445-C does not support typedef's and without working typedef's the
TYPE_NAME token simply will never occur. Typedef's are fair game for
extra credit points.


<h3> Representing C (C++, Java, etc.) Types </h3>

The type system is represented using data structures in the compiler's
implementation language.
In the symbol table and in the parse tree attributes used in type checking,
there is a need to represent and compare source language types.  You might
start by trying to assign a numeric code to each type, kind of like the
integers used to denote each terminal symbol and each production rule of the
grammar.  But what about arrays?  What about structs?  There are an infinite
number of types; any attempt to enumerate them will fail.  Instead, you
should create a new data type to explicitly represent type information.
This might look something like the following:
<p>

<pre>struct c_type {
   int base_type;    /* 1 = int, 2=float, ... */
   union {
      struct array {
         int size;
	 struct c_type *elemtype;
      } a;
      struct ctype *p;
      struct struc {
         char *label;
         struct field **f;
	 } s;
   } u;
}

struct field {
   char *name;
   struct ctype *elemtype;
}

</pre>

Given this representation, how would you initialize a variable to
represent each of the following types:

<pre>
int [10][20]
struct foo { int x; char *s; }
</pre>


<h3> Example Semantic Rules for Type Checking </h3>

<table border>
<tr>
<th> grammar rule <th> semantic rule
<tr>
<td>E<sub>1</sub> : E<sub>2</sub> PLUS E<sub>3</sub>
<td>E<sub>1</sub>.type = check_types(PLUS, E<sub>2</sub>.type, E<sub>3</sub>.type)
<tr>
</table>

Where check_types() returns a (struct c_type *) value.  One of the values
it should be able to return is Error.  The operator (PLUS) is included in
the check types function because behavior may depend on the operator --
the result type for array subscripting works different than the result
type for the arithmetic operators, which may work different (in some
languages) than the result type for logical operators that return booleans.


<h3>Type Promotion and Type Equivalence</h3>

When is it legal to perform an assignment x = y?  When x and y are
identical types, sure.  Many languages such as C have automatic
promotion rules for scalar types such as shorts and longs.
The results of type checking may include not just a type attribute,
they may include a type conversion, which is best represented by
inserting a new node in the tree to denote the promoted value.
Example:
<pre>
int x;
long y;
y = y + x;
</pre>
<p>

For records/structures, some languages use name equivalence, while
others use structure equivalence.  Features like typedef complicate
matters.  If you have a new type name MY_INT that is defined to be
an int, is it compatible to pass as a parameter to a function that
expects regular int's?  Object-oriented languages also get interesting
during type checking, since subclasses usually are allowed anyplace
their superclass would be allowed.

<p>
<font size=1> <A name=17>lecture #17</A> began here</font>
<p>

<h3> What range of syntactic and semantic analysis do we need for AS 3?</h3>

Our subset is: what's used in TrafficSense.
<p>

Looking again at <A href="flat/">flat.zip</A> we see...

<p>
<em> Remainder of class spent discussing aspects of how to approach
unique grammar issues for ActionScript.  Conclusion was that the first
ANTLR grammar was the only one that appeared complete enough to be
talking e.g. about classes, which we will need. </em>


<h3> Implementing Structs (a C thing; we need to ask AS3-specifics) </h3>

<ol>
<li> storing and retrieving structs by their label -- the struct label is
    how structs are identified.  You do not have to do typedefs and such.
    The labels can be keys in a separate hash table, similar to the global
    symbol table.  You can put them in the global symbol table so long as
    you can tell the difference between them and variable names.

<li> You have to store fieldnames and their types, from where the struct is
    declared.  You could use a hash table for each struct, but a link list
    is OK as an alternative.

<li> You have to use the struct information to check the validity of each
    dot operator like in rec.foo.  To do this you'll have to lookup rec
    in the symbol table, where you store rec's type.  rec's type must be
    a struct type for the dot to be legal, and that struct type should
    include a hash table or link list that gives the names and types of
    the fields -- where you can lookup the name foo to find its type.
</ol>


<p>
<font size=1> <A name=18>lecture #18</A> began here</font>
<p>

<h3> HW#2 Almost Graded </h3>

Ran all last night, saw enough to know that there was excessive code sharing
in one or more cases,
perhaps you already told me about it. If you copied code to or from a
classmate, please see me and remind me who wrote what, and how you think
you should be graded relative to peers who actually did their one work.
<p>
Reminder on class policy: if anything is shared it in this class (e.g. yacc
grammar, or donuts) it must be shared with the whole class.  Otherwise, it
ruins the level playing field and makes grading impossible...so I will give
zeros.

<h3> ActionScript Examples </h3>

In order to write a compiler for it, maybe first, we should actually
learn actionscript (see: "Bill and Ted's Excellent Adventure").
<P>

Here is a raft of ActionScript 3 examples:
<ul>
<li> <A href="http://faculty.purchase.edu/jeanine.meyer/as30/flashas3labs.html">Game Programs</A>
<li> <a href="http://franto.com/collected-links-to-actionscript-30-examples/">
Actionscript Examples/</A>
</ul>

But since this is compiler class, I don't want to run the examples, I want
to parse them and then do semantic analysis on them.



<h3>Run-time Environments </h3>

How does a compiler (or a linker) compute the addresses for the various
instructions and references to data that appear in the program source code?
To generate code for it, the compiler has to "lay out" the data as it will
be used at runtime, deciding how big things are, and where they will go.

<ul>
<li> Relationship between source code names and data objects during execution
<li> Procedure activations
<li> Memory management and layout
<li> Library functions
</ul>


<h4> Announcements </h4>


<h4> Scopes and Bindings </h4>

Variables may be declared explicitly or implicitly in some languages
<p>

Scope rules for each language determine how to go from names to declarations.
<p>

Each use of a variable name must be associated with a declaration.
This is generally done via a symbol table. In most compiled languages
it happens at compile time (in contrast, for example ,with LISP).

<h4> Environment and State </h4>

Environment maps source code names onto storage addresses (at compile time),
while state maps storage addresses into values (at runtime).  Environment
relies on binding rules and is used in code generation; state operations
are loads/stores into memory, as well as allocations and deallocations.
Environment is concerned with scope rules, state is concerned with things
like the lifetimes of variables.


<h4> Runtime Memory Regions </h4>

Operating systems vary in terms of how the organize program memory
for runtime execution, but a typical scheme looks like this:

<table border>
<tr><th>code
<tr><th>static data
<tr><th>stack (grows down)
<tr><td>heap (may grow up, from bottom of address space)
</table>

The code section may be read-only, and shared among multiple instances
of a program.  Dynamic loading may introduce multiple code regions, which
may not be contiguous, and some of them may be shared by different programs.
The static data area may consist of two sections, one for "initialized data",
and one section for uninitialized (i.e. all zero's at the beginning).
Some OS'es place the heap at the very end of the address space, with a big
hole so either the stack or the heap may grow arbitrarily large.  Other OS'es
fix the stack size and place the heap above the stack and grow it down.

<h4> Questions to ask about a language, before writing its code generator</h4>

<ol>
<li> May procedures be recursive? (Duh, all modern languages...)
<li> What happens to locals when a procedure returns? (Lazy deallocation rare)
<li> May a procedure refer to non-local, non-global names?
     (Pascal-style nested procedures, and object field names)
<li> How are parameters passed? (Many styles possible, different
     declarations for each (Pascal), rules hardwired by type (C)?)
<li> May procedures be passed as parameters?  (Not too awful)
<li> May procedures be return values? (Adds complexity for non-local names)
<li> May storage be allocated dynamically (Duh, all modern languages...
     but some languages do it with syntax (new) others with library (malloc))
<li> Must storage by deallocated explicitly (garbage collector?)
</ol>

<h4>Activation Records</h4>

Activation records organize the stack, one record per method/function call.

<table border>
<tr><td><td>return value
<tr><td><td>parameter
<tr><td><td>...
<tr><td><td>parameter
<tr><td><td>previous frame pointer (FP)
<tr><td><td>saved registers
<tr><td><td>...
<tr><td>FP--&gt;<td>saved PC
<tr><td><td>local
<tr><td><td>...
<tr><td><td>local
<tr><td><td>temporaries
<tr><td>SP--&gt;<td>...
</table>

At any given instant, the live activation records form a chain and
follow a stack discipline.  Over the lifetime of the program, this
information (if saved) would form a gigantic tree.  If you remember
prior execution up to a current point, you have a big tree in which
its rightmost edge are live activation records, and the non-rightmost
tree nodes are an execution history of prior calls.
<p>


<h3> "Modern" Runtime Systems </h3>

The preceding discussion has been mainly about traditional languages such as
C.  Object-oriented programs might be much the same, only every activation
record has an associated object instance; they need one extra "register" in
the activation record.   In practice, modern OO runtime systems have many
more differences than this, and other more exotic language features imply
substantial differences in runtime systems.  Here are a few examples of
features found in runtimes such as the Java Virtual Machine and .Net CLR.
 <p>

<ul>
<li> Garbage collection. Automatic storage management plays a prominent role
     in most modern languages; it is one of the single most important features
     that makes programming easier.
<p>

The Basic problem in garbage collection: given a piece of memory, are there
any pointers to it?  (And if so, where exactly are all of them please).
Approaches:

<ul>
<li> reference counting
<li> traversal of known pointers (marking)
	<ul>
	<li> copying (2 heaps approach)
	<li> compacting (mark and sweep)
	<li> generational
	</ul>
<li> conservative collection
</ul>


<li> Reflection.  Modern languages' values can often describe themselves.
     This plays a central role in Visual GUI builders and Visual IDE's,
     component architectures and other uses.

<li> Just-in-time compilation.  Modern languages often have a virtual machine
     model...and a compiler built-in to the VM that converts VM instructions
     to native code for frequently executed methods or code blocks.

<li> Security model.  Modern languages may attempt to guarantee certain
     security properties, or prevent certain kinds of attacks.


</ul>


Goal-directed programs have an activation tree each instant, due to
suspended activations that may be resumed for additional results.  The
lifetime view is a sort of multidimensional tree, with three types of nodes.



<h3> Having Trouble Debugging? </h3>

To save yourself on the semester project in this class, you really do have
to learn gdb and/or ddd as well as you can.  Sometimes it can help you
find your bug in seconds where you would have spent hours without it.  But
only if you take the time to read the manual and learn the debugger.
<p>

To work on segmentation faults: recompile all .c files with -g and run your
program inside gdb to the point of the segmentation fault.  Type the gdb
"where" command.  Print the values of variables on the line mentioned in the
debugger as the point of failure.  If it is inside a C library function, use
the "up" command until you are back in your own code, and then print the
values of all variables mentioned on that line.

<p>

There is one more tool you should know about, which is useful for certain
kinds of bugs, primarily subtle memory violations.  It is called electric
fence.  To use electric fence you add
<pre>
	/home/uni1/jeffery/ef/ElectricFence-2.1/libefence.a
</pre>
to the line in your makefile that links your object files together to
form an executable.

<!--
<h3> Java in Linux Netscape </h3>

If anyone is having trouble running the Color BASIC emulator, it works on
Netscape 7.0, but doesn't work on 7.1, try /local/netscape7/netscape
-->

<!--<h3> Reference Implementation Files </h3>

Here are some files containing example code you may use in your compiler
project.  Note that understanding and using someone else's code may require
just as much or more work than writing it yourself, and that no warranty
is expressed or implied: you are responsible for your compiler working,
even if it uses code from these files and it turns out they have a bug!

<ul>
<li> <A href="hw4/main.c">main.c</A>
<li> <A href="hw4/tree.h">tree.h</A>
<li> <A href="hw4/type.h">type.h</A>
<li> <A href="hw4/sym.h">sym.h</A>
<li> <A href="hw4/sym.c">sym.c</A>
<li> <A href="hw4/semantic.c">semantic.c</A>
</ul>-->

<p>
<font size=1> <A name=19>lecture #19</A> began here</font><p>

<h3> Need Help with Type Checking? </h3>

<ul>
<li> Implement the C Type Representation given in lecture #16.
<li> Read the Book
<li> What OPERATIONS (functions) do you need, in order to check
     whether types are correct?  What parameters will they take?
</ul>

<A name="codegen">
<h3> Intermediate Code Generation </h3>
</A>

Goal: list of machine-independent instructions for each procedure/method
in the program.  Basic data layout of all variables.
<p>

Can be formulated as syntax-directed translation
<ul>
<li> add new attributes where necessary, e.g. for expression E we might have
<dl>
<dt>E.place
<dd> the name that holds the value of E
<dt> E.code
<dd> the sequence of intermediate code statements evaluating E.
</dl>
<li> new helper functions, e.g.
<dl>
<dt><code>newtemp()</code>
<dd> returns a new temporary variable each time it is called
<dt><code>newlabel()</code>
<dd> returns a new label each time it is called
</dl>
<li> actions that generate intermediate code formulated as semantic rules
</ul>

<table border>
<tr><th>Production</th><th>Semantic Rules</th></tr>

<tr>
<td>S -&gt; id ASN E  <td> S.code = E.code || gen(ASN, id.place, E.place)
<tr>
<td>E -&gt; E1 PLUS E2 <td> E.place = newtemp();<br>
			    E.code = E1.code || E2.code || gen(PLUS,E.place,E1.place,E2.place);

<tr>
<td>E -&gt; E1 MUL E2 <td> E.place = newtemp();<br>
			    E.code = E1.code || E2.code || gen(MUL,E.place,E1.place,E2.place);

<tr>
<td>E -&gt; MINUS E1 <td> E.place = newtemp();<br>
			    E.code = E1.code || gen(NEG,E.place,E1.place);

<tr>
<td>E -&gt; LP E1 RP <td> E.place = E1.place;<br>
			  E.code = E1.code;

<tr>
<td>E -&gt; IDENT <td> E.place = id.place;<br>
			  E.code = emptylist();

</table>

<A name="tac">
<h4> Three-Address Code </h4>
</A>

Basic idea: break down source language expressions into simple pieces that:
<ul>
<li> translate easily into real machine code
<li> form a linearized representation of a syntax tree
<li> allow us to check our own work to this point
<li> allow machine independent code optimizations to be performed
<li> increase the portability of the compiler
</ul>
<p>

<b>Instruction set:</b>

<table>
<tr><th>mnemonic<th>C equivalent</th><th> description
<tr><th> ADD, SUB,MUL,DIV <th>x := y op z</th><td> store result of binary operation on y and z to x
<tr><th> NEG<th>x := op y </th><td> store result of unary operation on y to x
<tr><th> ASN<th>x := y </th><td> store y to x
<tr><th>ADDR<th>x := &y </th><td> store address of y to x
<tr><th>LCONT<th>x := *y </th><td> store contents pointed to by y to x
<tr><th>SCONT <th>*x := y </th><td> store y to location pointed to by x
<tr><th>GOTO<th>goto L </th><td> unconditional jump to L
<tr><th>BLESS,...<th>if x rop y then goto L </th><td> binary conditional jump to L
<tr><th>BIF<th>if x then goto L </th><td> unary conditional jump to L
<tr><th>BNIF<th>if !x then goto L </th><td> unary negative conditional jump to L
<tr><th>PARM<th>param x </th><td> store x as a parameter
<tr><th>CALL<th>call p,n,x </th><td> call procedure p with n parameters, store result in x
<tr><th>RET<th>return x </th><td> return from procedure, use x as the result
</table>
<p>

<b>Declarations (Pseudo instructions):</b>

These declarations list size units as "bytes"; in a uniform-size environment
offsets and counts could be given in units of "slots", where a slot (4 bytes
on 32-bit machines) holds anything.

<table>
<tr><th>global x,n1,n2</th><td>declare a global named x at offset n1 having n2 bytes of space
<tr><th>proc x,n1,n2</th><td>declare a procedure named x with n1 bytes of parameter space and n2 bytes of local variable space
<tr><th>local x,n</th><td>declare a local named x at offset n from the procedure frame
<tr><th>label Ln</th><td>designate that label Ln refers to the next instruction
<tr><th>end</th><td>declare the end of the current procedure
</table>

<b>TAC Adaptations for Object Oriented Code</b>

<table>
<tr><th>x := y field z</th><td>lookup field named z within y, store address to x
<tr><th>class x,n1,n2</th><td>declare a class named x with n1 bytes of class variables and n2 bytes of class method pointers
<tr><th>field x,n</th><td>declare a field named x at offset n in the class frame
<tr><th>new x</th><td>create a new instance of class name x
</table>


<h4> Variable Allocation and Access Issues</h4>

Given a variable name, how do we compute its address?
<dl>
<dt> globals
<dd> easy, symbol table lookup
<dt> locals
<dd> easy, symbol table gives offset in (current) activation record
<dt> objects
<dd> easy, symbol table gives offset in object, activation record has
     pointer to object in a standard location
<dt> locals in some enclosing block/method/procedure
<dd> ugh.  Pascal, Ada, and friends offer their own unique kind of pain.
     Q: does the current block support recursion?  Example: for procedures
     the answer would be yes; for nested { { } } blocks in C the answer
     would be no.
<ul>
<li> if no recursion, just count back some number of frame pointers based
     on source code nesting
<li> if recursion, you need an extra pointer field in activation record
     to keep track of the "static link", follow static link back some
     # of times to find a name defined in an enclosing scope
</dl>



<h4> Sizing up your Regions and Activation Records </h4>

Add a size field to every symbol table entry. Many types are not required
for your C445 project but we might want to discuss them anyhow.<br>

<ul>
<li> The size of integers is 4 (for x86; varies by CPU).<br>
<li> The size of reals is... ? (for x86; varies by CPU).<br>
<li> The size of strings is... &lt;= 256?  You could allocate static
256 character arrays in the global area, but better to do them as a
<em>descriptor</em> consisting of a length and a pointer.<br>
<li> The size of arrays is (sizeof (struct descrip)) * the number of elements?  Do we know an array size?
<li> Are arrays all int, or all real, or can they be mixed?
     (in BASIC and other dynamic languages, they can be mixed!)
<li> Are there arrays of strings? -- yes
<li> what about sizes of structs?
</ul>
<p>

You do this sizing up once for each scope.  The size of each scope is the
sum of the sizes of symbols in its symbol table.

<h4> Run Time Type Information </h4>

Some languages would need the type information around at runtime; for
example, dynamic object-oriented languages.  Its almost the case that one
just writes the type information, or symbol table information that includes
type information, into the generated code in this case, but perhaps one
wants to attach it to the actual values held at runtime.

<pre>
struct descrip {
   short type;
   short size;
   union {
      char *string;
      int ival;
      float rval;
      struct descrip *array;
      /* ... for other types */
      } value;
   };
</pre>

<h4> Compute the Offset of Each Variable </h4>

Add an address field to every symbol table entry.
The address contains a region plus an offset in that region.
No two variables may occupy the same memory at the same time.

<h4> Locals and Parameters are not Contiguous </h4>

For each function you need either to manage two separate regions
for locals and for parameters, or else you need to track where
in that region the split between locals and parameters will be.

<h3> Basic Blocks </h3>

Basic blocks are defined to be sequence of 1+ instructions in which
there are no jumps into or out of the middle.  In the most extreme
case, every instruction is a basic block.  Start from that perspective
and then lump adjacent instructions together if nothing can come between
them.<p>

What are the basic blocks in the following 3-address code?
("read" is a 3-address code to read in an integer.)

<pre>
	read x
	t1 = x > 0
	if t1 == 0 goto L1
	fact = 1
	label L2
	t2 = fact * x
	fact = t2
	t3 = x - 1
	x = t3
	t4 = x == 0
	if t4 == 0 goto L2
	t5 = addr const:0
	param t5		; "%d\n"
	param fact
	call p,2
	label L1
	halt
</pre>

Basic blocks are often used in order to talk about
specific types of optimizations that rely on basic blocks.  So if they are
used for optimization, why did I introduce basic blocks?  You can view
every basic block as a hamburger; it will be a lot easier to eat if you
sandwich it inside a pair of labels (first and follow)!


<h4>Intermediate Code for Control Flow </h4>

Code for control flow (if-then, switches, and loops) consists of
code to test conditions, and the use of goto instructions and
labels to route execution to the correct code.  Each chunk of code
that is executed together (no jumps into or out of it) is called
a <em>basic block</em>.  The basic blocks are nodes in a control flow graph,
where goto instructions, as well as falling through from one basic block
to another, are edges connecting basic blocks.
<p>

Depending on your source language's semantic rules for things like
"short-circuit" evaluation for boolean operators, the operators
like || and && might be similar to + and * (non-short-circuit) or
they might be more like if-then code.
<p>

A general technique for implementing control flow code is to add
new attributes to tree nodes to hold labels that denote the
possible targets of jumps.  The labels in question are sort of
analogous to FIRST and FOLLOW; for any given list of instructions
corresponding to a given tree node,
we might want a .first attribute to hold the label for the beginning
of the list, and a .follow attribute to hold the label for the next
instruction that comes after the list of instructions.  The .first
attribute can be easily synthesized.  The .follow attribute must be
inherited from a sibling.

The labels have to actually be allocated and attached to instructions
at appropriate nodes in the tree corresponding to grammar production
rules that govern control flow.  An instruction in the middle of a
basic block need neither a first nor a follow.

<table border>
<tr><th>C code<th>Attribute Manipulations
<tr><td>S-&gt;if E then S<sub>1</sub><td>E.true = newlabel();<br>
					E.false = S.follow;<br>
					S<sub>1</sub>.follow = S.follow;</br>
					S.code = E.code || gen(LABEL, E.true)||<br>
					S<sub>1</sub>.code
<tr><td>S-&gt;if E then S<sub>1</sub> else S<sub>2</sub>
<td>E.true = newlabel();<br>
    E.false = newlabel();<br>
	S<sub>1</sub>.follow = S.follow;</br>
	S<sub>2</sub>.follow = S.follow;</br>
	S.code = E.code || gen(LABEL, E.true)||<br>
	S<sub>1</sub>.code || gen(GOTO, S.follow) ||<br>
	gen(LABEL, E.false) || S<sub>2</sub>.code
</table>

Exercise: OK, so what does a while loop look like?

<!--
<h4> BASIC </h4>

As a student reported in class, Color BASIC supports statements in
the bodies of THEN and ELSE as an alternative to a line number to GOTO.
Indeed, it supports colon-separated lists of statements.<p>

This means the discussion in class about generating labels for the
starts and ends of then-parts and else-parts applies to BASIC, not
just C.<p>

BASIC also supports boolean AND, OR and NOT operators, and computes them
as integer (0 = FALSE, -1 = TRUE) but they are not short-circuit so the
handling of them is identical to (and simpler than) arithmetic operators
such as + and -.  Since we have not considered them up to now, and they
do not introduce interesting new challenges but instead are just handled
the same as required operators, Booleans are OPTIONAL EXTRA CREDIT for
your homework #4 and 5.  Don't bother with them unless everything else
in your assignment is finished.<p>
-->

<p>
<font size=1> <A name=20>lecture #20</A> began here</font><p>
<p>



<h3> More on Generating Code for Boolean Expressions </h3>

 
Last time we started to look at code generation for control structures
such as if's and while's.  Of course, before we can see the big
picture on these we have to understand how to generate code for the
boolean expressions that control these constructs.

<h4> Comparing Regular and Short Circuit Control Flow </h4>

Different languages have different semantics for booleans; for example
Pascal treats them as identical to arithmetic operators, while the
C family of languages (and many ) others specify "short-circuit"
evaluation in which operands are not evaluated once the answer to
the boolean result is known.  Some ("kitchen-sink" design) languages
have two sets of boolean operators: short circuit and non-short-circuit.
(Does anyone know a language that has both?)
<p>

Implementation techniques for these alternatives include:

<ol>
<li> treat boolean operators same as arithmetic operators, evaluate
     each and every one into temporary variable locations.
<li> <b>add extra attributes</b> to keep track of code locations that are
     targets of jumps. The attributes store link lists of those instructions
     that are <em>targets to backpatch</em> once a destination label is known.
     Boolean expressions' results evaluate to jump instructions and program
     counter values (where you get to in the code implies what the boolean
     expression results were).
<li> one could change the machine execution model so it implicity routes
     control from expression failure to the appropriate location.  In
     order to do this one would
     <ul>
     <li> mark boundaries of code in which failure propagates
     <li> maintain a stack of such marked "expression frames"
     </ul>
</ol>

<h4> Non-short Circuit Example</h4>

<pre>
a&lt;b || c&lt;d && e&lt;f
</pre>
translates into
<pre>
100:	if a&lt;b goto 103
	t<sub>1</sub> = 0
	goto 104
103:	t<sub>1</sub> = 1
104:	if c&lt;d goto 107
	t<sub>2</sub> = 0
	goto 108
107:	t<sub>2</sub> = 1
108:	if e&lt;f goto 111
	t<sub>3</sub> = 0
	goto 112
111:	t<sub>3</sub> = 1
112:	t<sub>4</sub> = t<sub>2</sub> AND t<sub>3</sub>
	t<sub>5</sub> = t<sub>1</sub> OR t<sub>4</sub>
</pre>

<h4> Short-Circuit Example </h4>

<pre>
a&lt;b || c&lt;d && e&lt;f
</pre>
translates into
<pre>
	if a&lt;b goto L1
	if c&lt;d goto L2
	goto L3
L2:	if e&lt;f goto L1
L3:	t = 0
	goto L4
L1:	t = 1
L4:	...
</pre>

Note: L3 might instead be the target E.false; L1 might instead be E.true;
no computation of a 0 or 1 into t might be needed at all.
<p>

<h4> While Loops </h4>

So, a while loop, like an if-then, would have attributes similar to:

<table border>
<tr><th>C code<th>Attribute Manipulations
<tr><td>S-&gt;while E do S<sub>1</sub><td>E.true = newlabel();<br>
					E.false = S.follow;<br>
					S<sub>1</sub>.follow = E.first;</br>
					S.code = gen(LABEL, E.first) ||<br>&nbsp;&nbsp;&nbsp;E.code || gen(LABEL, E.true)||<br>
					&nbsp;&nbsp;&nbsp;S<sub>1</sub>.code || <br>
					&nbsp;&nbsp;&nbsp;gen(GOTO, E.first)
</table>



C for-loops are trivially transformed into while loops, so they pose no new
code generation issues.

<!--
<h4> BASIC FOR Loops </h4>

Is the same true for a BASIC FOR loop?  If not,
So how is a FOR loop different from C while loop?
Well, for one thing, there are two separate statements (FOR and NEXT)
that are matched together only by the variable name that controls the loop.

<p>
Example BASIC FOR-loop:
<pre>
10 FOR I = 1 to 10
20 PRINT I
30 NEXT I
</pre>

One possible 3-address code equivalent for this is:
<pre>
L10:				; line 10
	asn G:24 C:1		; I = 1
L10A:				; "end of line 10" == loop test
	bgr G:24 C:10 L30A	; How did we decide to go to end of 30?
L20:				; line 20
	param G:24		; push I onto stack for print
	call  print,1		; call print
L30:				; line 30
	add G:24 G:24 C:1	; I = I + 1
	goto L10A		; go to end of line 10
L30A:
	...
</pre>

There is an obvious question, which is how do the FOR and the NEXT find
each other?  Minimally, one might be looking at writing tree traversal
code to match up FOR and NEXT statements.
->

<h3> What-all goes in tree nodes for code generation? </h3>


<!--
<p>
<h3> FOR loops, continued </h3>

Last time we considered generating code for simple FOR-loops.
In reality FOR loops are stickier than this; FOR really isn't like
a C-style for- or while-loop.
There can be several NEXT statements corresponding to a given
FOR statement.  A FOR statement cannot determine a destination
to which to branch when the loop is finished; it never fails.
If you execute the following lines, BASIC prints a "2":
<pre>
10 FOR I = 2 TO 1
20 PRINT I
30 NEXT I
</pre>

Instead, a NEXT statement must not only do the increment, but also
test the loop's exit condition, and either branch back up to the
top of the loop (if the loop is not finished) or fall through.
In order to communicate between a FOR and any of several NEXT's,
use <em>variables</em>.  As I see it, you need about two variables
to do FOR loops: one variable to store: what code region address
to goto to jump back to do the next iteration of the loop, and
one to store the upper limit of the loop (for STEP versions of FOR
you need a third variable to hold the increment).  With these two
variables, the simple FOR loop looks more like:
<p>
<pre>
L10:				; line 10
	asn G:24 C:1		; I = 1
	asn G:28 L10A
	asn G:32 C:10
	asn G:36 C:1
L10A:				; "end of line 10" == place for NEXT to go
L20:				; line 20
	param G:24		; push I onto stack for print
	call  print,1		; call print
L30:				; line 30
	add G:24 G:24 G:36	; I = I + 1
	bleq G:24 G:32 G:28	; if i <= 10 goto L10A
L30A:
	...
</pre>



<h4> Note on BASIC's INPUT statement </h4>

By the way, Color BASIC's INPUT statement
has a convenient, optional, PRINT-like prompt clause.  Instead of
<pre>
10 PRINT "Enter your Mastercard Number: "
20 INPUT M$
</pre>
you can write:
<pre>
10 INPUT "Enter your Mastercard Number: "; M$
</pre>
This is shown in Chapter 11 of the Color BASIC book.
-->

<p>
<font size=1> <A name=21>lecture #21</A> began here</font>


<h4> Intermediate Code Generation Examples </h4>

Consider the following small program.  It would be fair game as input
to your compiler project.  In order to show blow-by-blow what the code
generation process looks like, we need to construct the syntax tree and
do the semantic analysis steps.

<pre>
void main()
{
   int i;
   i = 0;
   while (i < 20)
      i = i * i + 1;
   print(i);
}
</pre>

This code has the following syntax tree

<img src="treepic.jpg">


<h4> Intermediate Code Generation Example (cont'd) </h4>

<!--
Here is an example BASIC program to compile:
<pre>
10	i = 0
20	IF i &gt;= 20 THEN 50
30	i = i * i + 1
40	GOTO 20
50	PRINT i
</pre>
-->
Here is an example C progrma to compile:
<pre>
   i = 0;
   if (i >= 20) goto L50;
   i = i * i + 1;
   goto 20;
   print(i);
</pre>

This program corresponds to the following syntax tree, which a
successful homework #5 would build.  Note that it has a height of
approximately 10, and a maximum arity of approximately 4.  Also: your
exact tree might have more nodes, or slightly fewer; as long as the
information and general shape is there, such variations are not a problem.
<p>
<img src="syntree.jpg">
<em> A syntax tree, with attributes obtained from lexical and semantic
analysis, needs to be shown here.</em>

During semantic analysis, it is discovered that "print" has not been
defined, so let it be:

<pre>
void print(int i) { }
</pre>

<p>

The code for the boolean conditional expression controlling the while
loop is a list of length 1, containing the instruction t0 = i < 20,
or more formally

<table border>
<tr><th>opcode<th>dest<th>src1<th>src2</tr>
<tr><td>LT<td>t0<td>i<td>20</tr>
</table>
<p>

The actual C representation of addresses dest, src1, and src2 is probably as a 
<table border><td>region<br><hr>offset</table> pair, so the
picture of this intermediate code instruction really looks something like this:

<p>

<table border>
<tr><th>opcode<th>dest<th>src1<th>src2</tr>
<tr><td>LT<td>local<br><hr>t0.offset<td>local<br><hr>i.offset<td>const<br><hr>20</tr>
</table>

<p>

Regions are expressed with a simple integer encoding like:
global=1, local=2, const=3.
Note that address values in all regions are offsets from the start of the
region, except for region "const", which
stores the actual value of a single integer as its offset.

<p>

<table border>
<tr><th>opcode<th>dest<th>src1<th>src2</tr>
<tr><td>MUL<td>local<br><hr>t1.offset<td>local<br><hr>i.offset<td>local<br><hr>i.offset</tr>
</table>

<p>

<!-- Using this same representation, the next instruction found by bottom-up
traversal of the tree is -->


<p>
<font size=1> <A name=22>lecture #22</A> began here</font>

<h4> Comments on Trees and Attributes </h4>

The main problem in semantic analysis and intermediate code generation is to
Move Information Around the Tree.  Moving information up the tree is kind of
easy and follows the pattern we used to build the tree in the first place.
To move the information down the tree, needed for HW4, you write tree
traversal functions. The tree traversal is NOT a "blind" traversal that does
the same thing at each node. It has a switch statement on what grammar rule
was used to build each node, and often does different work depending on what
nonterminal and what grammar rule a given node represents.


<h4> Traversal code example </h4>

The following code sample illustrates a code generation tree traversal.
Note the gigantic switch statement.  In class a student asked the question
of whether the link lists might grow longish, and if one is usually appending
instructions on to the end, wouldn't a naive link list do a terrible
O(n<sup>2</sup>) job.  To which the answer was: yes, and it would be good
to use a smarter data structure, such as one which stores both the head
and the tail of each list.

<pre>
void codegen(nodeptr t)
{
   int i, j;
   if (t==NULL) return;

   /*
    * this is a post-order traversal, so visit children first
    */
   for(i=0;i&lt;t-&gt;nkids;i++)
      codegen(t-&gt;child[i]);

   /*
    * back from children, consider what we have to do with
    * this node. The main thing we have to do, one way or
    * another, is assign t-&gt;code
    */
   switch (t-&gt;label) {
   case PLUS: {
      t-&gt;code = concat(t-&gt;child[0].code, t-&gt;child[1].code);
      g = gen(PLUS, t-&gt;address,
              t-&gt;child[0].address, t-&gt;child[1].address);
      t-&gt;code = concat(t-&gt;code, g);
      break;
      }
   /* ... really, we need a bazillion cases, perhaps one for each
    * production rule (in the worst case)
    */
   default:
      /* default is: concatenate our children's code */
      t-&gt;code = NULL;
      for(i=0;i&lt;t-&gt;nkids;i++)
         t-&gt;code = concat(t-&gt;code, t-&gt;child[i].code);
   }
}
</pre>



<h3>Code generation examples</h3>

Let us build one operator at a time.  You should implement your
code generation the same way, simplest expressions first.<p>

Zero operators.<p>

<pre>
if (x) S
</pre>
translates into

<pre>
if x != 0 goto L1
goto L2
label L1
...code for S
label L2
</pre>


or if you are being fancy

<pre>
if x == b goto L1
...code for S
label L1
</pre>
I may do this without comment in later examples, to keep them short.
<p>

One relational operator.<p>

<pre>
if (a &lt; b) S
</pre>
translates into

<pre>
if i &gt;= b goto L1
...code for S
label L1
</pre>

One boolean operator.<p>

<pre>
if (a &lt; b  &&  c &gt; d) S
</pre>
translates into

<pre>
if (a &lt; b)
   if (c &gt; d)
      ...code for S
</pre>
which if we expand it

<pre>
if i &gt;= b goto L1
if c &lt;= d goto L2
...code for S
label L2
label L1
</pre>

by mechanical means, we may wind up with lots of labels for the same
target, this is OK.<p>


<pre>
if (a &lt; b  ||  c &gt; d) S
</pre>
translates into

<pre>
if (a &lt; b) ...code for S
if (c &gt; d) ...code for S
</pre>
but its unacceptable to duplicate the code for S!  It might be huge!
Generate labels for boolean-true-yes-we-do-this-thing, not just for
boolean-false-we-skip-this-thing.

<pre>
if a &lt; b goto L1
if c &gt; d goto L2
goto L3
label L2
label L1
...code for S
label L3
</pre>


<h4> Array subscripting!  </h4>

So far, we have only said, if we passed an array as a parameter we'd have to
pass its address.  3-address instructions have an "implicit dereferencing
semantics" which say all addresses' values are fetched / stored by default.
So when you say t1 := x + y, t1 gets values at addresses x and y, not the
addresses.  Once we recognize arrays are basically a pointer type, we need
3-address instructions to deal with pointers.  <p>

now, what about arrays?  reading an array value: x = a[i].  Draw the
picture.  Consider the machine uses byte-addressing, not word-addressing.

<pre>
t0 := addr a
t1 := i * 4
t2 := plus t0 t1
t3 := deref t2
x  := t3
</pre>

What about writing an array value?


<h3> Debugging Miscellany </h3>

Prior experience suggests if you are having trouble debugging, check:

<dl>
<dt> makefile .h dependencies!
<dd> if you do not list makefile dependencies for important .h files,
     you may get coredumps!
<dt> traversing multiple times by accident?
<dd> at least in my version, I found it easy to accidentally re-traverse
     portions of the tree. this usually had a bad effect.
<dt> bad grammar?
<dd> our sample grammar was adapted from good sources, but don't assume its
     impossible that it could have a flaw or that you might have messed it up.
<!--
<dd> cocogram.y was adapted from an old BASIC grammar and from the available
     books on color computer BASIC.  But, it is certain that it still
     has bugs (missing pieces).  Our goal is not to do the whole of Color
     BASIC, but if there is a bug in the reasonable subset we've defined,
     fix it.
-->
</dl>


<p>
<font size=1> <A name=23>lecture #23</A> began here</font>
<p>

Remind me to come back to <A href="hw6.html">HW #6</A> before the end of
today's lecture.

<a name="finalcode">
<h3> Final Code </h3>
</a>

Goal: execute the program we have been translating, somehow.<p>

Alternatives:
<dl>
<dt> interpret the source code
<dd> we could have build an interpreter instead of a compiler, in which the
     source code was kept in string or token form, and re-parsed every
     execution. Early BASIC's did this, but it is Really Slow.
<dt> interpret the parse tree
<dd> we could have written an interpreter that executes the program
     by walking around on the tree doing traversals of various subtrees.
     This is still slow, but successfully used by many "scripting languages".
<dt> interpret the 3-address code
<dd> we could interpret the link-list or a more compact binary representation
     of the intermediate code
<dt> translate into VM instructions
<dd> popular virtual machines such as JVM or .Net allow execution from an
     instruction set that is often higher level than hardware, may be
     independent of the underlying hardware, and may be oriented toward
     supporting the specific language features of our source language.
     For example, there are various BASIC virtual machines out there.
<dt> translate into "native" instructions
<dd> "native" generally means hardware instructions.
</dl>

In mainstream compilers,
final code generation takes a linear sequence of 3-address intermediate
code instructions, and translates each 3-address instruction into one or
more native instructions.
The big issues in code generation are (a) instruction selection, and (b)
register allocation and assignment.

<h4> Collecting Information Necessary for Final Code Generation </h4>

<ul>
<li> a top-down approach to learning your native target code is to
     study a reference work supplied by the chip manufacturer, such
     as the Intel 80386 Programmer's Reference Manual
<li> a bottom-up approach to learning your native target code is to
     study an existing compiler's native code.  For example, running
     "gcc -S foo.c" will compile foo.c into a human-readable native
     assembler code equivalent foo.s file which you can examine.
     By systematically studying .s files for various toy C programs
     you can learn native instructions corresponding to each C construct,
     including ones equivalent to the various 3-address instructions.
</ul>


<h4>Instruction Selection</h4>

The hardware may have many difference sequences of instructions to
accomplish a given task.  Instruction selection must choose a particular
sequence.  At issue: how many registers to use, whether a special
case instruction is available, and what addressing mode(s) to use.  Given
a choice among equivalent/alternaive sequences, the decision on which
sequence of instructions to use is based on estimates or measurements of
which sequence executes the fastest.  This is usually determined by the
number of memory references incurred during execution, including the
memory references for the instructions themselves.  Simply picking the
shortest sequence of instructions is often a good approximation of the
optimal result, since fewer instructions usually translates into fewer
memory references.


<h4> Register Allocation and Assignment </h4>

Accessing values in registers is much much faster than accessing main memory.
Register allocation denotes the selection of which variables will go
into registers.  Register assignment is the determination of exactly
which register to place a given variable.  The goal of these operations
is generally to minimize the total number of memory accesses required
by the program.
<p>

In the Old Days, there were Load-Store hardware architectures in which
only one (accumulator) register was present.  On such an architecture,
register allocation and assignment is not needed; the compiler has few
options about how it uses the accumulator register.  Traditional x86
16-bit architecture was only a little better than a load-store architecture,
with 4 registers instead of 1.  At the other extreme, Recent History has
included CPU's with 32 or more general purpose registers.  On such systems,
high quality compiler register allocation and assignment makes a huge
difference in program execution speed.  Unfortunately, optimal register
allocation and assignment is NP-complete, so compilers must settle for
doing a "good" job.
<p>


<h3>Discussion of Tree Traversals that perform Semantic Tests.</h3>

Suppose we have a grammar rule
<pre>
AssignStmt : Var EQU Expr.
</pre>
We might extend the C semantic action for that rule with
extra code after building our parse tree node:
<pre>
AssignStmt : Var EQU Expr { $$ = alctree(..., $1, $2, $3);
	lvalue($1);
	rvalue($3);
	}
</pre>

lvalue() and rvalue() are mini-tree traversals for the lefthand side
and righthand side of an assignment statement. Their missions are to
propagate information from the parent, namely, inherited attributes
that tell nodes whether their values are being assigned to (initialized)
or being read from.

<pre>
void lvalue(struct tree *t)
{
   if (t-&gt;label == IDENT) {
      struct symtabentry *ste = lookup(t->u.token.name);
      ste->lvalue = 1;
   }
   for (i=0; i<t->nkids; i++) {
      lvalue(t->child[i]);
      }
}
void rvalue(struct tree *t)
{
   if (t-&gt;label == IDENT) {
      struct symtabentry *ste = lookup(t->u.token.name);
      if (ste->lvalue == 0) warn("possible use before assignment");
   }
   for (i=0; i<t->nkids; i++) {
      lvalue(t->child[i]);
      }
}
</pre>

<h4> What is different about real life as opposed to this toy example</h4>

In real life, you should build a flow graph, and propagate these
variable definition and use attributes using the flow graph instead
of the syntax tree.  For example, if the program starts by calling
a subroutine at the bottom of code which initializes all the
variables, the flow graph will not be fooled into generating warnings
like you would if you just started at the top of the code and checked
whether for each variable, assignments appear earlier in the source
code than the uses of that variable.

<p>
<font size=1> <A name=24>lecture #24</A> began here</font>
<p>

<!--
<h3> The Easy Target: BASIC to C </h3>

I was reminded last lecture that by far the easiest target is to generate
ANSI C from your BASIC code.  It is also somewhat less cool.  If you do
this you should write out a .c file, call the C compiler on it, and produce
an executable.

-->

<h3> Runtime Systems </h3>

Every compiler (including yours) needs a runtime system.  A runtime system
is the set of library functions and possibly global variables maintained by
the language on behalf of a running program.  You use one all the time; in C
it functions like printf(), plus perhaps internal compiler-generated calls
to do things the processor doesn't do in hardware.<p>

So you need a runtime system; potentially, this might be as big or bigger a
job than writing the compiler.  Languages vary from assembler (no runtime
system) and C (small runtime system, mostly C with some assembler) on up to
Java (large runtime system, mostly Java with some C) and in even higher level
languages the compiler may evaporate and the runtime system become gigantic.
The Unicon language has a relatively trivial compiler and gigantic virtual
machine and runtime system.  Other scripting languages might have no compiler
at all, doing everything (even lexing and parsing) in the runtime system.
<p>

For your project: whether you generate C or X86 or Java, you'll need a plan
for what to do about a runtime system.  And, in principle, I am not opposed
to helping with this part.  But the compiler and runtime system have to fit
together; if I write part of the BASIC runtime system for you, or we write
it together, we have to agree on things such as: what the types of
parameters and return values must look like.<p>

So, what belongs in a Color BASIC runtime system?  Anything not covered
by a three address instruction.  Looking at cocogram.y:
<ul>
<li> INPUT/PRINT
<li> READ/DATA
<li> CLEAR
<li> CLOAD/CSAVE/SKIPF
<li> CLS
<li> SET/RESET
<li> SOUND
<li> CHR$, LEFT$, MID$, RIGHT$, INKEY$
<li> ASC, INT, JOYSTK, LEN, PEEK, RND, VAL
<li> DIM
<li> string +, string compares
</ul>
<p>

What would a runtime system function look like?  It would take in and
pass out BASIC values, represented as C structs.  You would then link
this code in to your generated C or assembler code (if you generated
Java code, you would have to deal with the Java Native Interface or
else write these functions in Java).
<pre>
void PRINT(struct descrip *d)
{
   switch (d->type) {
   case INTEGER: printf("%d",d->value.ival); break;
   case REAL: printf("%f",d->value.rval); break;
   case STRING: printf("%*s",d->size,d->value.string); break;
   case ARRAY: printf("cannot print arrays"); break; /* can't get here */
   default: printf("PRINT: internal error, type %d\n", d->type);
   }
}
</pre>

Now, let's look at the "whole" runtime system:

<ul>
<li> <A href="libb.c">libb.c</A>
</ul>

<h3> More on Memory Management in the BASIC Runtime System </h3>

Arrays are interesting.  They can be used without being declared or DIM'ed.
They can only be DIM'ed once.  If you use them before they are DIM'ed, they
are implicitly DIM'ed to size 11 and can't be re-DIM'ed.
<p>
What do variables A, A(), A$, and A$() look like in memory?  How does our
runtime system make it so?
<p>
Let's take a look at DIM, in libc.c.  This DIM is for arrays of numbers.
How would you handle arrays of strings?
<p>
Can you implement STRCAT for your BASIC runtime system?
<p>
What other BASIC statements, operators, or functions allocate memory?
<p>
How would we avoid memory "leaks"?

<h3> Final Project comments </h3>
<ul>
<li> We have a week of classes more, plus a couple weekends, before your
     final project (HW#7) is due.
<li> Really, really, test your turnin, by "turning your .tar in to
     yourself": unpacking in a separate directly, and verifying that it builds
     and runs correctly in a separate subdirectory.  Turnins that do not
     compile and run due to missing files, etc. may receive a 0.
<li> You are invited and encouraged, but not required, to make an appointment
     to demo your compiler with me during Finals week.  The purpose is to
     make sure you get credit for those parts which you can show me are
     working (as opposed to me testing your program independently and
     somehow missing the parts that work).
<li> Student assignments which have "impossible similarity" to each other
     may result in a 0 for the assignment or an "F" for the course.
     Impossible similarity means: beyond a reasonable doubt, substantial
     code other than sample code fragments provided in lecture or lab notes,
     has been shared or copied.
</ul>


<h3> STRCAT </h3>

So, what does your STRCAT look like?  <A href="libb.c#strcat">Here's one.</A>

<h3> GOSUBs </h3>

Our 3-address instruction set has call and return instructions, but basic
is less structured than regular procedural languages; you can GOSUB to any
line number you want.  You can't use a variable to GOSUB to line number X,
but in principle every line number could be the target of a procedure call.
<p>
If you use the "call" (3-address) instruction to do GOSUB, your native code
will have to make a clear distinction between BASIC call's and calls to
runtime system (built-in) functions.  Perhaps it is best to implement BASIC
GOSUB by pushing a "param" (the next instruction following the GOSUB) and
a "goto".  The BASIC RETURN is then a "pop" followed by a "goto".  What,
we don't have a "pop" 3-address instruction?  We do now...  the name of
"param" should probably be "push" anyhow.
<p>

Come to think of it, we've been talking about doing a call to a built-in
function such as PRINT, but that PRINT function we wrote is C code; it
doesn't do a 3-address "ret" instruction, hmmm.  How are we going to
generate the native code for the 3-address "call" instruction?
It may include an assembler call instruction, but it may also involve
instructions to handle the interface between BASIC and C.

<p>
<font size=1> <A name=25>lecture #25</A> began here</font>

<h3> Register Allocation and Assignment (cont'd) </h3>

When the number of variables in use at a given time exceeds the number
of registers available (the common case), some variables may be used
directly from memory if the instruction set supports memory-based operations.
When an instruction set does not support memory-based operations, all
variables must be loaded into a register in order to perform arithmetic
or logic using them.
<p>

Even if an instruction set does support memory-based operations, most
compilers will want to load load a value into a register while it is
being used, and then spill it back out to main memory when the register
is needed for another purpose.  The task of minimizing memory accesses
becomes the task of minimizing register loads and spills.

<h3> Some Code Generation Examples </h3>

<h4> Reusing a Register </h4>

Consider the statement:
<pre>
   a = a+b+c+d+e+f+g+a+c+e;
</pre>
Our naive three address code generator would generate a
lot of temporary variables here, when really one big number is being added.
How many registers does the expression need?  Some variables
are referenced once, some twice.  GCC generates:
<pre>
	movl	b, %eax
	addl	a, %eax
	addl	c, %eax
	addl	d, %eax
	addl	e, %eax
	addl	f, %eax
	addl	g, %eax
	addl	a, %eax
	addl	c, %eax
	addl	e, %eax
	movl	%eax, a
</pre>

Now consider
<pre>
   a = (a+b)*(c+d)*(e+f)*(g+a)*(c+e);
</pre>
How many registers are needed here?
<pre>
	movl	b, %eax
	movl	a, %edx
	addl	%eax, %edx
	movl	d, %eax
	addl	c, %eax
	imull	%eax, %edx
	movl	f, %eax
	addl	e, %eax
	imull	%eax, %edx
	movl	a, %eax
	addl	g, %eax
	imull	%eax, %edx
	movl	e, %eax
	addl	c, %eax
	imull	%edx, %eax
	movl	%eax, a
</pre>

And now this:
<pre>
   a = ((a+b)*(c+d))+((e+f)*(g+a))+(c*e);
</pre>
which compiles to
<pre>
	movl	b, %eax
	movl	a, %edx
	addl	%eax, %edx
	movl	d, %eax
	addl	c, %eax
	movl	%edx, %ecx
	imull	%eax, %ecx
	movl	f, %eax
	movl	e, %edx
	addl	%eax, %edx
	movl	a, %eax
	addl	g, %eax
	imull	%edx, %eax
	leal	(%eax,%ecx), %edx
	movl	c, %eax
	imull	e, %eax
	leal	(%eax,%edx), %eax
	movl	%eax, a
</pre>
Lastly (for now) consider:
<pre>
   a = ((a+b)*(c+d))+(((e+f)*(g+a))/(c*e));
</pre>
The division instruction adds new wrinkles.  It operates on an implicit
register accumulator which is twice as many bits as the number you divide
by, meaning 64 bits (two registers) to divide by a 32-bit number.  Note
in this code that gcc would rather spill than use %ebx.  %ebx is either
being used implicitly or is reserved by the compiler for some (probably
good) reason.  %edi and %esi are similarly ignored.
<pre>
	movl	b, %eax
	movl	a, %edx
	addl	%eax, %edx
	movl	d, %eax
	addl	c, %eax
	movl	%edx, %ecx
	imull	%eax, %ecx
	movl	f, %eax
	movl	e, %edx
	addl	%eax, %edx
	movl	a, %eax
	addl	g, %eax
	imull	%eax, %edx
	movl	c, %eax
	imull	e, %eax
	movl	%eax, -4(%ebp)
	movl	%edx, %eax
	cltd
	idivl	-4(%ebp)
	movl	%eax, -4(%ebp)
	movl	-4(%ebp), %edx
	leal	(%edx,%ecx), %eax
	movl	%eax, a
</pre>

<h4> Code Generation for Virtual Machines </h4>

A virtual machine architecture such as the JVM changes the "final" code
generation somewhat.  We have seen several changes, some of which
simplify final code generation and some of which complicate things.

<dl>
<dt> no registers, simplified addressing
<dd> a virtual machine may omit a register model and avoid complex
     addressing modes for different types of variables
<dt> uni-size or descriptor-based values
<dd> if all variables are "the same size", some of the details of
     memory management are simplified.  In Java most values occupy
     a standard "slot" size, although some values occupy two slots.
     In Icon and Unicon, all values are stored using a same-size descriptor.
<dt> runtime type system
<dd> requiring type information at runtime may complicate the
     code generation task since type information must be present
     in generated code.  For example in Java method invocation and
     field access instructions must encode class information.
</dl>

Just for fun, let's compare the generated code for java with that X86
native code we were just looking at:
<pre>
	iload_1
	iload_2
	iadd
	iload_3
	iload 4
	iadd
	imul
	iload 5
	iload 6
	iadd
	iload 7
	iload_1
	iadd
	imul
	iload_3
	iload 5
	imul
	idiv
	iadd
	istore_1
</pre>


<p>
<font size=1> <A name=26>lecture #26</A> began here</font>
<p>

<h3> A Shallow Introduction to Code Optimization </h3>

There are major classes of optimization that can significantly speedup
a compiler's generated code.  Usually you speed up code by doing the
work with fewer instructions and by avoiding unnecessary memory reads
and writes. You can also speed up code by rewriting it with fewer gotos.

<h4> Peephole Optimization </h4>

Peephole optimizations look at the native code through a small, moving
window for specific patterns that can be simplified.  These are some of the
easiest optimizations because they potentially don't require any analysis
of other parts of the program in order to tell when they may be applied.
Although some of these are stupid and you wouldn't think they'd come up,
the simple code generation algorithm we presented earlier is quite stupid
and does all sorts of obvious bad things that we can avoid.
<p>

<table border>
<tr>
<th> name
<th> sample
<th> optimized as
<tr>
<td> redundant load or store
<td>
<pre>
MOVE R0,a
MOVE a,R0
</pre>
<td>
<pre>
MOVE R0,a
</pre>
<tr>
<td> dead code
<td>
<pre>
#define debug 0
...
if (debug) printf("ugh");
</pre>
<tr>
<td> control flow simplification
<td>
<pre>
if a &lt; b goto L1
...
L1: goto L2
</pre>
<td>
<pre>
if a &lt; b goto L2
...
L1: goto L2
</pre>
<tr>
<td> algebraic simplification
<td>
<pre>
x = x * 1;
</pre>
<tr>
<td> strength reduction
<td>
<pre>
x = y * 16;
</pre>
<td>
<pre>
x = y << 4;
</pre>
</table>


<h4> Constant Folding </h4>

Constant folding is performing arithmetic at compile-time when the values
are known.  This includes simple expressions such as 2+3, but with more
analysis
some variables' values may be known constants for some of their uses.
<pre>
     x = 7;
     ...
     y = x+5;
</pre>

<h4> Common Subexpression Elimination </h4>

Code that redundantly computes the same value occurs fairly frequently,
both explicitly because programmers wrote the code that way, and implicitly
in the implementation of certain language features.
<p>

Explicit:
<pre>
    (a+b)*i + (a+b)/j;
</pre>

The (a+b) is a common subexpression that you should not have to compute twice.
<p>

Implicit:
<pre>
    x = a[i]; a[i] = a[j]; a[j] = x;
</pre>

Every array subscript requires an addition operation to compute the memory
address; but do we have to compute the location for a[i] and a[j] twice in
this code?


<h4> Loop Unrolling </h4>

Gotos are expensive (do you know why?).  If you know a loop will
     execute at least (or exactly) 3 times, it may be faster to copy the
     loop body those three times than to do a goto.  Removing gotos
     simplifies code, allowing other optimizations.

<table border>
<tr>
<td>
<pre>
for(i=0; i<3; i++) {
   x += i * i;
   y += x * x;
   }
</pre>
<td>
<pre>
   x += 0 * 0;
   y += x * x;
   x += 1 * 1;
   y += x * x;
   x += 2 * 2;
   y += x * x;
</pre>
<td>
<pre>
   y += x * x;
   x += 1;
   y += x * x;
   x += 4;
   y += x * x;
</pre>
</table>

<h4> Hoisting Loop Invariants </h4>

<table border>
<td>
<pre>
for (i=0; i&lt;strlen(s); i++)
   s[i] = tolower(s[i]);
</pre>
<td>
<pre>
t_0 = strlen(s);
for (i=0; i&lt;t_0; i++)
   s[i] = tolower(s[i]);
</pre>
</table>

<h4> Interprocedural Optimization </h4>

Considering memory references across procedure call boundaries;
     for example, one might pass a parameter in a register if both
     the caller and callee generated code knows about it.
<h4> argument culling </h4>
 when the value of a specific parameter is a constant, a custom version
     of a called procedure can be generated, in which the parameter is
     eliminated, and the constant is used directly (may allow additional
     constant folding).

<table border>
<td>
<pre>
f(x,r,s,1);

int f(int x, float y, char *z, int n)
{
  switch (n) {
  case 1:
     do_A; break;
  case 2:
     do_B; break;
     ...
     }
}
</pre>
<td>
<pre>
f_1(x,r,s);

int f_1(int x, float y, char *z)
{
   do_A;
}
int f_2(int x, float y, char *z)
{
   do_B;
}
...
</pre>

</table>


<h3> Final Exam Review </h3>

The final exam is comprehensive, but with a strong emphasis on "back end"
compiler issues: symbol tables, semantic analysis, and code generation.


<ul>
<li>  Review your lexical analysis, regular expressions, and finite automata.
<li>  Review your syntax analysis, CFG's, and parsing.
<li>  If a parser discovers a syntax error, how can it report what line
      number that error occurs on?  If semantic analysis discovers a
      semantic error (or probable semantic error), how can it report what
      line number that error occurs on?
<li>  What are symbol tables?
<li>  What are symbol tables used for?  What information is stored there?
<li>  How does information get into a symbol table?
<li>  How many symbol tables does a compiler need?
<li>  What is "semantic analysis"?
<li>  What does "semantic analysis" accomplish? What are its side effects?
<li>  What are the primary activities of a compiler's semantic analyzer?
<li>  What are memory regions, and why does a compiler care?
<li>  What memory regions are there, and how do they affect code generation?
<li>  What does code generation do, anyhow?
<li>  What kinds of code generation are there?
<li>  Why do (almost all) compilers use an "intermediate code"?  What does
      intermediate code look like?  How is it different from final code?
</ul>
