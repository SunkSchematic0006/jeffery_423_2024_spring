<H1> Dr. J's Compiler and Translator Design Lecture Notes </h1>

(C) Copyright 2011-2021 by Clinton Jeffery and/or original authors where
appropriate.  For use in Dr. J's Compiler classes only.  Lots of material
in these notes originated with Saumya Debray's Compiler course notes from
the University of Arizona, for which I owe him a debt of thanks.  Various
portions of his notes were in turn inspired by the ASU red dragon book.

<table>
<tr align=top>
<td>
<ul>
<li> <A href="intro">Introduction</A>
<ul>
<li> <A href="#1">Lecture 1</A> (<A href="445-1.pptx">pptx</A>)
</ul>
<li> <A href="#lexical">Lexical Analysis</A>
<ul>
<li> <A href="#2">Lecture 2</A> (<A href="445-2.pptx">pptx</A>)
<li> <A href="#3">Lecture 3</A> (<A href="445-3.pptx">pptx</A>)
<li> <A href="#4">Lecture 4</A>
<li> <A href="#5">Lecture 5</A> (<A href="445-5.pptx">pptx</A>)
<li> <A href="#6">Lecture 6</A>
<li> <A href="#7">Lecture 7</A> (<A href="445-7.pptx">pptx</A>)
<li> <A href="#8">Lecture 8</A>
<li> <A href="#9">Lecture 9</A>
</ul>
</ul>
<ul>
<li> <A href="#syntax">Syntax Analysis</A>
<ul>
<li> <A href="#10">Lecture 10</A>
<li> <A href="#11">Lecture 11</A>
<li> <A href="#12">Lecture 12</A>
<li> <A href="#13">Lecture 13</A>
<li> <A href="#14">Lecture 14</A>
<li> <A href="#15">Lecture 15</A>
<li> <A href="#16">Lecture 16</A>
<li> <A href="#17">Lecture 17</A>
<li> <A href="#18">Lecture 18</A>
<li> <A href="#19">Lecture 19</A>
</ul>
</ul>
</td>
<td align=top>
<ul>
<li> <A href="#semantic">Semantic Analysis</A>
<ul>
<li> <A href="#20">Lecture 20</A>
<li> <A href="#21">Lecture 21</A>
<li> <A href="#22">Lecture 22</A>
<li> <A href="#23">Lecture 23</A>
<li> <A href="#24">Lecture 24</A>
<li> <A href="#25">Lecture 25</A>
<li> <A href="#26">Lecture 26</A>
<li> <A href="#27">Lecture 27</A>
<li> <A href="#28">Lecture 28</A>
<li> <A href="#30">Lecture 30</A>
<li> <A href="#31">Lecture 31</A>
<li> <A href="#32">Lecture 32</A>
<li> <A href="#33">Lecture 33</A>
</ul>
</ul>

<ul>
<li> Midterm Review
<ul>
<li> <A href="#29">Lecture 29</A>
</ul>
</ul>

<td>

<ul>
<li> <A href="#codegen">Intermediate Code Generation</A>
<ul>
<li> <A href="#34">Lecture 34</A>
<li> <A href="#35">Lecture 35</A>
<li> <A href="#36">Lecture 36</A>
<li> <A href="#37">Lecture 37</A>
<li> <A href="#38">Lecture 38</A>
<li> <A href="#39">Lecture 39</A>
<li> <A href="#40">Lecture 40</A>
<li> <A href="#41">Lecture 41</A>
<li> <A href="#42">Lecture 42</A>
<li> <A href="#43">Lecture 43</A>
<li> <A href="#44">Lecture 44</A>
<li> <A href="#45">Lecture 45</A>
</ul>
</td>
<td align=top>
<li> <A href="#finalcode">Final Code Generation</A>
<ul>
<li> <A href="#46">Lecture 46</A>
<li> <A href="#47">Lecture 47</A>
<li> <A href="#48">Lecture 48</A>
<li> <A href="#49">Lecture 49</A>
<li> <A href="#50">Lecture 50</A>
<li> <A href="#51">Lecture 51</A>
<li> <A href="#52">Lecture 52</A>
<li> <A href="#53">Lecture 53</A>
<li> <A href="#54">Lecture 54</A>
</ul>
<li> <A href="#optimization">Optimization</A>
<ul>

<li> <A href="#55">Lecture 55</A>
<li> <A href="#56">Lecture 56</A>
<li> <A href="#57">Lecture 57</A>

</ul>
</td>
</tr>
</table>

<p>
<font size=1> <A name=1>lecture #1</A> began here</font>
<p>

<h3> Syllabus</h3>

Yes, go over the <A href="syllabus.html">syllabus</A>.

<h3> Announcements </h3>

<ul>
<li> Starting next week, this class will have labs on Wednesdays, by zoom only,
from 3:40-5:40.  Today, however, there will not be a lab.
<li> Homework #1 is posted. It is due by end-of-day tomorrow. You should
     probably do it here and now, while you are listening to me, and have
     it out of the way.
</ul>


<A name="intro">
<h3>Why study compilers?</h3>
</a>

Computer scientists study compiler construction for the
following reasons:

<ul>
<li> Experience with large-scale
applications development. Your compiler may be the largest
program you write as a student.  Experience working with really big
data structures and complex interactions between algorithms will
help you out on your next big programming project.

<li> A shining triumph of CS theory.
It demonstrates the value of theory over the impulse to just "hack up"
a solution.

<li> A basic element of programming language research.
Many language researchers write compilers for the languages they design.

<li> Many applications have similar properties to one or more phases of
a compiler, and compiler expertise and tools can help an application
programmer working on other projects besides compilers.

</ul>

CSE 423 is labor intensive. This is a good thing: there is no way to
learn the skills necessary for writing big programs without this kind
of labor-intensive experience.

<h3> Some Tools we will use </h3>

Labs and lectures will discuss all of these, but if you do not know them
already, the sooner you go learn them, the better.

<dl>
<dt> C and "make".
<dd> If you are not expert with these yet, you will be a lot closer
     by the time you pass this class.
<dt> lex and yacc
<dd> These are compiler-writers tools, but they are useful for other
     kinds of applications, almost anything with a complex file format
     to read in can benefit from them.
<dt> gdb and valgrind
<dd> If you do not know a source-level like gdb debugger well, start learning.
      You will need one to survive this class. If you have never used valgrind:
      it can find some bugs that gdb misses!
<dt> e-mail
<dd> Regularly e-mailing your instructor is a crucial part of class
     participation.  If you aren't asking questions, you aren't doing
     your job as a student.
<dt> web
<dd> This is where you get your lecture notes, homeworks, and labs,
     and turnin all your work.
</dl>

<h3> Compilers - What Are They and What Kinds of Compilers are Out There? </h3>

The purpose of a compiler is: to translate a program in some language (the
<i>source language</i>) into a lower-level language (the <I>target
language</i>).  The compiler itself is written in some language, called
the <i>implementation language</i>.  To write a compiler you have to be
very good at programming in the implementation language, and have to
think about and understand the source language and target language.<p>

There are several major kinds of compilers:

<dl>
<dt> Native Code Compiler
<dd> Translates source code into hardware (assembly or machine code)
     instructions.  Example: gcc.

<dt> Virtual Machine Compiler
<dd> Translates source code into an abstract machine code, for execution
     by a virtual machine interpreter.  Example: javac.

<dt> JIT Compiler
<dd> Translates virtual machine code to native code.  Operates within
     a virtual machine. Example: Sun's HotSpot java machine.

<dt> Preprocessor
<dd> Translates source code into simpler or slightly lower level source code,
     for compilation by another compiler.  Examples: cpp, m4.

<dt> Pure interpreter
<dd> Executes source code on the fly, without generating machine code.
     Example: Lisp.
</dl>

OK, so a pure interpreter is not really a compiler.  Here are some more tools,
by way of review, that compiler people might be directly concerned with, even
if they are not themselves compilers.
You should learn any of these terms that you don't already know.

<dl>
<dt> assembler
<dd> a translator from human readable (ASCII text) files of machine
instructions into the actual binary code (object files) of a machine.
<dt> linker
<dd> a program that combines (multiple) object files to make an executable.
     Converts names of variables and functions to numbers (machine addresses).
<dt> loader
<dd> Program to load code.  On some systems, different executables start at
     different base addresses, so the loader must patch the executable with
     the actual base address of the executable.
<dt> preprocessor
<dd> Program that processes the source code before the compiler sees it.
     Usually, it implements macro expansion, but it can do much more.
<dt> editor
<dd> Editors may operate on plain text, or they may be wired into the rest
     of the compiler, highlighting syntax errors as you go, or allowing
     you to insert or delete entire syntax constructs at a time.
<dt> debugger
<dd> Program to help you see what's going on when your program runs.
     Can print the values of variables, show what procedure called what
     procedure to get where you are, run up to a particular line, run
     until a particular variable gets a special value, etc.
<dt> profiler
<dd> Program to help you see where your program is spending its time, so
     you can tell where you need to speed it up.
</dl>



<h3> Phases of a Compiler </h3>

<dl>
<dt>Lexical Analysis:</dt>
<dd>Converts a sequence of characters into words, or <I>tokens</i></dd>
<dt>Syntax Analysis:</dt>
<dd>Converts a sequence of tokens into a <I>parse tree</i></dd>
<dt>Semantic Analysis:</dt>
<dd>Manipulates parse tree to verify symbol and type information</dd>
<dt>Intermediate Code Generation:</dt>
<dd>Converts parse tree into a sequence of intermediate code instructions</dd>
<dt>Optimization:</dt>
<dd>Manipulates intermediate code to produce a more efficient program</dd>
<dt>Final Code Generation:</dt>
<dd>Translates intermediate code into final (machine/assembly) code</dd>
</dl>

<p>
<A name="lexical">
<font size=1> <A name=2>lecture #2</A> began here</font>
</A>
<p>

<h3> Comments on HW#0 </h3>

<ul>
<li> Expected and saw a wide variation in levels of C experience
<li> Apparently some previous offerings of CSE 423 allowed students
     to choose their implementation language.  I am not quite so
     open-minded as that.  Here is our policy.
<li> C is the recommended language for you to use in this course,
     however there is a bit of wiggle room.
<li> The ideal language is: the one that you know best, that happens
     to have a near-100%-compatible lex and yacc tool, and happens
     to be on lovecraft.cs.nmt.edu aka login.cs.nmt.edu.
<li> Examples of languages I've allowed students to attempt to use in past:
<dl>
<dt> C++
<dd> OK, but not recommended. If calling flex/bison from C++ give you trouble
     that's on you.
<dt> Python
<dd> Vetoed. The main "lex and yacc for Python", PLY, is not lex and yacc
     compatible enough.  Past students who I allowed this performed poorly.
<dt> Java
<dd> OK, but you have to agree to use jflex and byacc/j, and we might need
     to do some setup for it to run as needed.
<dt> <A href="http://www.unicon.org">Unicon</A>
<dd> My research language will be used
     occasionally as an executable pseudocode in examples this semester.
     Unicon is obscure, with language level akin to Python but
     syntax a bit more C/Pascal/Java-ish. Lex and yacc specifications
     that are written carefully can be shared by Unicon and Java tools.
</dl>
<li> If you wish to use something other than C, you must confer with Dr. J
     and it must be approved. Which pretty much means we have to be able
     to make it run on lovecraft.
</ul>


<H3> Example of the Compilation Process </h3>

Consider the example statement; its translation to machine code
illustrates some of the issues involved in compiling.
<table border><tr><td><pre>
position = initial + rate * 60
</pre></table>
30 or so characters, from a single line of source code, are first
transformed by lexical analysis into a sequence of 7 tokens.  Those
tokens are then used to build a tree of height 4 during syntax analysis.
Semantic analysis may transform the tree into one of height 5, that
includes a type conversion necessary for real addition on an integer
operand.  Intermediate code generation uses a simple traversal
algorithm to linearize the tree back into
a sequence of machine-independent three-address-code instructions.
<p>
<table border><tr><td><pre>

  t1 = inttoreal(60)&nbsp;&nbsp;
  t2 = id<sub>3</sub> * t1
  t3 = id<sub>2</sub> + t2
  id<sub>1</sub> = t3</pre></table>

<p>
Optimization of the intermediate code allows the four instructions to
be reduced to two machine-independent instructions.  Final code generation
might implement these two instructions using 5 machine instructions, in
which the actual registers and addressing modes of the CPU are utilized.
<p>

<table border><tr><td><pre>

  MOVF	id<sub>3</sub>, R2&nbsp;&nbsp;
  MULF	#60.0, R2
  MOVF	id<sub>2</sub>, R1
  ADDF	R2, R1
  MOVF	R1, id<sub>1</sub>
</pre>
</tr>
</table>

<h4> Reading! </h4>

<ol>

<li>
Read the Thain text chapters 1-3. Within the Scanning chapter, there are
portions on the finite automata that should be CSE 342 review; you may
SKIM that material, unless you don't know it or don't remember it.

<li>
Read Sections 3-5 of the Flex manual,
<A href="http://westes.github.io/flex/manual/">Lexical Analysis With Flex</A>.

<li> Read the class lecture notes
as fast as we manage to cover topics. Please ask questions about
whatever is not totally clear.  You can <em>Ask Questions</em> in class or
via e-mail.
</ol>

<p>

Although the whole course's lecture notes are ALL available to you
up front, I generally revise each lecture's notes, making additions,
corrections and adaptations to this year's homeworks, the night before each
lecture.  The best time to print hard copies of the lecture notes, if you
choose to do that, is one
day at a time, right before the lecture is given.  Or just read online.
<p>


Unlike software engineering, the compiler class project is mostly
a solo exercise,
meant to increase your skill at programming on a larger scale than in most
classes. On the one hand it is sensible to use software engineering tools
such as revision control systems (like git) on a large project like this.
On the other hand it is not OK to share your work with your classmates,
intentionally or through stupidity. If you use a revision control system,
figure out how to make it private. Various options:
<ul>
<li> on github you setup private repositories, either for free or cheap
<li> you can use revision control with a local repository. setup is easy,
     but if you do this, figure out how to back up your work.
<li> you can figure out how to do git through ssh onto a department unix
     account
</ul>
<p>


<h3> Initial Discussion of HW#1 </h3>

This one is on a tight fuse, please hit the ground running and seek
assistance if anything hinders your progress.


<h3> Getting Going</h3>

Last time, we ended sort of in the middle of a description of
<A href="hw1.html">Homework #1</A>.
We need to finish that, but we also need some introductory material on
lexical analysis in order to understand parts of it. So we will come
back to HW#1 before the end of class.


<h3> Overview of Lexical Analysis </h3>

A lexical analyzer, also called a <em>scanner</em>, typically has the
following functionality and characteristics.

<ul>

<li> Its primary function is to convert from a (often very long) sequence of
characters into a (much shorter, perhaps 10X shorter) sequence of tokens.
This means less work for subsequent phases of the compiler.

<li> The scanner must Identify and Categorize specific character sequences
into tokens.  It must know whether every two adjacent characters in the file
belong together in the same token, or whether the second character must be
in a different token.

<li> Most lexical analyzers discard comments &amp; whitespace. In most
languages these characters serve to separate tokens from each other, but
once lexical analysis is completed they serve no purpose.  On the other
hand, the exact line # and/or column # may be useful in reporting errors,
so some record of what whitespace has occurred may be retained.  <em>Note:</em>
in some languages, even popular ones, whitespace is significant.

<li> Handle lexical errors (illegal characters, malformed tokens) by
reporting them intelligibly to the user.

<li> Efficiency is crucial; a scanner may perform elaborate input buffering

<li> Token categories can be (precisely, formally) specified using regular
expressions, e.g.
<pre>
	 IDENTIFIER=[a-zA-Z][a-zA-Z0-9]*
</pre>

<li> Lexical Analyzers can be written by hand, or implemented automatically
using finite automata.
</ul>

<p>
<font size=1> <A name=3>lecture #3</A> began here</font>
<p>

<h3>A couple comments on the Lab for this course</h3>

<dl>
<dt> Main purpose of the lab: auxiliary public Q &amp; A and debugging help
     for your project. <dd> Bring us your coredumps, your stack overflows, your
     huddled parse problems, yearning to breath free.
<dt> Auxiliary purpose of the lab: extended practice with the
     professional tools of the course.
<dd> For some of you, this part will be review.
<dt> Format of the labs: usually a public Q &amp; A followed by
     an hour or so lab exercise.  The TA may run a lot of the lab
     or instructor and TA may alternate or team teach it.
<dt> Grading of the Labs
<dd> The Labs are to help you complete your real homework (project)
     assignments and will be a miniscule portion of your grade, treated
     comparable to quizzes. Let's say, the aggregate of all labs (and quizzes,
     if any) will amount to 5%. A given lab might be 0.3-0.5% and is
     likely to be graded on a boolean (you did it or not) scsale.
</dl>


<h3> What is a "token" ?</h3>

In compilers, a "token" is:

<ol>
<li> a single word of source code input (a.k.a. "lexeme")
<li> an integer code that refers to (the category of) a single word of input
<li> a set of lexical attributes computed from a single word of input
<li> a struct (or object) that holds all those attributes
</ol>

Programmers think about all this in terms of #1. Syntax checking uses
#2. Error reporting, semantic analysis, and code generation require #3.  In
a compiler written in C, for each token you allocate a C struct to store (3)
for each token.

<h4> Auxiliary data structures </h4>

You were presented with the phases of the compiler, from lexical and syntax
analysis, through semantic analysis, and intermediate and final code 
generation.  Each phase has an input and an output to the next phase.
But there are a few data structures
we will build that  survive across multiple phases: the literal table,
the symbol table, and the error handler.

<dl>
<dt> lexeme table
<dd> a table that stores lexeme values, such as strings and variable
     names, that may occur in many places.  Only one copy of each
     unique string and name needs to be allocated in memory.
     (This is an optional memory-saving device.)
<dt> symbol tables
<dd> symbol tables store the names defined (and visible within) each
     particular scope. The most common scopes are: global, and procedure
     (local).
     Real languages have more scopes such as class (or record)
     and package.
<dt> error handlers
<dd> errors in lexical, syntax, or semantic analysis need a common
     reporting mechanism, that shows where the error occurred (filename,
     line number, and maybe column number are useful). This may entail
     helper functions, global variables, or entire data structures.
</dl>



<h3> Regular Expressions </h3>

The notation we use to precisely capture all the variations that a given
category of token may take are called "regular expressions" (or, less
formally, "patterns".  The word "pattern" is really vague and there are
lots of other notations for patterns besides regular expressions).
Regular expressions are a shorthand notation
for sets of strings.  In order to even talk about "strings" you have
to first define an <em>alphabet</em>, the set of characters which can
appear.

<ol>
<li> Epsilon (&epsilon;) is a regular expression denoting the set
     containing the empty string
<li> Any letter in the alphabet is also a regular expression denoting
     the set containing a one-letter string consisting of that letter.
<li> For regular expressions r and s, <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; r | s<br>
     is a regular expression denoting the union of r and s
<li> For regular expressions r and s, <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; r s<br>
     is a regular expression denoting the set of strings consisting of
     a member of r followed by a member of s
<li> For regular expression r, <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; r*<br>
     is a regular expression denoting the set of strings consisting of
     zero or more occurrences of r.
<li> You can parenthesize a regular expression to specify operator
     precedence (otherwise, alternation is like plus, concatenation
     is like times, and closure is like exponentiation)
</ol>



<h3> Lex/Flex Extended Regular Expressions </h3>

Although the basic regular expression operators given earlier
are sufficient to describe all regular languages,
in practice everybody uses extensions:

<ul>
<li> For regular expression r, <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; r+<br>
     is a regular expression denoting the set of strings consisting of
     one or more occurrences of r.  Equivalent to rr*
<li> For regular expression r, <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; r?<br>
     is a regular expression denoting the set of strings consisting of
     zero or one occurrence of r.  Equivalent to r|&epsilon;
<li> The notation [abc] is short for a|b|c.  [a-z] is short for a|b|...|z.
     [^abc] is short for: any character other than a, b, or c.
<li> The dot (.) operator matches any one char except newline. [^\n]
</ul>

Lex has a Lot of extended regular expressions.  I have listed the minimum
set that you are absolutely responsible for knowing. How many others do you
remember from reading the Flex manual?

<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>


<p>



<h3> Lex extended regular expressions </h3>

Here is an almost-complete list of Lex's regular expressions:

<dl>
<dt> c
<dd> normal characters mean themselves
<dt> \c
<dd> backslash escapes remove the meaning from most operator characters.
     Inside character sets and quotes, backslash performs C-style escapes.
<dt> "s"
<dd> Double quotes mean to match the C string given as itself.
     This is particularly useful for multi-byte operators and may be
     more readable than using backslash multiple times.
<dt> [s]
<dd> This character set operator matches any one character among those in s.
<dt> [^s]
<dd> A negated-set matches any one character not among those in s.
<dt> .
<dd> The dot operator matches any one character except newline: [^\n]
<dt> r*
<dd> match r 0 or more times.
<dt> r+
<dd> match r 1 or more times.
<dt> r?
<dd> match r 0 or 1 time.
<dt> r{m,n}
<dd> match r between m and n times.
<dt> r<sub>1</sub>r<sub>2</sub>
<dd> concatenation. match r<sub>1</sub> followed by r<sub>2</sub>
<dt> r<sub>1</sub>|r<sub>2</sub>
<dd> alternation. match r<sub>1</sub> or r<sub>2</sub>
<dt> (r)
<dd> parentheses specify precedence but do not match anything
<dt> r<sub>1</sub>/r<sub>2</sub>
<dd> lookahead.  match r<sub>1</sub> when r<sub>2</sub> follows, without
     consuming r<sub>2</sub>
<dt> ^r
<dd> match r only when it occurs at the beginning of a line
<dt> r$
<dd> match r only when it occurs at the end of a line
</dl>



<h3> Avoid Common Regex Bugs </h3>

Usually when doing your homework, you figure out if you messed up and fix it,
but it can bite you on exams

<dl>
<dt> square bracket abuse
<dd> trying to use regex operators inside square brackets; trying to use
     square brackets as if they were parentheses
<dt> good old fashioned operator precedence problems
<dd> when in doubt, use parentheses
<dt> writing a regular expression that is too loose
<dd> be careful especially when using a regex that matches everything;
     you can read the entire file with one match.
</dl>

<h3> Some Regular Expression Examples </h3>

Regular expressions are the preferred notation for
specifying patterns of characters that define token categories.  The best
way to get a feel for regular expressions is to see examples.  Note that
regular expressions form the basis for pattern matching in many UNIX tools
such as grep, awk, perl, etc. <p>

What is the regular expression for each of the different lexical items that
appear in C programs?  How does this compare with another, possibly simpler
programming language such as BASIC?  What are the corresponding rules for our
language this semester, are they the same as C?

<!--This is the first of many things where BASIC is somewhat easier 
to deal with than C.-->

<table border>
<tr> <th> lexical category <th> BASIC <th> C <!--<th> Go--> </tr>
<tr> <td> operators <td> the characters themselves
    <td> For operators that are regular expression operators we need mark them
     with double quotes or backslashes to indicate you mean the character,
     not the regular expression operator.  Note several operators have a
     common prefix. The lexical analyzer needs to look ahead to tell
     whether an = is an assignment, or is followed by another = for example.
<!-- <td> ??-->
 </tr>
<tr> <td> reserved words <td> the concatenation of characters; case insensitive <td>
     Reserved words are also matched by the regular expression for identifiers,
     so a disambiguating rule is needed.
<!-- <td> ??-->
</tr>

<tr>
<td> identifiers <td> no _; $ at ends of some; 2 significant letters!?; case insensitive <td> [a-zA-Z_][a-zA-Z0-9_]*
<!-- <td> Same a C; only difference is that starting with a Capital specifies
public members of a package. -->
</tr>

<tr>
<td> numbers <td> ints and reals, starting with [0-9]+ <td> 0x[0-9a-fA-F]+ etc.
<!-- <td> Go has C literals, plus imaginary/complex numbers.-->
</tr>

<tr> <td> comments <td> REM.* <td> C's comments are tricky regexp's
<!-- <td> ??-->

<tr> <td> strings <td> almost ".*"; no escapes <td> escaped quotes
<!-- <td> ??-->

<tr> <td> what else?
<!-- <td> ??-->

</table>

<p>
<font size=1> <A name=4>lecture #4</A> began here</font>
<p>
<h3> Comments </h3>

OK, what have you got?


<h3> What are the Best Regular Expressions you can Write for c113c ?</h3>

What corrections/improvements/additions are needed in the following?
Note that the full ANSI C language would entail a lot of additions.
What additions are needed for the c113c subset?
<p>

<table border>
<tr> <th> Category <th> Regular Expression
<tr> <td> Variable names <td> [a-zA-Z_][a-zA-Z0-9_]*
<tr> <td> Integer constants <td> "-"?[0-9]+ | "0x"[0-9A-Fa-f]+
<tr> <td> Real # Constants <td> [0-9]*"."[0-9]+
<tr> <td> String Constants <td> \"([^"\n]|("\\\""))*\"
</table>

<p>


<h3> Lexing Reals </h3>

C float and double constants have to have at least one digit, either
before or after the required decimal.  This is a pain:
<pre>
([0-9]+.[0-9]* | [0-9]*.[0-9]+) ...
</pre>

You might almost be happier if you wrote

<pre>
([0-9]*.[0-9]*)    { return (strcmp(yytext,".")) ? REAL : PERIOD; }
</pre>

Starring: C's ternary operator <code>e1 ? e2 : e3</code> is an if-then-else
expression, very slick.  Note that if you have to support
scientific/exponential real numbers (JSON does), you'll need a bigger regex.



<!--
<h3> Introductory Comments on BASIC </h3>

We are doing (a large subset of) TRS-80 Color Computer Extended BASIC.
Compared with last semester, you will get more help from me on getting
started with each assignment, and be asked to do a little more.

<li>  The main language reference manuals are on our class web page...

<li> I am writing my own commentary on it 
<A href="basic.html">
basic.html</A>
where most of your formal specifications will appear.

<li> I have made a start at some pseudocode
<A href="basic.icn">basic.icn</A>
for the "interpreter loop" that will wrap around your compiler.
-->


<h3> Lexical Attributes and Token Objects </h3>

Besides the token's category, the rest of the compiler may need several
pieces of information about a token in order to perform semantic analysis,
code generation, and error handling. 

A <em>lexical attribute</em> is a piece of information about a token.  These
typically include:

<table>
<tr><td> category <td> an integer code used to check syntax
<tr><td> lexeme <td> actual string contents of the token
<tr><td> line, column, file <td> where the lexeme occurs in source code
<tr><td> value <td> for literals, the binary data they represent
</table>


These are stored in an object instance of class Token, or in C, a struct.
The fields are generally something like:

<pre>
struct token {
   int category;
   char *text;
   int linenumber;
   int column;
   char *filename;
   union literal value;
}
</pre>

The union literal will hold computed values of integers, real numbers, and
strings.  <em>In your homework assignment, I am requiring you to compute
column #'s; not all compilers require them, but they are easy.  Also: in
our compiler project we are not worrying about optimizing our use of memory,
so am not requiring you to use a union</em>.



<h4> Avoid These Common Bugs in Your Homeworks and Labs! </h4>

<ol>
<li> yytext or yyinput were not declared global
<li> main() does not have its required argc, argv parameters!
<li> main() does not call yylex() in a loop or check its return value
<li> getc() EOF handling is missing or wrong!  check EVERY all to getc() for EOF!
<li> opened files not (all) closed! file handle leak!
<li> end-of-comment code doesn't check for */
<li> yylex() is not doing the file reading
<li> yylex() does not skip multiple spaces, mishandles spaces at the front
     of input, or <em>requires</em> certain spaces in order to function OK
<li> extra or bogus output not in assignment spec
<li> = instead of ==
</ol>

<!--
<h3> Language Candidates </h3>

Hypothesize that "it would be wise" for us to choose a language subset project
that is defined by somebody and NOT to make up one from scratch.  FYI: Python
does not have a widely-available YACC parser; Ruby apparently does.

<dl>
<dt> C-based: C-minus-minus
<dd> Pro: familiar.  Con: boring.  And name overloaded by multiple groups.
     Difference from Heckendorn: I will make you target x86_64 assembler.
<dt> Java-based: <A href="http://BantamJava.com"> BantamJava </A> or <A href="http://www2.cs.uidaho.edu/~jeffery/godiva/">Godiva-0</A>
<dd> Pro: Java knowledge is useful.
<dt> TRS-80 Extended Color BASIC
<dd> Pro: can run cool 80's games on it.  Con: BASIC is so last-century
<dt> Ruby-based
<dd> Pro: cool.  Con: ill-defined.  Would we just copy and study the existing
     implementation?  Blah
<dt> Plzero (Pascal language 0, I think)
<dd> Pro: I am sure I have a copy lying around that is newer than the one at
      <A href="http://www.moorecad.com/standardpascal/plzero.pas">moorecad</A>.
<dt> Unicon-based
<dd> Pro: Jeffery knows it inside and out. Con: who cares about Unicon?
</dl>
-->

<h3> <tt>lex(1)</tt> and <tt>flex(1)</tt> </h3>

These programs generally take a lexical specification given in a .l file
and create a corresponding C language lexical analyzer in a file named
lex.yy.c.  The lexical analyzer is then linked with the rest of your compiler.
<p>

The C code generated by lex has the following public interface.  Note the
use of global variables instead of parameters, and the use of the prefix
yy to distinguish scanner names from your program names.  This prefix is
also used in the YACC parser generator.
<pre>
FILE *yyin;	/* set this variable prior to calling yylex() */
int yylex();	/* call this function once for each token */
char yytext[];	/* yylex() writes the token's lexeme to an array */
                /* note: with flex, I believe extern declarations must read
                   extern char *yytext;
                 */
int yywrap();   /* called by lex when it hits end-of-file; see below */
</pre>
<p>

The .l file format consists of a mixture of lex syntax and C code fragments.
The percent sign (%) is used to signify lex elements.  The whole file is
divided into three sections separated by %%:
<pre>
   header
%%
   body
%%
   helper functions
</pre>
<p>

The header consists of C code fragments enclosed in %{ and %} as well as
macro definitions consisting of a name and a regular expression denoted
by that name.  lex macros are invoked explicitly by enclosing the
macro name in curly braces.  Following are some example lex macros.
<pre>
letter		[a-zA-Z]
digit		[0-9]
ident		{letter}({letter}|{digit})*
</pre>
<p>

<blockquote>
<em>A friendly warning: your UNIX/Linux/MacOS Flex tool is NOT
good at handling input files saved in MS-DOS/Windows format, with
carriage returns before each newline character.  Some browsers,
copy/paste tools, and text editors might add these carriage returns
without you even seeing them, and then you might end up in Flex Hell
with cryptic error messages for no visible reason. Download with
care, edit with precision. If you need to get rid of carriage returns
there are lots of tools for that. You can even build them into your
makefile. The most classic UNIX tool for that task is tr(1), the
character translation utility</em>
</blockquote>

<p>
<font size=1> <A name=5>lecture #5</A> began here</font>
<p>

<h3>Peek at <A href="hw2.html">HW#2</A> </h3>

Short fuse on this one, dive into Flex this week, see if you can get
it done (mostly) on/by Wednesday's Flex lab.

<h3> Flex Header Section syntax </h3>

<ul>
<li> <code>%{</code>   and  <code>%}</code>  mark off any C code
that is to be passed through into the top of the generated lex.yy.c
file.
<li>  Flex might otherwise think you are defining a macro.
<li>  Lex's
syntax is bluntly fast and loose and it will give you cryptic error
messages, or no error messages, if you take any liberties.
</ul>

<h3> Flex Body Section </h3>

The body consists of a sequence of regular expressions for different
token categories and other lexical entities.

<ul>
<li> Each regular expression can
have a (C) code fragment enclosed in curly braces that executes when that
regular expression is matched.
<li> For most of the regular expressions the 
code fragment (called a <em>semantic action</em>) consists of returning
an integer that identifies the token category to the rest of the compiler.
It is used by the parser to check syntax.
<li>  Some typical regular
expressions and semantic actions might include:

<pre>
" "		{ /* no-op, discard whitespace */ }
{ident}		{ return IDENTIFIER; }
"*"		{ return ASTERISK; }
"."		{ return PERIOD; }
</pre>

<li> You also need regular expressions for lexical errors such as unterminated
character constants, or illegal characters.

<li>  If your semantic action executes a return, yylex() is done and has to
be called again by the surrounding code. If there is no semantic action or it
does not return, yylex() resumes scanning looking for a new regular expression
after the action code completes.

<li> If NO regular expression will match at a given point, yylex() literally
just advances and prints one character to standard out, and restarts the scan
at the next character.

<li> If two or more regular expressions match, yylex() uses the longest match
<li> If two or more regular expressions match at the same longest length
    possible, yylex() just uses whichever one appears first in the .l file

</ul>
<p>

Actually, your semantic actions in a compiler will do more than just
return the category code.
<ul>
<li> Helper functions can be called from the actions in a lex file
body section
<li> Helper functions typically compute lexical attributes,
such as the actual integer or string values denoted by literals.
<li> One helper function that is required is yywrap(), which is called when lex
hits end of file.  If you just want lex to quit, have yywrap() return 1.
If your yywrap() switches yyin to a different file and you want lex to continue
processing, have yywrap() return 0.
<li> On some systems, a "lex library" or "flex library" (-ll or -lfl)
provides a default <code>yywrap()</code> function that return a 1
<li> Flex has the directive
<code>%option noyywrap</code> which allows you to skip writing this function.
<li>
You can avoid a similar warning for an unused unput() function by saying
<code>%option nounput</code>.
</ul>
<p>

Note: other platforms with working Flex installs (including
some versions of CENTOS, apparently including lovecraft)
do not have a flex library, neither <code>-ll</code> nor
<code>-lfl</code>. Use <code>%option</code> directives
or provide your own functions instead of expecting <code>-lfl</code>
to be present.  Example:
<pre>
%{
#include &lt;stdio.h&gt;
%}
%option noyywrap
%%
"abc"	{ printf("!!!"); }
%%
int main()
{
   yyin = stdin;
   return yylex();
}
</pre>

<h3> Lexical Error Handling </h3>

<ul>
<li> Really, two kinds of lexical errors: nonsense, and stuff in the base
     language that's not in our subset of that language.
<li> Include file name and line number in your error messages.
<li> Avoid cascading error messages -- only print the first one you see
     on a given line/function/source file.
<li> You can write regular expressions for common errors, in order
     to give a better message than "lexical error" or "unrecognized character".
     (This is how you should approach stuff in the base language but not our
     subset.)
</ul>


<p>
<font size=1> <A name=6>lecture #6</A> began here</font>
<p>


<h3> Announcement </h3>

Spring Fair on Tuesday Feb 2nd, tomorrow.  The Fair is completely on line
and on HANDSHAKE.  We have companies and grad schools ready to hire for full
time and internships as well as grad school appointments.

<h3> Comments on HW#1 </h3>

<ul>
<li> "Implementing every single language feature that we were exposed
     to in CSE113 seems excessive" -- yeah, OK. We are looking for the
     subset that you would have to be able to use to do the homeworks.
<li> Ranged in size from like 6 to 20 pages.
<li> Grades vary, but I was not being super-picky. HW#1 will be weighted
     far less than subsequent homeworks.
<li> DrJ's bugs left in your doc are "amusing"; deja vu across teams,
     not so much.  (my name, the missing &lt;stdio.h&gt;, the Go reference)
<li> Many teams proposed somewhat too much
<li> Several teams proposed things that aren't quite C ?!
<li> In some cases where teams reported differently, I am left wondering
     (pointer arithmetic? *** ? array dimensionality? in 113?)
<li> Yeah, no, #define and #include are not tokens, but what is our
     preprocessor strategy?
<li> I am still extracting/constructing our final spec.  But let's look at
     <A href="annotated-c113c.pdf">one of them</A>
     and consider what changes are needed.
</ul>

<h3> Mailbag </h3>

<dl>
<dt> I'm not understanding what the output is supposed to look like
     for Exercise 4 on Lab 1.
     Do we make a single yylex() call read until a new category of
     character is found, or is yylex() supposed to just read one
     character every time, and we distinguish the adjacent groups
     outside of yylex()?
<dd> Input "aaa" is supposed to return a single time, having eaten all
     three a's. The end of the lab is trying to move from "one call to
     yylex() eats one character" to "one all to yylex() eats one word".
     A by-product, I would hope, would be that you end up being glad that
     Flex is going all the work for you is HW#2 and beyond, as without it
     you'd be spending a Lot more time working out stupid character
     processing details.
</dl>

<h3> Old Mailbag </h3>

<dl>
<!--
<dt> I've heard of <code>malloc()</code>, but I haven't had any real experience
     working with it.
<dd> <code>malloc()</code>, <code>calloc()</code> and <code>realloc()</code>
     are a flexible memory management
     API for C that corresponds roughly to <code>new</code> keyword in C++
     or Java.  The <code>malloc()</code> family allows you to
     allocate memory generically by # of bytes, independent of the type
     system. This capability is powerful but dangerous.
-->

<dt> What should the lexical analyzer look like?  where do I start?
<dd> In Homework #2 you learn to use a declarative language called
     Flex which does almost all the work for you. The only design
     issue is how does it interact with the rest of the compiler, i.e.
     its public interface. This is mostly hardwired/designed for you
     by Flex. Your only customization option is in what form to make token
     information available to the later phases of the compiler.

<dt> How should our output be visible?
<dd> One human readable output line, per token, as shown in hw2.html
     Build the linked list first, then walk it (visit all nodes) to
     print the output. Figure out how to do this so output is in the
     correct order and not reversed!

<dt> You mention storing the int and double as binary. That just means
     storing them in int and double variables, correct?
<dd> It means for constants you have to convert from the lexeme string
     that actually appears in the source code to the value (int, double)
     and then store the result in the corresponding lexical attribute
     variable.

<dt> When do you use <code>extern</code> and when do you use
     <code>#include</code> in C programming?
<dd> <code>extern</code> can be done without an <code>#include</code>,
    to tell one module
    about global variables defined in another module. But if you are
    going to share that <code>extern</code> with multiple modules, it
    is best to put it in an <code>#include</code>.
    More generally, use <code>#include</code> in order to share types,
    externs, function prototypes,
    and symbolic <code>#define</code>'s across multiple files. That is all.
    No code, which is to say, no function bodies.
<dt> Can I add parameters to <code>yylex()</code>?
<dd> No, you can't add your own parameters, <code>yylex()</code> is a
     public interface.
     You might be tempted to return a token structure pointer, or
     add some parameters to tell it what filename it is reading from.
     But you can't.  Leave <code>yylex()</code>'s interface alone,
     the parser will call it with its current interface.

<dt> Do you want us to have a .h file for enumerating all the different
     kind of tokens for HW 1? I was looking into flex and bison and it
     looks like bison creates a tab.h file that does this automatically.
<dd> Yes. In HW1 you create a .h file for these defines; plan to throw it
     away in favor of the one Bison creates for you in HW#2.
<dt> Are you going to provide us the list of tokens required, or the .h file?
<dd> Usually I provide a language reference, from which you are to make the
     list. But by asking the right questions, you are making me add details
     to the language reference.

<dt> Will you always call "make" on our submissions?
<dd> Yes. I expect you to use make and provide a makefile in each
     homework. Turn in the whole source, not just "changed" or
     "new" files for some assignments. My script will
     unpack your .zip file by saying "unzip" in some new test directory
     and then run "make" and then run your executable. If
     anything goes wrong (say, you unzipping into a subdirectory the script
     does not know the name of) you will lose a few points.
<br><br>
     On the other hand, I do not want the tool-generated files
     (lex.yy.c, cgram.tab.c) or .o or executables.  The makefile should
     contain correct dependencies to rerun flex (and later, bison) and
     generate these files whenever source (.l, .y , etc.) files are changed.

<dt>

When creating the linked list I see that you have a struct token and a
struct tokenlist. Should I create my linked list this way or can I eliminate
the struct tokenlist and add a next pointer inside struct token(struct token
*next) and use that to connect my linked list?

<dd>

The organization I specified - with two separate structs - was very
intentional. Next homework, we need the struct tokens that we allocate from
inside yylex(), but not the struct tokenlist that you allocate from outside
yylex(). You can do anything you want with the linked list structure, but
the struct token must be kept more-or-less as-is, and allocated inside
yylex() before it returns each time.

<dt> I was wondering if we should have a different code for each keyword or just have a 'validkeyword' code and an 'invalidkeyword' code.
<dd>  Generally, you need a different code for two keywords if and when they are used in different positions in the syntax.  For example, int and float are type names and are used in the same situations,  but the keywords func and if, denoting the beginning of a function and the beginning of a conditional expression, have different syntax rules and need different integer codes.

<dt> In the specification for assignment 1 it says that
     if there is no extension given, we should add the required extension
     to the filename.
     Should we still accept and run our compiler on other file extensions
     that could be provided or should we return an error of some sort?
<dd> Accept no other extensions. If any file has an illegal extension,
     you can stop with a message like: "Usage: cc [options] filename[.c] ..."
<dt> how am i supposed to import the lexer into my main.c file?
<dd> Do not import or #include your lexer. Instead,
     link your lexer into the executable, and tell <code>main()</code>
     how to call it, by providing a prototype for <code>yylex()</code>.
     If <code>yylex()</code>
     sets any global variables (it does), you'd declare those as
     <code>extern</code>. You can do prototypes and externs in main.c,
     but these things are exactly what header (.h) files were invented for.
<dt> Is the <code>struct token</code> supposed to be in our
     <code>main()</code>? Do we use <code>yylex()</code>
     along with other variables within lex.yy.c to fill the "struct token" with
     the required information?

<dd> Rather than overwriting a global struct each time, a <em>pointer</em>
    to a struct token should be in <code>main()</code>.
    Function <code>yylex()</code> should allocate a struct token, fill it,
    and make it visible to <code>main()</code>, probably by assigning its
    address to some global pointer variable. Function <code>main()</code>
    should build the linked list in a loop, calling <code>yylex()</code> each
    time through the loop. It should then print the output by looping through
    the linked list.

<!--<dt> Proposed regex solution
<dd> How about this (amalgamated) student proposed solution:
<pre>
"/*"(("*"+[^/*])|[^*]+)*"*"+"/"
</pre>
Correct or not?  If incorrect, give example where it fails.
Can it match <code>/* this **/ regex here*/</code>
-->

<!--
<dt> Discussion of include stacks. Thank you to the student contributor of
this example:
<dd>
<pre>
Here's the code I'm using to push/pop the lexer state.
It uses a couple of user-defined functions and a struct
to store auxiliary information such as the filename,
but the rest are standard C/flex functions.

/*
 * Return 1 if done, 0 if yyin points at more input
 */
int yywrap() {
    // Is the state stack empty?
    if(include_stack == NULL) {
        return 1;
    } else {
        fclose(yyin);

        // Grab the previous input file from the state stack.
        yypop_buffer_state();
        SourceFileState state = pop_file_state(&include_stack);
        filename = state.filename;
        line_num = state.line_num;
        return 0;
    }
}

/*
 * Handles a "user" include directive (using double quotes)
 */
static void handle_user_include() {
    char *fname = strchr(yytext, '\"')+1;
    fname[strlen(fname)-1] = '\0';
    fname = strdup(fname);

    FILE* input_file = fopen(fname, "r");
    if(!input_file) {
        fprintf(stderr, "Unable to open include file %s: ", fname);
        perror("");
        exit(1);
    }

    // Push flex's internal buffer state.
    yypush_buffer_state(yy_create_buffer(input_file, YY_BUF_SIZE));
    // Push "auxiliary" file data.
    push_file_state(&include_stack, filename, line_num);
    filename = fname;
    line_num = 1;
}
</pre>

<A href="http://westes.github.io/flex/manual/Multiple-Input-Buffers.html#Multiple-Input-Buffers">Section 11 of the Flex manual</A> discusses functions such as
yypush_buffer_state().
-->
</dl>


<h3> Old Mailbag </h3>

<dl>
<dt> When I compile my homework, my executable is named a.out, not what
     our compiler is supposed to be named!  What do I do?
<dd> Some of you who are less familiar with Linux should read the
     "manual pages" for gcc, make, etc.  gcc has a -o option, that would work.
     Or in your makefile you could rename the file after building it.

<dt> Can I use flex start conditions?
<dd> Yes, if you need to, feel free.

<dt> Can I have an extension?
<dd> Yeah, but the further you fall behind, the more zeroes you end up with
     for assignments that you don't do.
     Late homeworks are accepted with a penalty per day (includes
     weekend days) except in the case of a valid excused absence.
     The penalty starts at 10% per day (HW#1), and reduces by 2% per
     assignment (8%/day for HW#2, 6%/day for HW#3, 4%/day for HW#4,
     and 2%/day for HW#5).  I reserve the right to underpenalize.

<dt> Do you accept and regrade resubmissions?
<dd> Submissions are normally graded by a script in a batch.
     Generally, if an initial submission was fail, I might accept a
     resubmission for partial credit up to a passing (D) grade.  If a
     submission fails for a trivial reason such as a missing file, I might
     ask you to resubmit with a lighter penalty.

<dt> I have not been able to figure out how sscanf() will help me. Could you
     point me to an example or documentation.
<dd> <A href="sscanf.c">Yes</A>. Note that sscanf'ing into a double calls
     for a %lg.

<dt> What is wrong with my commandline argument code.
<dd> If it is not that you are overwriting the existing arrays with strcat()
     instead of allocating new larger arrays in order to hold new longer
     strings, then it is probably that you are using sizeof() instead of
     strlen().

<dt> Can you go over using the %array vs. the standard %pointer option
     and if there are any potential benefits of using %array?
     I was curious to see if you could use YYLMAX in junction
     with %array to limit the size of identifiers, but there is
     a probably a better way.
<dd> After yylex() returns,
     the actual input characters matched are available as a string named
     yytext, and the number of input symbols matched are in yyleng.  But is
     yytext a char * or an array of char?  Usually it doesn't matter in C,
     but <em>I personally have worked on a compiler where declaring an extern
     for yytext in my other modules, and using the wrong one, caused a crash.</em>
     Flex has both pointer and array implementations available via %array
     and %pointer declarations, so your compiler can use either.  YYLMAX
     is not a Flex thing, sorry, but how <em>can</em> we limit
     the length of identifiers?  Incidentally: I am astonished, to read
     claims that the Flex scanner buffer doesn't automatically increase
     in size as needed, and might be limited by default to 8K or so regexes.
     If you write open-ended regular expressions, but might be advisable
     in this day of big memory to say something like
<pre>
	i=stat(filename,&st);
	yyin=fopen(filename,"r");
	yy_current_buffer = yy_create_buffer(yyin, st.st_size);
</pre>
     to set flex so that it cannot experience buffer overrun. By the way,
     Be sure to
     check ALL your C library calls for error returns in this class!

<dt> The O'Reilly book recommended using Flex states instead of that big
     regular expression for C comments.  Is that reasonable?
<dd> You may implement the most elegant correct answer you can
     devise, not just what you see in class. If you use something from
     anywhere other than our course texts, you must cite it!
<dt> Are we free to explore non-optimal solutions?
<dd> I do not want to read lots of extra pages of junk code, but you are free
     to explore alternatives and submit the most elegant solution you come
     up with, regardless of its optimality. Note that there are some parts
     of the implementation that I might mandate. For example, the symbol table
     is best done as a hash table. You could use some other fancy data
     structure that you love, but if you give me a linked list I will be
     disappointed. Then again, a working linked list implementation would get
     more points than a failed complicated implementation.
<dt> Is it OK to allocate a token structure inside main() after yylex()
     returns the token?

<dd> No. In the next phase of your compiler, you will not call
<code>yylex()</code>, the Bison-generated parser will call
<code>yylex()</code>.  There is a way for
the parser to grab your token if you've stored it in a global variable,
but there is not a way for the parser to build the token structure itself.
However you <em>are</em> expected to allocate the linked list nodes in main(), and
in the next homework that linked list will be discarded. Don't get attached.

<dt> My tokens' "text" field in my linked list are all messed up when I go
     back through the list at the end. What do I do?
<dd> Remember to make a physical copy of <code>yytext</code> each token,
     because it overwrites itself each time it matches a regular expression
     in <code>yylex()</code>.  Typically a physical copy of a C string is
     made using <code>strdup()</code>, which is a <code>malloc()</code>
     followed by <code>strcpy()</code>.

<dt> C++ concatenates adjacent string literals, e.g. "Hello" " world"
Does our lexer need to do that?
<dd>
No, you do not have to do it.
But if you did, can you think of a way to get the job done without too
much pain?
It could be done in the lexer, in the parser, or sneakily in-between.
Be careful to consider 3+ adjacent string literals
("Hello" " world, " "how are you" and so on)
<dt> How do I handle escapes in svals? Do I need to worry about more than
\n \t \\ and \r?
<dd>
You replace the two-or-more characters with a single, encoded character.
'\\' followed by 'n' become a control-J character.  We need
\n \t \\ and \" -- these are ubiquitous.
You can do additional ones like \r but they are not required and
will not be tested.


<!--
<dt> Does HW#1 expect semi-colon insertion? It is not mentioned in the hw1
description but is in the spec.
<dd> We will need <A href="https://golang.org/ref/spec#Semicolons">semi-colon insertion</A> for HW#2 but it is not required for HW#1. Let's discuss.
-->

<!--
<dt> I was trying to come up with a regular expression for runes that are accep
<dd> The full Go literals spec is <A href="https://golang.org/ref/spec#Rune_literals">here</A>.
VGo rune literals are basically C/C++ char literals. A VGo lexical
analyzer might want to start with a regex for a char literal, and then
add regex'es for things that are legal Go and not legal VGo.  Here are
examples. There are also octal and hex escapes legal in Go but not in VGo.<br>

<table border>
<tr><th>Regex <th> Interpretation
<tr><td>
<code>"'"[^\\\n]"'"</code> <td> initial attempt at normal non-escaped runes
<tr><td>
<code>"'\\"[nt\\']"'"</code> <td> a few legal VGo escaped runes
<tr><td>
<code>"'\\"[abfrv]"'"</code> <td> legal in Go not in VGo escaped runes
<tr><td>
<code>"'\\u"[0-9a-fA-F]{4}"'"</code> <td> legal in Go not in VGo
<tr><td>
<code>"'\\U"[0-9a-fA-F]{8}"'"</code> <td> legal in Go not in VGo
</table>
-->

<dt> You mentioned that the next homework assignment, we won't be calling
<code>yylex()</code> from <code>main()</code> (which is why you previously
mentioned you cannot allocate the token structure in <code>main()</code>).
I have followed that rule,
but I question how will linked lists be set up in Homework #2 then?

<dd> In HW#2 the linked list will be subsumed (that is, replaced) by you
building a tree data
structure. If you built a linked list inside <code>yylex()</code>, that
would be a harmless waste of time and space and could be left in place.
If you malloc'ed the token structs inside <code>yylex()</code> but
built the linked list in your <code>main()</code>, your linked list
will just go away in HW#2 when we modify <code>main()</code> to call
the Bison parser function <code>yyparse()</code> instead of the loop
that repeatedly calls <code>yylex()</code>.

<dt> Can you test my scanner and see if I get an "A"?
<dd> No.
<dt> Can you post tests so I can see if my scanner gets an "A"?
<dd> If you share tests that you devise, for example
     when you have questions, I will add them to a public collection
     for use by the class.
<dt> So if I run OK on a few sample files, do I get an "A"?
<dd> Maybe.
     You should devise "coverage tests" to hit all described features.

<!--
<dt>
Each time a regular <em>user-written</em> include file is "handled",
we must stop the current yyin file (and save it), and open this new
file and assigning it yyin, and read from the user-defined include
file. Once we finish with the include file, do we have to go back
(somehow) to where yylex was reading from the original yyin?

<dd> Yes. Excellent question because it points out that
switching between files is more than just switching saving and restoring
the global FILE * yyin variable, which (if left open) would retain its
cursor position: flex seems to do its own layer of buffering in addition to
the buffering built-in to C stdio files.
Note that the sample clex.l file omits the saving and restoring of flex's
buffer state, and naively tries to just assign a new yyin and go on.
<p>

Section 11 of the flex manual provides the tools to correct and complete
(or replace entirely) the include mechanism started in clex.l.  Function
<code>yypush_buffer_state()</code>, or function
<code>yy_switch_to_buffer()</code>, allows for switching back (either by
popping, or switching again) after an include file is completed.

<dt>
From reading the Homework #1 page, I can't seem to understand how
you want <em>system includes</em> to be handled. I'm still not really sure
what you want the 120++ lexical anyalzyer to do for system includes,
could you provide some more info?
<dd>
I dismiss the notion of including g++'s real system includes, because they
are too large and liable to have non-standard extensions.
You have two options: 1) set a global boolean flag for each
system include, from the small set that are allowed in 120++. Use those
flags later in your compiler to hardwire "built-in" globals/functions
into your global symbol table.
OR 2) implement the system includes by having the system includes pull in
a set of tiny "120++ include files" that you write for your compiler. For
portability, these should be located either relative to your compiler's
binary location, or built-in such that your compiler can place them in
the current directory as temporary files during the compile.

<dt>
When displaying the token per line, does that mean once we encounter a
user-defined include, it should begin displaying token info for its tokens?

<dd> Yes, and then switch back to the main source file after the #include has
been processed.
-->

<dt>
Are we required to be using a lexical analysis error function lexerr()?
<dd>
<ul>
<li>
Whether you have a helper function with that particular name is up to you.
<li> You should report lexical errors in a manner that is helpful to the user.
Include line #, filename, and nature of the error if possible.
<li>Many lexical errors could consist of "token Y is not legal in language X".
<li>You are allowed to stop with an error exit status when you find an error.
</ul>

<dt>
The HW Specification says we are to use at least 2 separately compiled
.c files. Does Flex's generated lex.yy.c count as one of them,
or are you looking for yet another .c file, aside from lex.yy.c? 

<dd>
lex.yy.c counts. You may have more, but you should at least have a lex.yy.c
or other lex-compatible module, and a main function in a separate .c file

<dt> For numbers, should we care about their size? What if an integer in
the source file is greater than 2^64 ?
<dd> We could ask: what do production compilers do?  Or we could just say:
good catch, your compiler would ideally range check and emit an error
if a value that doesn't fit into 64-bits occurs, for either the integer
or (less likely) float64 literals.  Any ideas on how to detect an out
of range literal?

<dt> I was using valgrind to test memory leaks and saw that there is a
<code>leak-check=full</code> option.  Should I be testing that as well, or
just standard valgrind output with no options?

<dd> You are welcome to use valgrind's memory-leak-finding capabilities, but
you are only being graded on whether your compiler performs illegal reads or
writes, including reads from uninitialized memory.

</dl>

<!--

<h3> Flex Manpage Examplefest </h3>

To read a UNIX "man page", or manual page, you type "man <em>command</em>" 
where command is the UNIX program or library function you need information
on.  Read the man page for man to learn more advanced uses ("man man").
<p>

It turns out the flex man page is intended to be pretty complete, enough
so that we can draw some examples from it. Perhaps what you should figure
out from these examples is that flex is actually... flexible.  The first
several examples use flex as a filter from standard input to standard
output.


<UL>
<li> sneaky string removal tool:
<pre>
           %%
           "zap me"
</pre>
<li> excess whitespace trimmer
<pre>
           %%
           [ \t]+        putchar( ' ' );
           [ \t]+$       /* ignore this token */
</pre>
<li> sneaky string substitution tool:

<pre>
           %%
           username    printf( "%s", getlogin() );
</pre>
</ul>


<ul>
<li> Line Counter/Word Counter

<pre>
                   int num_lines = 0, num_chars = 0;

           %%
           \n      ++num_lines; ++num_chars;
           .       ++num_chars;

           %%
           main()
                   {
                   yylex();
                   printf( "# of lines = %d, # of chars = %d\n",
                           num_lines, num_chars );
                   }
</pre>
-->

<p>
<font size=1> <A name=7>lecture #7</A> began here</font>
<p>

<h3>Old Mailbag </h3>

<dl>
<dt> My C compiles say "implicit declaration of function"
<dd> The C compiler requires a prototype (or actual function definition)
     before it sees any <em>calls</em> to each function, in order to generate
     correct code. On 64-bit platforms, treat this warning as an error.

<!--
<dt> The 120++ manual's lexical section does not include short/long int
and double types as it does in section 1, from Dr. Soule's book. Are we not
including these?
<dd> We are including short/long reserved words, they are in the 120++ book.
Subject to semantics requirements of ANSI C++, we might simplify our code
generation and implement all sizes as the same
thing (say, a 64-bit integer).
-->

<dt> In reference to including system includes, should we just use a flag to
     note if these have been added?
<dd> You do not have to work out the details in this HW.
     By the semantic analysis phase, you will need a strategy for #include's.
     I recommend one flag for each supported system include.

<dt> For system includes, should we process functions in those libraries
     differently? Such as printf.
<dd> These items are processed normally in the lexical and syntax analysis
phases*.  When we do semantic analysis, we will need a strategy for
pre-initializing the symbol table based on include-flags. 
*predefined type names such as system-introduced typedef's may affect our
 syntax analysis.

<!-- 120++
<dt>
With the string library being included, do we not need to worry about char* types being present?
<dd> char * does appear in 120++. We will need to support basic pointer types.
More details will be needed in semantic analysis.  char  and * are two separate
tokens in your scanner of course.

<dt>
Do we need to include the referencing operator &amp;
<dd>
Yes.

<dt>
Is the distinction between and bitwise AND and referencing operation done by our grammar? 
<dd> Yes, the lexical analyzer just returns a token saying it saw an &amp;
and the syntax analyzer has to decide if that is used as a binary operator,
a unary modifer to a parameter, a unary address-of operator, etc.
-->

</dl>

<h3> Mailbag </h3>

<dl>
<dt>
Could we talk more about setting up and using Flex for Homework 2
<dd> Sure. Lab today should give you practice doing this yourself,
     but let's walk through an example.

</dl>


<h3> <A href="toy.l">Toy compiler example</A> adapted from the Flex Manpage </h3>

<ul>
<li> What does this example have that you might use in your HW#2?
<li> What does HW#2 require that needs to be different?
</ul>

<p>

<pre>
           /* scanner for a toy Pascal-like language */

           %{
           #include &lt;stdio.h&gt;
           /* need this for the call to atof() below */
           #include &lt;math.h&gt;
           %}

           DIGIT    [0-9]
           ID       [a-z][a-z0-9]*

           %%

           {DIGIT}+    {
                       printf( "An integer: %s (%d)\n", yytext,
                               atoi( yytext ) );
                       }

           {DIGIT}+"."{DIGIT}*        {
                       printf( "A float: %s (%g)\n", yytext,
                               atof( yytext ) );
                       }

           if|then|begin|end|procedure|function        {
                       printf( "A keyword: %s\n", yytext );
                       }

           {ID}        { printf( "An identifier: %s\n", yytext ); }

           "+"|"-"|"*"|"/"   { printf( "An operator: %s\n", yytext ); }

           "{"[^}\n]*"}"     {  /* eat up one-line comments */ }

           [ \t\n]+          { /* eat up whitespace */ }

           .         {  printf( "Unrecognized character: %s\n", yytext ); }

           %%

           int main(int argc, char **argv )
               {
               ++argv, --argc;  /* skip over program name */
               if ( argc &gt; 0 )
                       yyin = fopen( argv[0], "r" );
               else
                       yyin = stdin;

               yylex();
               }
</pre>



<h3> Using character sets (square brackets) in Flex </h3>

A student once sent me an example regular expression for comments that read:
<pre>
   COMMENT [/*][[^*/]*[*]*]]*[*/]
</pre>
One problem here is that square brackets are not parentheses, they do not nest,
they do not support concatenation or other regular expression operators. They
mean exactly: "match any one of these characters" or for ^: "match any one
character that is not one of these characters".  Note also that you
<em>can't</em> use ^ as a "not" operator outside of square brackets: you
can't write the expression for "stuff that isn't */" by saying (^ "*/")

<!--
<A name=finiteautomata>
<h3> Finite Automata </h3>
</A>

Efficiency in lexical analyzers based on regular expressions is all about
how to best implement those wonders of CS Theory: the finite automata. Today
we briefly review some highlights from theory of computation with an eye
towards implementation.

<p>

A finite automaton (FA) is an abstract, mathematical machine, also known as a
finite state machine, with the following components:

<ol>
<li> A set of states S
<li> A set of input symbols E (the alphabet)
<li> A transition function move(state, symbol) : new state(s)
<li> A start state S0
<li> A set of final states F
</ol>
-->

<h3> Implementing Finite Automata </h3>

<ul>
<li> We aren't going to study Flex's implementation in detail; I am sure
     you could have a lot of fun with that.
<li> The word <em>finite</em> refers to the set of states: there is a fixed
     size to this machine.  No "stacks", no "virtual memory", just a known
     number of states.
<li> The word <em>automaton</em> refers to the execution mode: there is
     no brain, not so much as a instruction set and sequence of instructions.
</ul>

<h4> dfa v1 </H4>

The basic logic is almost a hardwired short loop like this:

<pre>
   while ((c=getchar()) != EOF) S := move(S, c);
</pre>

The move() function, which handles transitions from state to state,
might be some kind of table (2D array) lookup.
What this "finite automaton algorithm" lacks in flexibility,
it makes up in speed. 

<h4> dfa v2 </H4>

In real-life, there are some side effects
or semantic action code associated with certain states,
or it is not very useful.

<pre>
   while ((c=getchar()) != EOF) { S := move(S, c); switch(S) { ... } }
</pre>

<p>

To go faster than this, you can stop representing the current
state in some variable S, and instead make the state an implicit property of
the instruction/program counter register.


<h3> DFAs </h3>

The type of finite automata that is easiest to understand and simplest to
implement <!--(maybe even in hardware)--> is called a deterministic finite
automaton (DFA).  The word <em>deterministic</em> here refers to the return
value of
function move(state, symbol), which goes to at most one state.

Example:
<p>
<pre>
S = {s0, s1, s2}
E = {a, b, c}
move = { (s0,a):s1; (s1,b):s2; (s2,c):s2 }
S0 = s0
F = {s2}
</pre>
<p>

Finite automata correspond in a 1:1 relationship to transition diagrams;
from any transition diagram one can write down the formal automaton in
terms of items #1-#5 above, and vice versa.  To draw the transition diagram
for a finite automaton:
<ul>
<li> draw a circle for each state s in S; put a label inside the circles
     to identify each state by number or name
<li> draw an arrow between S<sub>i</sub> and S<sub>j</sub>, labeled with x
     whenever the transition says to move(S<sub>i</sub>, x) : S<sub>j</sub>
<li> draw a "wedgie" into the start state S0 to identify it
<li> draw a second circle inside each of the final states in F
</ul>

<h3> The Automaton Game </h3>

If I give you a transition diagram of a finite automaton, you can hand-simulate
the operation of that automaton on any input I give you.


<h4> DFA Implementation </h4>

The nice part about DFA's is that they are efficiently implemented
on computers.  What DFA does the following code correspond to?  What
is the corresponding regular expression?  You can speed this code
fragment up even further if you are willing to use goto's or write
it in assembler.

<pre>
state := S0
for(;;)
   switch (state) {
   case 0: 
      switch (input) {
         'a': state = 1; input = getchar(); break;
         'b': input = getchar(); break;
	 default: printf("dfa error\n"); exit(1);
         }
   case 1: 
      switch (input) {
         EOF: printf("accept\n"); exit(0);
	 default: printf("dfa error\n"); exit(1);
         }
      }
</pre>

Flex has extra complications. It accepts multiple regular expressions, runs
them all in parallel in one big DFA, and adds semantics to break ties. These
extra complications might be viewed as "breaking" the strict rules of DFA's,
but they don't really mess up the fast DFA implementation.


<p>
<font size=1> <A name=8>lecture #8</A> began here</font>
<p>
<h4> Deterministic Finite Automata Examples </h4>

A lexical analyzer might associate different final states with different
token categories. In this fragment, the final states are marked by
"return" statements that say what category to return. What is incomplete
or wrong here?
<p>


<img src="dfacat.png">
<p>


C Comments:<p>
<img src="dfa-ccom.png">
<p>



<h3> C Comments Redux </h3>

<ul>
<li>
It takes less than 5 minutes to find a solution on the internet, but many
of them are in fact suboptimal.
<li> A FA might or might not give solution hints for the corresponding regex.
<li> Here is an internet solution, cleaned up:

<pre>
"/*"([^*]|"*"+[^/*])*"*"+"/"
</pre>
<li> Think hard about it. Does it have any bugs?
</ul>


<h4> Nondeterministic Finite Automata (NFA's)</h4>

Notational convenience motivates more flexible machines in which function
move() can go to more than one state on a given input symbol, and some
states can move to other states even without consuming an input symbol
(&epsilon;-transitions).
<p>

Fortunately, one can prove that for any NFA, there is an equivalent DFA.
They are just a notational convenience. So, finite automata help us get
from a set of regular expressions to a computer program that recognizes
them efficiently.

<h4> NFA Examples </h4>

&epsilon;-transitions make it simpler to merge automata:<p>
<img src="fa-eps.gif">
<p>

multiple transitions on the same symbol handle common prefixes:<p>
<img src="fa-less.gif">
<p>

factoring may optimize the number of states.  Is this picture OK/correct?<p>
<img src="fa-less2.gif">
<p>


<h4> C Pointers, malloc, and your future </h4>

For many of you success as a computer scientist may boil down to what it
will take for you to master the concept of dynamically allocated memory,
and whether you are willing to do that.  In C this means pointers and the
<code>malloc()</code> family of functions.  Here are some tips:

<ul>
<li> Draw "memory box" pictures of your variables.  Pencil and paper
     understanding of memory leads to correct running programs.
<li> Always initialize local pointer variables.  Consider this code:
<pre>
void f() {
   int i = 0;
   struct tokenlist *current, *head;
   ...
   foo(current)
}
</pre>

Here, <code>current</code> is passed in as a parameter to foo, but it is a
pointer that hasn't been pointed at anything. I cannot tell you how many
times I personally have written bugs myself or fixed bugs in student code,
caused by reading or writing to pointers that weren't pointing at anything
in particular.  Local variables that weren't initialized point at random
garbage. If you are lucky this is a coredump, but you might not be lucky,
you might not find out where the mistake was, you might just get a wrong answer.
This can all be fixed by

<pre>
   struct tokenlist *current = NULL, *head = NULL;
</pre>

<LI> Avoid this common C bug:
<pre>
struct token *t = (struct token *)malloc(sizeof(struct token *)));
</pre>
This compiles, but causes coredumps during program execution.  Why?

<li> Check your <code>malloc()</code> return value to be sure it is not
NULL.  Sure, modern programs have big memories so you think they will "never
run out of memory".  Wrong. <code>malloc()</code> can return NULL even on
big machines.  Operating systems often place limits on memory far beneath
the hardware capabilities.  wormulon (or cs-course42) is likely a conspicuous
example. Machine shared across 40 users?  You may have a lower memory
limit than you think.

</ul>


<h4> NFA examples - from regular expressions </h4>

Can you draw an NFA corresponding to the following?

<pre>
(a|c)*b(a|c)*

(a|c)*|(a|c)*b(a|c)*

(a|c)*(b|&epsilon;)(a|c)*
</pre>




<h3> Regular expressions can be converted automatically to NFA's </h3>

Each rule in the definition of regular expressions has a corresponding
NFA; NFA's are <i>composed</i> using &epsilon; transitions.  This is called
"Thompson's construction" <!--(Louden pg. 64, ASU Algorithm 3.3-->).
We will work
examples such as (a|b)*abb in class and during lab.

<ol>
<li> For &epsilon;, draw two states with a single &epsilon; transition.
     <br><img src="fa-th2.gif">
<li> For any letter in the alphabet, 
     draw two states with a single transition labeled with that letter.
     <br><img src="fa-th1.gif">
<li> For regular expressions r and s, draw r | s
     by adding a new start state with &epsilon; transitions to the start
     states of r and s, and a new final state with &epsilon; transitions
     from each final state in r and s.
     <br><img src="fa-th4.gif">
<li> For regular expressions r and s, draw rs
     by adding &epsilon; transitions from the final states of r to the
     start state of s.
     <br><img src="fa-th3.gif">
<li> For regular expression r, draw r*
     by adding new start and final states, and &epsilon; transitions
<ul>
	<li> from the start state to the final state,
	<li> from the final  state back to the start state,
	<li> from the new start to the old start and from the old final
            states to the new final state.
</ul>
     <br><img src="fa-th5.gif">
<li> For parenthesized regular expression (r) you can use the NFA for r.
</ol>


<p>
<font size=1> <A name=9>lecture #9</A> began here</font>
<p>



<h3> Mailbag </h3>

<dl>
<dt> Go has four different kinds of literal constants, but for HW#2,
     the grammar one thing, LLITERAL, what up?
<dd> You are correct. If you return four different codes for four different
     types of literals, you have to modify the grammar to replace LLLITERAL
     with a grammar rule that allows your four integer codes. Alternatively,
     you can have your four (or more) different flex regular expressions for
     different kinds of literal constants, all return the LLITERAL integer.
<dt> How do I deal with semi-colons?
<dd> For HW#1, hopefully you just added an integer token category for them,
     and returned that integer if you
     saw one, even though explicit semi-colons are infrequent
     in source code.  For HW#2 your options are to write a grammar
     that doesn't need semi-colons and works anyhow, or write a grammar that
     needs semi-colons, and perform semi-colon insertion.

<!--
<dt> I'm trying to understand the <code>d</code> operator.
     What about the following:
<pre>
  d20
  d 20
  d x
  d(x)
  5d16
  5d 16
  5 d16
  5 d 16
  x d16
  x d 16
  (x)d16
  (x)d 16
  5d x
  5 d x
  5d(x)
  5 d(x)
  x d y
  (x) d y
  x d (y)
  (x)d(y)
</pre>
<dd>
Thank you for really pushing the question: what is the d operator.
The intention is indeed that everything that makes sense shall work.
Almost ALL of the patterns listed here come about naturally from adding
a "d" operator in the context free grammar in HW#2. The only things you
have to worry about for HW#1 is what letters belong to how many tokens
in what token categories.  For example, is d20 one token, or two?  It
matches the regex for variable names, but we need it to be two tokens.
Can we do that with flex regular expressions' lookahead operator, or are
we going to have to special-case it as one complex token and have
special treatment for it in the grammar?
-->

<!--
<dt>I'm still not super clear what should happen with system includes.
They will eventually be stored in a symbol table for Bison. The symbol 
table should be a hash table. But what is being stored there?
Should I look up every variable and function name in the 6 libraries 
mentioned by 120++, and manually add them all to the symbol table?

<dd> By Homework #2, we will have to know what identifiers are the names
of types (classes) in order to return the correct category for them.
By homework #3 we will want to store type information for these system
functions and parameters and such, and be able to check calls for validity.
-->
<!--
<dt>
120++ mentions "built-in" classes or functions -- <<, >>, cout, 
cin, string, ifstream, etc. What does that mean in terms of the lexer?
<dd> The lexer should include operators (separate integer categories/codes)
     for all C++ operators.  The lexer should treat built-ins that are not
     reserved words as identifiers.  We will need to revisit this topic
     next assignment.
-->

<!--
<dt> I was curious if character literals (i.e. 'a' or 'b') need to be stored as an ival or maybe sval?

<dd> Yes. Easiest would be to treat them similar to a string and store an
sval that is only one character long.
-->

<!--
<dt> Are we supposed to distinguish between pointers and multiplication for our scanner? They use the same symbol, but are we supposed to know when it's considered a pointer and when it's considered multiplication?

<dd> No. The lexical analyzer doesn't know the surrounding syntax context
that would say what the token is used for, it just knows it sees a *
-->

<dt>What do you mean, for ival/dval/sval, by telling us to
    "store binary value here"
<dd>A binary value is the actual native representation that corresponds to
the string of ASCII codes that is the lexeme, for example what you get when
you call atoi("1234") for the token "1234".

<dt> I am getting a lot of "unrecognized rule" errors in my .l file
<dd> Look for problems with regular expressions or semantic actions prior to
     the first reported error.  If you need better diagnosis, find a way to
     show me your code. One student saw these errors because they omitted
     the required space between their regular expressions and their C semantic
     actions.

<dt> Do you have any cool tips to share regarding the un-escaping of special
characters?
<dd> Copy character-by-character from the yytext into
a newly allocated array. Every escape sequence of multiple characters in yytext
represents a single character in
sval. Inside your loop copying characters from yytext into sval,
if you see a backslash in yytext, skip it and use a switch statement
on the next character.  See below for additional discussion.

<!--
<dt>
C++14 supports binary by using "0b"
<dd>
OK, that means you should write a regular expression for it, allow it on input,
and print an error message if you encounter it.
-->

<dt>
How can we represent and print out the binary value in ival and dval?
Wouldn't both ival and dval need to be char arrays types to actually display
a "binary representation"?

<dd>
You do NOT have to convert to a binary string representation or output anything
in 0b010101010000 format.

<!--
<dt>
The 120++ manual mentions "_123 is not a legal variable name (does not contain a letter), while the C/C++ languages allow it (underscore is considered to be a letter). The ideal treatment in 120++ would be to issue a warning (at most once).". So, should I follow that rule?
<dd>
Things in C++ that are not in 120++ are allowed to print an error
and exit.
-->

<dt>
Is a function name also an identifier?
<dd>
Yes.
</dl>

<h3> <A href="https://golang.org/ref/spec#Semicolons">Semi-Colon Insertion</A>
     in Go </h3>

The Go designers probably had good reason to include semi-colons in the Go
grammar, to facilitate parsing, but they didn't want code to require them
99% of the time, so they introduced semi-colon insertion, an idea that they
borrowed from other languages.
<p>

<ol>
<li> At a newline, semi-colon is inserted if the last token was
<ul>
<li> identifier
<li> literal (number, rune, or string)
<li> break, continue, fallthrough, or return
<li> ++ -- ) ] or }
</ul>

<li> "a semi-colon may be omitted before a closing ) or }"
</ol>

What does (2) even mean?  Automatic ; insertion before every ) or }?
Or just that the grammar handles an optional semi-colon in those spots?

<h3> Ways to Implement Semi-colon Insertion </h3>

<dl>
<dt> preprocessor
<dd> you could write a pre-pass that does nothing but semi-colon insertion
<dt> layered in between yylex() and yyparse()
<dd> you could rename the yylex() generated by flex to be yylex2(), and
     write a new yylex() that returns a semi-colon if conditions are right,
     and otherwise just calls yylex2(). You'd have to have some global or
     static memory for (1) what was the last token and (2) whether we saw
     a newline
<dt> within the regular expression for newline?
<dd> not quite general enough, but you could return a semi-colon integer
     when you see a newline whose previous token met the conditions
<dt> layered inside yylex's C semantic actions
<dd> a student figured out that one can do semi-colon insertion inside
     a helper function called from each flex semantic action. The function,
     if it substitutes a semi-colon for what is normally returned, has to
     save/remember what it was going to return, and return it later. The
     trick here is: if you inserted a semi-colon and saved your found token,
     you return the saved token after you have scanned your <em>next</em>
     token. In that case, you need to save <em>that</em>token somehow;
     one way is to tell flex to back up via yyless(0).
</dl>


<!--
<h3> Semi-Colon Insertion in Unicon </h3>

<ol>
<li> Categorize for each token: is it a legal Beginner?
<li> Categorize for each token: is it a legal Ender?
<li> Remember previous token's Ender status, update each call to yylex()
<li> Set a flag every newline to mark the next token First_on_a_line;
     update each call to yylex()
<li> Algorithm for new yylex():
<pre> 
   IF we saved last token and returned Semi-Colon last time THEN
      return saved token
   ELSE {
      call old yylex()
      IF First_on_a_line AND Beginner AND last.Ender THEN {
          save_token; return Semi-Colon
          }
      ELSE return token
      }
</pre>
</ol>
-->


<h3> NFA's can be converted automatically to DFA's </h3>

In: NFA N<br>
Out: DFA D<br>
Method: Construct transition table Dtran (a.k.a. the "move function").
Each DFA state is a set of
NFA states. Dtran simulates in parallel all possible moves N can make
on a given string.
<p>

Operations to keep track of sets of NFA states:
<p>
<dl>
<dt>&epsilon;_closure(s)</dt>
<dd> set of states reachable from state s via &epsilon;</dd>
<dt>&epsilon;_closure(T)</dt>
<dd> set of states reachable from any state in set T via &epsilon;</dd>
<dt>move(T,a)</dt>
<dd> set of states to which there is an NFA transition from states in T on symbol a</dd>
</dl>
<p>

NFA to DFA Algorithm:
<p>
<pre>
Dstates := {&epsilon;_closure(start_state)}
while T := unmarked_member(Dstates) do {
	mark(T)
	for each input symbol a do {
		U := &epsilon;_closure(move(T,a))
		if not member(Dstates, U) then
			insert(Dstates, U)
		Dtran[T,a] := U
	}
}
</pre>



<h3> HW #1 Tips </h3>

These comments are based on historical solutions. I learned a lot from my
older siblings when I was young. Consider this your opportunity to learn
from your Vandal forebears' mistakes.

<dl>
<dt> better solutions' lexer actions looked like
<pre>
...regex...      { return token(TERMSYM); }
</pre>
<dd>
     where token() allocates a token structure, sets a global variable to
     point to it, and returns the same integer category that it is passed
     from yylex(), so yylex() in turn returns this value.
<dt> Put in enough line breaks.
<dd>
     Use &lt;= 80 columns in your code, so that it prints readably.
<dt> Comment non-trivial helper functions.  Comment non-trivial code.
<dd> Comment appropriate for a CS professional reader, not a newbie tutorial.
     I know what i++ does, you do not have to tell me.
<dt> Do not leave in commented-out debugging code or whatever.
<dd> I might miss, and misgrade, your good output if I can't see it.
<!--
<li> Does lexer know about C++ library things like cin?  Can it report good
     errors for those if the required system include file was not included?
     (Generally: no, it can't).
-->
<dt> Fancier formatting might calculate field widths from actual data
     and use a variable to specify field widths in the printf.
<dd> You don't
     have to do this, but if you want to it is not that hard.
<dt> Remind yourself of the difference between NULL and '\0' and 0
<dd> NULL is used for pointers. The NUL byte '\0' terminates strings. 0
     is a different size from NULL on many 64-bit compilers. Beware.
<dt> Avoid O(n<sup>2</sup>) or worse, if at all possible
<dd> It is possible to write bad algorithms that work, but it is better
     to write good algorithms that work.
<dt> Avoid big quantities of duplicate code
<dd> You will have to use and possibly extend this code all semester.
<dt> Use a switch when appropriate instead of long chain of if-statements
<dd> Long chains of if statements are actually slow and less readable.
<dt> On strings, allocate one byte extra for NUL.
<dd> This common problem causes valgrind trouble, memory violations etc.
<dt>  On all pointers, don't allocate and then just point the pointer
      someplace else
<dd> This common student error results in, at least, a memory leak.
<dt> Don't allocate the same thing over and over unless copies may need
     to be modified.
<dd> This is often a performance problem.
<dt> Check all allocations and fopen() calls for NULL return (good to have helper functions).
<dd> C library functions can fail.  Expect and check for that.

<dt> Beware losing the base pointer that you allocated.
<dd> You can only free()
     if you still know where the start of what you allocated was.
<dt> Avoid duplicate calls to strlen()
<dd> especially in a loop! (Its O(n<sup>2</sup>))
<dt> Use strcpy() instead of strncpy()
<dd> unless you are really copying only part of a string, or
     copying a string into a limited-length buffer.

<dt> You can't <code>malloc()</code> in a global initializer
<dd> <code>malloc()</code> is a runtime allocation from a memory
     region that does not
     exist at compile or link time. Globals can be initialized, but not to
     point at memory regions that do not exist until runtime.
<dt> Don't use raw constants like 260
<dd> use symbolic names, like LEFTPARENTHESIS or LP
<dt> The vertical bar (|) means nothing inside square brackets!
<dd> Square brackets are an implicit shortcut for a whole lot of ORs
<dt> If you don't allocate your token inside yylex() actions...
<dd> You'll have to go back and do it, you need it for HW#2.
<dt> If your regex's were broken
<dd> If you know it, and were lazy, then fix it.  If you don't know it,
     then good luck on the midterm and/or final, you need to learn these,
     and devise some (hard) tests!
</dl>



<h3> On resizing arrays in C </h3>

The sval attribute in the homework is a perfect example of a problem which a
Business (MIS) major might not be expected to solve well, but a CS major
should be able to do by the time they graduate.  This is not to encourage
any of you to consider MIS, but rather, to encourage you to learn how to
solve problems like these.

<p>

The problem can be summarized as: step through yytext, copying each character
out to sval, <!--removing doublequotes and plusses between the pieces, and
evaluating CHR$() constants. -- this was for BASIC -->
looking for escape sequences.

<P>

Space allocated with malloc() can be increased in size by realloc().
realloc() is awesome.  But, it COPIES and MOVES the old chunk of
space you had to the new, resized chunk of space, and frees the old
space, so you had better not have any other pointers pointing at
that space if you realloc(), and you have to update your pointer to
point at the new location realloc() returns.

<!--
<pre>
i = 0; j = 0;
while (yytext[i] != '\0') {
   if (yytext[i] == '\"') {
      /* copy string into sval */
      i++;
      while (yytext[i] != '\"') {
         sval[j++] = yytext[i++];
         }
      }
   else if ((yytext[i] == 'C') || (yytext[i] == 'c')) {
      /* handle CHR$(...) */
      i += 5;
      k = atoi(yytext + i);
      sval[j++] = k;           /* might check for 0-255 */
      while (yytext[i] != ')') i++;
      }
   /* else we can just skip it */
   i++;
}
sval[j] = '\0'; /* NUL-terminate our string */
</pre>
-->
<p>

There is one more problem: how do we allocate memory for sval, and how big
should it be?

<ul>
<li> Solution #1: sval = malloc(strlen(yytext)+1) is very safe, but wastes
     space.
<li> Solution #2: you could malloc a small amount and grow the array as
     needed.
<pre>
sval = strdup("");
...
sval = appendstring(sval, yytext[i]); /* instead of sval[j++] = yytext[i] */
</pre>
where the function appendstring could be:
<pre>
char *appendstring(char *s, char c)
{
    i = strlen(s);
    s = realloc(s, i+2);
    s[i] = c;
    s[i+1] = '\0';
    return s;
}
</pre>
Note: it is very inefficient to grow your array one character at
a time; in real life people grow arrays in large chunks at a time.

<li> Solution #3: use solution one and then shrink your array when you
find out how big it actually needs to be.
<pre>
sval = malloc(strlen(yytext)+1);
/* ... do the code copying into sval; be sure to NUL-terminate */
sval = realloc(sval, strlen(sval)+1);
</pre>
</ul>


<h3> Practice converting NFA to DFA </h3>

OK, you've seen the algorithm, now can you use it?<p>
<img src="nfadfa.gif">
<p>
...
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
...did you get:<p>
<img src="nfadfa2.gif">
<p>
<br>
<br>
<br>
<br>
OK, how about this one: <p>
<img src="nfadfa3.gif">
<p>



<h3> Look at <A href="hw2.html">HW#2</A> </h3>

<!--
<h2> Some Remarks (BASIC)</h2>

<ul>
<li> Color BASIC has two-letter identifiers.  We are doing Extended Color
     BASIC, so we will allow longer identifier names.  But in the current
     assignment #2 you will only be tested on short variable names.
<li> Whether we return the same or a different category for integer constants
     and for line numbers depends very much on the grammar we use to parse
     our language,
     and whether it can understand what's going on with the
     line numbers if it doesn't have two categories.  My instinct tells me
     we will probably need either a token for newline characters or will
     need to detect line numbers as distinct from normal integer constants.
     Before we can answer that question, we need to learn about syntax!
</ul>
-->

<!--
<h3> Lexical Analysis and the Literal Table </h3>

In many compilers, the memory management components of the compiler interact
with several phases of compilation, starting with lexical analysis.

<p>

<ul>
<li> Efficient storage is necessary to handle large input files.
<li> There is a colossal amount of duplication in lexical data:
     variable names, strings and other literal values duplicate frequently
<li> What token type to use may depend on previous declarations.
</ul>
<p>
A hash table or other efficient data structure can avoid this duplication.
The software engineering design pattern to use is called the "flyweight".


<h3> Literal Table: Usage Example </h3>

Example abbreviated from [ASU86]: Figure 3.18, p. 109.  Use "install_id()"
instead of "strdup()" to avoid duplication in the lexical data.

<pre>
%{
/* #define's for token categories LT, LE, etc.
%}

digit   [0-9]
id	[a-zA-Z_][a-zA-Z_0-9]*
num     {digit}+(\.{digit}+)?

%%

[ \t\n]+ { /* discard */ }
if	 { return IF; }
then	 { return THEN; }
else	 { return ELSE; }
{id}	 { yylval.id = install_id(); return ID; }
{num}    { yylval.num = install_num(); return NUMBER; }
"&lt;"	 { yylval.op = LT; return RELOP; }
"&gt;"	 { yylval.op = GT; return RELOP; }

%%

install_id()
{
   /* insert yytext into the literal table */
}

install_num()
{
   /* insert (binary number corresponding to?) yytext into the literal table */
}
</pre>

So how would you implement a literal table using a hash table?  We will see
more hash tables when it comes time to construct the symbol tables with which
variable names and scopes are managed, so you had better become fluent.


<h3> Major Data Structures in a Compiler </h3>

<dl>
<dt> token
<dd> contains an integer category, lexeme, line #, column #, filename...
     We could build these into a link list, but instead we'll use them
     as leaves in a tree structure.
<dt> syntax tree
<dd> contains grammar information about a sequence of related tokens.
     leaves contain lexical information (tokens).  internal nodes
     contain grammar rules and pointers to tokens or other tree nodes.
<dt> symbol table
<dd> contains variable names, types, and information needed to generate
     code for a name (such as its address, or constant value).  Look ups
     are by name, so we'll need a hash table.
<dt> intermediate &amp; final code
<dd> We'll need link lists or similar structures to hold sequences of machine
     instructions
</dl>


<h4> Quick Note on things to look for in HW </h4>

<ul>
<li> Adding reserved words is trivial. But clex.l was for C, and we
     need some of the C++ reserved words for 120++.
<li> Also look for: any new data types (besides bool) and their new
     types of literal constants?
     New literals require new nontrivial regular expressions in your
     lex file.
<li> If there are bugs in the clex.l file you were given, the
ones we would be most likely to care about are bugs in the regular expressions
for literal constants.  This calls for close scrutiny and painstaking attention
to detail...
</ul>

-->

<p>
<font size=1> <A name=10>lecture #10</A> began here</font>
<p>




<A name="syntax"><h2> Syntax Analysis </h2></A>

<em>Parsing</em> is the act of performing syntax analysis to verify an input
program's compliance with the source language.  A by-product of this process
is typically a tree that represents the structure of the program.


<h3> Context Free Grammars </h3>

A context free grammar G has:

<ul>
<li> A set of terminal symbols, T
<li> A set of nonterminal symbols, N
<li> A start symbol, s, which is a member of N
<li> A set of production rules of the form A -> &omega;,
     where A is a nonterminal and &omega; is a string of terminal and 
     nonterminal symbols.
</ul>

A context free grammar can be used to <em>generate</em> strings in the
corresponding language as follows:
<pre>let X = the start symbol s
while there is some nonterminal Y in X do
   apply any one production rule using Y, e.g. Y -> &omega;
</pre>
When X consists only of terminal symbols, it is a string of the language
denoted by the grammar.  Each iteration of the loop is a
<em>derivation step</em>.  If an iteration has several nonterminals
to choose from at some point, the rules of derviation would allow any of these
to be applied.  In practice, parsing algorithms tend to always choose the
leftmost nonterminal, or the rightmost nonterminal, resulting in strings
that are <em>leftmost derivations</em> or <em>rightmost derivations</em>.

<h3> Context Free Grammar Examples </h3>

Well, OK, so how much of the <!--BASIC--> C language grammar can we come up
with in class today?  Start with expressions, work on up to statements, and
work there up to entire functions, and programs.


<h3> Context Free Grammar Example (from BASIC) </h3>

How many terminals and non-terminals does the grammar below use?
Compared to the little grammar we started last time, how does this rate?
What parts make sense, and what parts seem bogus?

<pre>
Program : Lines
Lines   : Lines Line
Lines   : Line
Line    : INTEGER StatementList
StatementList : Statement COLON StatementList
StatementList : Statement
Statement: AssignmentStatement
Statement: IfStatement
<em> REMark: ... BASIC has many other statement types </em>

AssignmentStatement : Variable ASSIGN Expression
Variable : IDENTIFIER
<em> REMark: ... BASIC has at least one more Variable type: arrays </em>

IfStatement: IF BooleanExpression THEN Statement
IfStatement: IF BooleanExpression THEN Statement ELSE Statement

Expression: Expression PLUS Term
Expression: Term
Term      : Term TIMES Factor
Term      : Factor
Factor    : IDENTIFIER
Factor    : LEFTPAREN Expression RIGHTPAREN
<em> REMark: ... BASIC has more expressions </em>
</pre>



<!--
<h3> A brief aside on casting your mallocs </h3>

<li> If you don't put a prototype for malloc(), C thinks it returns an int.
<pre>
#include &lt;stdlib.h&gt;
</pre>
includes prototypes for malloc(), free(), etc.  malloc() returns a void *.
<br><br>

<li> void * means "pointer that points at nothing", or "pointer that points
     at anything".  You need to cast it to what you are really pointing at,
     as in:
<pre>
union lexval *l = (union lexval *)malloc(sizeof(union lexval));
</pre>
Note the stupid duplication of type information; no language is perfect!
Anyhow, always cast your mallocs.  The program may work without the cast,
but you need to fix every warning, so you don't accidentally let a serious
one through.<br><br>
-->

<h3>Mailbag</h3>

Really, I want to <em>thank</em> all of you who are sending me juicy questions
by e-mail.

<dl>
<dt> I am trying to get a more basic picture of the communication that happens between Flex and Bison. From my understanding:

<ol>
<li>main() calls yyparse()
<li>yyparse() calls yylex()
<li>yylex() returns tokens from the input as integer values which are enumerated to text for readability to the .y file
<li> yyparse() tries to match these integers against rules of our grammar
<br>
(if it unsuccessful it errors (shift/reduce, reduce/reduce, unable to parse))
</ol>
Is this correct?
<dd>1-3 are correct. 3 also includes: yylex() sets a global variable so that
yyparse() can pickup the lexical attributes, e.g. a pointer to struct token.
4 is correct except that shift/reduce and reduce/reduce conflicts are found
at bison time, not at yyparse() runtime.  But yes yyparse() can find syntax
errors and we have to report them meaningfully.

<dt> Does <code>yylval</code> have any use to us? In CS 210 we did a 
calculator and it was used to bring the value of the token into the parser.
<dd> Yes, <code>yylval</code> is how yyparse() picks up lexical attributes.
     We will talk about it more in class.

<dt>How would we add artificial tokens, like the semi-colon, without skipping
real tokens when we return?
<dd> Save the real, found token in a global or static, or figure out a way to
push it back onto the input stream.  Easiest is a one-token saved (pointer to
a) token struct.

<dt> Since we are adding semi-colons without knowledge
of the grammar how do we avoid simply putting a semi-colon at the end of
every line? Is there a set group of tokens that can't add semi-colons?
<dd> You make an interesting point that one could maybe do semi-colon
insertion with guidance from the parser, but it is intended that it be
done in the way described previously in class: classify every token as
to whether it is a legal statement-beginner, and whether it is a legal
statement-ender.  Insert semi-colons at newlines between an ender and
a beginner.  Example classification (via an array of booleans or whatever):

<table border>
<tr><th>token<th>Beginner?<th>Ender?
<tr><td>  x  <td> yes <td> yes
<tr><td>  1  <td> no?  <td> yes
<tr><td>  if <td> yes <td> no
<tr><td>  (  <td> yes <td> no
<tr><td>  )  <td> no <td> yes
<tr><td>  +  <td> no? <td> no
<tr><td>  -  <td> no? <td> no
</table>

<dt> How can I make Bison use a different yylex in order to allow for
     semi-colon insertion?
<dd> Two possibilities come to mind:
<ol>
<li> Modify output of bison to replace the call to yylex() with myyylex(),
<li> Modify output of flex to change its declaration of yylex to realyylex()
</ol>
     A traditional Linux tool for sneaky stuff like this is
     <code>sed(1)</code>, which could be invoked from your makefile.


<dt> Does VGo support both statements with semi-colons and statements without
semi-colons?
<dd> Go does.  VGo probably should, but if you figured out a way to hack
     the grammar to not use semi-colons and still recognize all of VGo,
     it would be pretty OK to only support statements without semicolons.

<dt>Does VGo support empty statements?
<dd> Most C-based grammars allow these.  Occasionally I find them handy.
I would say they are optional for your compiler.

</dl>

<h3> Grammar Ambiguity </h3>

The grammar

<pre>
E -> E + E
E -> E * E
E -> ( E )
E -> ident
</pre>

allows two different derivations for strings such as "x + y * z".
The grammar is ambiguous, but the semantics of the language dictate
a particular operator precedence that should be used.  One way to
eliminate such ambiguity is to rewrite the grammar. For example,
we can force the precedence we want by adding some nonterminals and
production rules.

<pre>
E -> E + T
E -> T
T -> T * F
T -> F
F -> ( E )
F -> ident
</pre>

Given the arithmetic expression grammar from last lecture:
<p>

How can a program figure that x + y * z is legal?<br>
How can a program figure out that x + y (* z) is illegal?
<p>



<A name=yacc>
<h3> YACC </h3>
</A>

YACC ("yet another compiler compiler") is a popular tool which originated at
AT&T Bell Labs.  YACC takes a context free grammar as input, and generates a
parser as output.  Several independent, compatible implementations (AT&amp;T
yacc, Berkeley yacc, GNU Bison) for C exist, as well as many implementations
for other popular languages. There also exist other more "modern" parser
generators, but they are often less portable and are
heavily inspired/influenced by YACC so it is what we will study. <p>

YACC files end in .y and take the form
<pre>
declarations
%%
grammar
%%
subroutines
</pre>
The declarations section defines the terminal symbols (tokens) and
nonterminal symbols. The most useful declarations are:
<dl>
<dt> %token a
<dd> declares terminal symbol a; YACC can generate a set of #define's
that map these symbols onto integers, in a y.tab.h file. <em><b> Note: don't
#include your y.tab.h file from your grammar .y file, YACC generates the
same definitions and declarations directly in the .c file, and including
the .tab.h file will cause duplication errors.</b></em>
<dt> %start A
<dd> specifies the start symbol for the grammar (defaults to nonterminal
     on left side of the first production rule).
</dl>
<p>
The grammar gives the production rules, interspersed with program code
fragments called semantic actions that let the programmer do what's
desired when the grammar productions are reduced.  They follow the
syntax
<pre>
A : body ;
</pre>
Where body is a sequence of 0 or more terminals, nonterminals, or semantic
actions (code, in curly braces) separated by spaces.  As a notational
convenience, multiple production rules may be grouped together using the
vertical bar (|).



<h3> Bottom Up Parsing (How Does Bison's yyparse() Work?) </h3>

Bottom up parsers start from the sequence of terminal symbols and work
their way back up to the start symbol by repeatedly replacing grammar
rules' right hand sides by the corresponding non-terminal.  This is
the reverse of the derivation process, and is called "reduction".
<p>

Example. For the grammar
<pre>
(1)	S->aABe
(2)	A->Abc
(3)	A->b
(4)	B->d
</pre>
the string "abbcde" can be parsed bottom-up by the following reduction
steps:
<pre>
abbcde
aAbcde
aAde
aABe
S
</pre>


<h3> Handles </h3>

Definition: a <em>handle</em> is a substring that
<ol>
<li> matches a right hand side of a production rule in the grammar and
<li> whose reduction to the nonterminal on the left hand side of that
     grammar rule is a step along the reverse of a rightmost derivation.
</ol>

<A name=shiftreduce>
<h3> Shift Reduce Parsing </h3>     
</A>

A shift-reduce parser performs its parsing using the following structure
<pre>
<u>Stack</u>					<u>Input</u>
$						&omega;$
</pre>
At each step, the parser performs one of the following actions.
<ol>
<li> Shift one symbol from the input onto the parse stack
<li> Reduce one handle on the top of the parse stack. The symbols
     from the right hand side of a grammar rule are popped off the
     stack, and the nonterminal symbol is pushed on the stack in their place.
<li> Accept is the operation performed when the start symbol is alone
     on the parse stack and the input is empty.
<li> Error actions occur when no successful parse is possible.
</ol>

<p>
<font size=1> <A name=11>lecture #11</A> began here</font>
<p>

<h3> Reading Assignment </h3>

Clarifying the reading assignment from last lecture:

<ul>
<li> (maybe previously assigned) Read Louden Chapter 3, section 1-6.
     You can skip the Tiny language description in 3.7.
<li> It was suggested that you read the Louden section on YACC or the
     Bison chapter from the optional text.
<li> Additionally or alternatively, you may read sections
     1, 3, 4, 5 and 6 of the <A href="https://www.gnu.org/software/bison/manual/html_node/">Bison Manual</A>
</ul>

<h3>Mailbag</h3>

<DL>
<dt> The grammar file uses '{' and such as terminal symbols,
     instead of names like LCURLY. Is that going to cause a problem?
     '{' is just a small integer.
<dd> Yes it does, no it does not cause a problem.
<dt> What element types can be used in arrays and maps?  Can I have an
     array of arrays?  A map of maps?

<dd> For VGo, legal map index types are: int, string. Element types
     also include float64 and structs.
     Array of arrays and map of maps are awesome but not in VGo.
     Note that structs can have arrays or maps as member variables.

<dt> What about no-op statements like 2+2?
<dd> Go and VGo do not allow no-op statements like 2+2.  You have to use
     the value somehow, like by writing it out or assigning it to a variable.

<dt> The grammar you gave us has many symbols that have not been mentioned.
     Should we support them, or not?  If we don't
     have to support them does that mean we don't have to include all the
     grammar rules that use them?
<dd> Feel free to ask about specifics.
     The supplied grammar is for the whole language not our subset. You
     would need to delete from it <em>en masse</em> to get down to our subset.
     While that might be helpful from a code-management perspective,
     it would also leave you saying a more vague "parse error" message
     for many legal Go constructs for which a more helpful message is
     "this Go feature is not supported by VGo".

<dt> How about a tool that would generate #define numbers for grammar rules
automatically from our .y files?
<dd> I wrote a <A href="nonterms.icn">cheap hack version 0</A>
of such a tool awhile back. I have not tested it on go.y, it might be buggy.

<dt> Will we get marked off for any reduce/reduce conflicts we have?
<dd> Yes you will lose points if you turn in a HW#2 with reduce/reduce
conflicts.

<dt> How are we supposed to integrate the token names we created in the
     lexer with those token names in the Bison .y file?
<dd> Any which way you can.  Probably, you
     either rename yours to use their names, or rename theirs to
     use your names.

<dt> what action should be taken in the case of epsilon statements
<dd> HW#2 spec says to use $$=NULL. I could also imagine using
     <code>$$=alctree(EPSILON, 0)</code> to build an explicit epsilon leaf,
     for people who don't like to have to check for NULL everywhere.

<dt> Will I be setting myself up for failure if I attempt to write
     my own grammar from scratch?
<dd> Go right ahead and ignore the provided grammar if you want; feel free to
     instead derive your grammar from the reference manual.
</dl>


<h3> Midterm Exam Date Discussion </h3>

We will need to have a midterm on Oct 17.


<h3> The YACC Value Stack </h3>

<ul>
<li> YACC's parse stack contains only "states"
<li> YACC maintains a parallel set of values
<li> $ is used in semantic actions to name elements on the value stack
<li> $$ denotes the value associated with the LHS (nonterminal) symbol
<li> $n denotes the value associated with RHS symbol at position n.
<li> Value stack typically used to construct the parse tree
<li> Typical rule with semantic action: A : b C d { $$ = tree(R,3,$1,$2,$3); }
</ul>



<h3> YACC Value Stack's Element Type: YYSTYPE </h3>

<ul>
<li> The default value stack is an array of integers
<li> The value stack can hold arbitrary values in an array of unions
<li> The union type is declared with %union and is named YYSTYPE
</ul>

<p>
<font size=1> <A name=12>lecture #12</A> began here</font>
<p>

<h3> Mailbag </h3>

<dl>
<dt> During my "make" the linker complains about redefinition of yyparse()
     and missing main(). What's going on?
<dd> If your main is in vgo.c, beware renaming go.y as vgo.y -- the "make"
     program has default rules that assume if a .c file has the same name
     as a .y file, it is supposed to build the .c from the .y by running
     yacc and renaming the foo.tab.c as foo.c!

<dt> My vgo parser always dies on the first LBODY, what gives?
<dd> Wow, this opened an awesome can of worms!  go.y as delivered
     by the go 1.2.2 compiler used two different codes for '{' in
     the grammar! In their lexical analyzer, which we are not using,
     they wrote:
<pre>
	 * to implement rule that disallows
	 *	if T{1}[0] { ... }
	 * but allows
	 * 	if (T{1}[0]) { ... }
	 * the block bodies for if/for/switch/select
	 * begin with an LBODY token, not '{'.
	 *
	 * when we see the keyword, the next
	 * non-parenthesized '{' becomes an LBODY.
	 * loophack is normally 0.
	 * a keyword makes it go up to 1.
	 * parens push loophack onto a stack and go back to 0.
	 * a '{' with loophack == 1 becomes LBODY and disables loophack.
</pre>
     We will have to devise a strategy to deal with this.
<ul>
<li> "Just for fun" I changed all LBODY in go.y into '{' to see the fuss.
<li> result was: 2 shift-reduce conflicts. Presumably these are not the kind
     of shift-reduce conflicts I am used to ignoring.
<li> I looked at the conflicts details using <code>bison -v</code>, which
     writes a *.output file
<li> Deleting a couple of production rules under non-terminal pexpr_no_paren
     would "fix" the problem...
<li> One of the conflicting rules was actually already an error
     ("cannot parenthesize type in compusite literal")
<li> The other one might be for struct initializers. We can live without those
     in VGo.
<li> Summary: go.y was updated, it is recommended that you change all LBODY to
     '{' and delete a couple grammar production rules.
</ul>
<dt> What is <code>%prec NotParen</code> about?
<dd> Great question.  %prec TERM directs Bison to apply the
     current grammar rule with the precedence of TERM.  In go.y, three
     fake terminal symbols are introduced as their secret to avoid
     shift/reduce conflicts.

     Note that neither %prec nor TERM are symbols on the righthand side of
     whatever production rule is being given -- if there aren't any other
     symbols then that precedence is being applied to an epsilon rule.

     %prec is used to apply some precedence rules specified via %left,
      %right etc. to production rules in the Bison grammar where there is
      not a symbol that can be declared as %left or %right.  %left and
      %right are in turn, Bison's way of tie-breaking ambiguous grammar
      rules that would otherwise generate shift/reduce or reduce/reduce
      conflicts.


<dt> I am working on the tree but I am confused as to how to approach it. For
example package has the following rule:
<pre>package: LPACKAGE sym ';'</pre>

The tree struct shown on the hw2 assignment sheet has kids which
are of type struct tree and a leaf which is of struct token. Since package
has two tokens the LPACKAGE and ';' how should I approach saving this
to the tree struct. Should everything be saved under kids? With how I have
my %union right now, LPACKAGE and ';' are tokens and sym is struct tree.

<dd> The example in HW#2, which you are not required to follow, illustrates
one possible way to incorporate terminal symbols as leaves.  If you follow
it, separate from your struc token for each leaf you allocate a struct tree,
with 0 children, whose prodrule is the token's terminal symbol #, and for
a treenode with 0 children and a terminal symbol as a prodrule, the code that
goes back through the tree afterwards would know to not visit the children
array, but instead look at the leaf field for a token.
To do all this with your current %union with pointer to struct token on the
tree for terminal symbols, every time you are about to insert a tree node
with terminal symbols, you would allocate a leaf node to hold the token *.
So your rule for a package would allocate three tree nodes total, one for
the parent and two for the two terminal symbols being placed into leaves.
There are other ways that one can get it done, but this would work.


</dl>

<h4> Getting Lex and Yacc to talk </h4>

<ul>
<li> YACC uses a global variable named <code>yylval</code>, of type YYSTYPE,
to receive lexical information from the scanner.
<li> Whatever is in this variable <code>yylval</code> gets copied onto the
top of the value stack each time <code>yylex()</code> returns to the parser
</ul>
<p>

Options:
<ol>
<li> Declare that struct token may appear in the %union.
     In that case the value stack is a mixture of struct node
     and struct token.  You still have to have a mechanism for
     how do tokens get wired into your tree. Are all children
     of type union YYSTYPE, and you use the prodrule R
     to tell which are which?
<li> For each terminal symbol, allocate a "leaf" tree node with 0 children
     and point its "leaf" field at your struct token.  0 children implies
     "don't use the kids field" and "a non-null leaf might be present"
<li> declare a tree type that allows tokens to include
     their lexical information directly in the tree nodes, perhaps tree nodes
     contain a union that provides EITHER an array of kids OR a struct token.
</ol>

If you have more than one %union type possible, be prepared to see type
conflicts and to declare the types of all your nonterminals.

<p>

Getting all this straight takes some time; you can plan on it.  Your best
bet is to draw pictures of how you want the trees to look, and then make the
code match the pictures. Given pictures, I can help you make the code do
what the pictures say.  No pictures == "Dr. J will ask to see your
pictures and not be able to help if you can't describe your trees."


<h3> Declaring value stack types for terminal and nonterminal symbols </h3>

Unless you are going to use the default (integer) value stack, you will
have to declare the types of the elements on the value stack.  Actually,
you do this by declaring which
union member is to be used for each terminal and nonterminal in the
grammar.
<p>
Example: in the cocogram.y that I gave you we could add a %union declaration
with a union member named treenode:
<pre>
%union {
  nodeptr treenode;
}
</pre>

This will produce a compile error if you haven't declared a nodeptr type
using a typedef, but that is another story.  To declare that a nonterminal
uses this union member, write something like:
<pre>
%type < treenode > function_definition
</pre>

Terminal symbols use %token to perform the corresponding declaration.
If you had a second %union member (say struct token *tokenptr) you
might write:
<pre>
%token < tokenptr > SEMICOL
</pre>



<h3> Mailbag </h3>

<dl>
<dt> My compiler is complaining about strdup being missing. What up?
<dd> It turns out -std=c99 removes strdup() because it is not part of that
     standard.  Possibly solutions include: not using -std=c99 when compiling
     files that call strdup(), or writing/providing your own strdup().

<dt> When I compile my .y file, bison complains spitting out a bunch of
     warnings about useless nonterminals and rules. how much attention
     should I pay to this?
<dd> "Useless" warnings sound innocuous, but they mean what they say.
     You probably have something wrong that will have to be fixed.
     Everything but shift/reduce conflicts is potentially serious, until
     you determine otherwise. If you can't figure out what some Bison error
     is after giving it the reasonable college try, send it to me by e-mail
     or schedule an appointment.  If I am not available or you are remote,
     we may schedule a Zoom meeting.  You might have to learn some Zoom.
     I might have to setup a camera on my many machines, and remember my
     Zoom credentials.
<dt> I've been trying to implement implicit concatenation in the grammar
     and I'm getting reduce/reduce errors. Do you have any tips for
     implementing implicit concatenation? Should I make specific rules
     for concatenating strings and lists and stop trying to integrate
     it into my expression syntax?
<dd> If you can't get implicit concatenation working, you might resort
     to explicit concatenation via (perhaps) the + operator. Tips to avoid
     reduce/reduce errors include: avoid epsilon rules. MERGE rules that
     look like the same thing (in Ada, functions and arrays both used the
     same syntax!  sad!).  Incidentally, neither Unicon nor Java have
     implicit concatenation, so in g0 it is a "can we do it?" question.
     I would be happy to consult with folks on your grammarly endeavors
     in office hours and additional appointments.

<dt> It seems after HW#2 we will have to implement a hash table.
     If this is the case, what would be a reasonable size (# buckets) of
     the table?  n=20?
<dd> Fixed-size tables should use a prime. For the size of inputs
     I will ever manage in this class, probably a prime less than 100 would do.
     How about n=41 ?
<!--
<dt> Are we just supporting class, enum, typedef, and namespace identifiers and <em>not</em> structs?
<dd> 120++ has to my knowledge class, typedef, and struct but not
     enum or namespaces other than std.  Furthermore, typedef and
     struct are only mentioned in passing and not used significantly.
     About the only mention of them is
<pre>
typedef struct pet {
int happy;
int hunger;
char name[100];
} pet;
pet pet1, pet2;
</pre>

For the purposes of our class, the Best thing to do would be to
make the "type names table" record, for each name, whether it was
a struct label, a typedef name, or a class name.  However, it will
sufficient if all you managed was to return CLASS_NAME
instead of IDENTIFIER for names that were declared as the names of
classes.

-->
</dl>


<h3> Conflicts in Shift-Reduce Parsing </h3>

"Conflicts" occur when an ambiguity in the grammar creates a situation
where the parser does not know which step to perform at a given point
during parsing.  There are two kinds of conflicts that occur.

<dl>
<dt> shift-reduce
<dd> a shift reduce conflict occurs when the grammar indicates that
     different successful parses might occur with either a shift or a reduce
     at a given point during parsing.  The vast majority of situations where
     this conflict occurs can be correctly resolved by shifting.
<dt> reduce-reduce
<dd> a reduce reduce conflict occurs when the parser has two or more
     handles at the same time on the top of the stack.  Whatever choice
     the parser makes is just as likely to be wrong as not.  In this case
     it is usually best to rewrite the grammar to eliminate the conflict,
     possibly by factoring.
</dl>

Example shift reduce conflict:
<pre>
S->if E then S
S->if E then S else S
</pre>
<P>
In many languages two nested "if" statements produce a situation where
an "else" clause could legally belong to either "if".  The usual rule
(to shift) attaches the else to the nearest (i.e. inner) if statement.
<p>

Example reduce reduce conflict:
<pre>
(1)	S -> id LP plist RP
(2)	S -> E GETS E
(3)	plist -> plist, p
(4)	plist -> p
(5)	p -> id
(6)	E -> id LP elist RP
(7)	E -> id
(8)	elist -> elist, E
(9)	elist -> E
</pre>
By the point the stack holds ...id LP id<br>
the parser will not know which rule to use to reduce the id: (5) or (7).

<p>
<font size=1> <A name=13>lecture #13</A> began here</font>
<p>

<h3>Mailbag</h3>

<dl>
<dt> Can I put a string label in my tree nodes, saying what nonterminal it is?
<dd> You could have a string, you could have an integer; you could have both
     for all I care. Actually, both is a pretty good idea. The string makes
     for human-readable tree output, while the integer is superior for writing
     tree traversals and doing different behavior depending on what kind of
     tree node you are dealing with.
<dt> I haven't been able to find a way to edit the yylex() that's generated
     (in order to semi-colon insertion).
<dd> You aren't supposed to do this manually, you are supposed to do it
     automatically with a computer program whenever you (re)make it. Per
     a previous class discussion, there are several UNIX tools that could
     do this, including the option of writing a C program or a flex program
     to do it.  But one of the simplest options may be something like the
     following in your makefile:
<pre>
lex.yy.c: lex.l
	flex lex.l
	sed -i 's/yylex/myyylex/g' lex.yy.c
</pre>

<dt> In the example <code>A : b C d {$$ = tree(R,3,$1,$2,$3);} ;</code>
Suppose C is a terminal and b and d are non-terminals. Then $2 will be
OK, but when will I be able to get the data that $1 and $3 need to
be set to?
<dd>Bison parsers are bottom up. You don't reduce this grammar rule
or execute this code until sometime after the handle <code>b C d</code>
has already been parsed, and in that process the production rules for
b and d have already executed, just as surely as the shift of C which
placed whatever yylval held at that time onto the value stack in $2.
If the rules for b and d had actions that said {$$=...} at that point
in the past, then $1 and $3 now will be holding what was assigned to $$
back in those rules' semantic actions.

<dt> In the example <code>A : b C d {$$ = tree(R,3,$1,$2,$3);} ;</code>
     to what doth R refer?
<dd> R was intended to be an integer code that allows you to tell, when
     walking through the tree later on, what production rule built that node.
     I would typically do a code for each nonterminal, gapped large enough
     that R can be (nonterminal+rule#forthatnonterminal).  Suppose this was
     the first of three production rules that build an A.  The integer might
     be (__A__ + 1) to denote the first A rule.

<dt> I'm considering having some sort of stack that keeps track of the parent
     you should currently be attaching children to.
<dd> You can do anything you want, but bison's value stack is that stack and
     and at each level you should allocate a node for $$ and attach all of its
     children. That is it.

<dt> Should we be defining our own integer codes for token types or just use
 the ones in our *.tab.h file from HW#1?
<dd> You can't define your own codes, you have to use the codes that bison
 generates. You'll have to modify your lexer to use bison's integers, or your
 flex and bison will not work together.

<dt>Are yylval's types defined in the %union?
<dd>Yes, yylval is of type YYSTYPE, the type bison generates for the %union.
<dt> What is the actual value of a $n variable?
<dd> Before your bison grammar's semantic action code triggers, $1, $2, ... 
     etc. will be holding either (A) whatever you put in yylval if the
     corresponding symbol is a terminal, or (B) whatever you put in $$
     for its rule if the symbol is a non-terminal.
  
<dt>Do we have to implicitly concatenate <em>sub</em>strings?
<dd>Yes, substrings are strings.
<dt> Since we're not doing initializers, what is required of a for-statement?
<dd> You don't have to do a declaration of a variable in a for initializer.
      Saying <code>for(int i=1; ...)</code> was a C++ thing.
<!--
<dt> what's a declarator?
<dd> A portion of a variable declaration, not including the base type,
     which includes the variable's name and pointer/reference/array status.
     It may optionally include an initializer.  Here is a definition from
     <A href="https://msdn.microsoft.com/en-us/library/86zce4y8.aspx">MS</A>.
<p>
Examples:

<pre>
int x;      // declarator is x
int x, y=5; // declarators are x and y=5 in a declarator list
char *s[3]; // declarator is *s[3]
</pre>

-->
</dl>

<h3> Further Discussion of Reduce Reduce and Shift Reduce Conflicts </h3>

The following grammar, based loosely on our expression grammar from
last time, illustrates a reduce reduce conflict, and how you have to
exercise care when using epsilon productions.  Epsilon productions
were helpful for some of the grammar rewriting methods, such as removing
left recursion, but used indiscriminately, they can cause much trouble.

<pre>
T : F | F T2 ;
T2 : p F T2 | ;
F : l T r | v ;
</pre>

The reduce-reduce conflict occurs after you have seen an F.  If the next
symbol is a p there is no question of what to do, but if the next symbol
is the end of file, do you reduce by rule #1 or #4 ?
<p>


<h3> Back to Bison Conflicts and Ambiguity </h3>

A slightly different grammar is needed to demonstrate a shift-reduce conflict:

<pre>
T : F g;
T : F T2 g;
T2 : t F T2 ;
T2 : ;
F : l T r ;
F : v ;
</pre>

This grammar is not much different than before, and has the same problem,
but the surrounding context (the "calling environments") of F cause the
grammar to have a shift-reduce instead of reduce-reduce.  Once again,
the trouble is after you have seen an F and dwells on the question of
whether to reduce the epsilon production, or instead to shift, upon
seeing a token g.
<p>

The .output file generated by "bison -v" explains these conflicts in
considerable detail.  Part of what you need to interpret them are the
concepts of "items" and "sets of items" discussed below.

<P>




<A name=precedence>
<h4> YACC precedence and associativity declarations </h4>
</A>

YACC headers can specify precedence and associativity rules for otherwise
heavily ambiguous grammars.  Precedence is determined by increasing order
of these declarations.  Example:

<pre>
%right ASSIGN
%left PLUS MINUS
%left TIMES DIVIDE
%right POWER
%%
expr: expr ASSIGN expr
    | expr PLUS expr
    | expr MINUS expr
    | expr TIMES expr
    | expr DIVIDE expr
    | expr POWER expr
    | IDENT
    ;
</pre>

<A name=yyerror>
<h4> YACC error handling and recovery </h4>
</A>
<ul>
<li> Use special predefined token <code>error</code> where errors expected
<li> On an error, the parser pops states until it enters one that has an
     action on the error token.
<li> For example: statement: error ';' ;
<li> The parser must see 3 good tokens before it decides it has recovered.
<li> yyerrok tells parser to skip the 3 token recovery rule
<li> yyclearin throws away the current (error-causing?) token
<li> yyerror(s) is called when a syntax error occurs (s is the error message)
</ul>

<p>
<font size=1> <A name=14>lecture #14</A> began here</font>
<p>

<h3> Mailbag </h3>

<dl>
<dt> I have spent 30 hours and am not close to finishing adding the
     hundreds of grammar rules and tree construction semantic actions
     required for HW#2!
<dd> As a professional programmer, you should invest time to master
     a powerful programmer's editor with a key-memorizing macro facility
     that can let you insert semantic actions (for example)
     very rapidly.  If you've been typing them in by hand, ouch!
     Paste the right thing 500 times and then just tweak.  Or paste all
     the constructors with the same number of children in batches, so
     you have less to tweak because you already pasted in the right number
     of kids.

<!--
<dt> Your reference parser reports a bogus error on this simple
     120++ program of mine that uses strings:
<pre>
int main(){
  string name;	
}
</pre>
<dd> Yes, this is an error. It is not bogus.  Interestingly,
g++ still reports a syntax error if you add #include &lt;string&gt;.
In order to recognize the non-built-in type string, the
C++ program has to have "using namespace std;" and include one of:
&lt;string&gt;, &lt;iostream&gt;, or &lt;fstream&gt;.  It turns out the
{io,f}stream  includes include &lt;string&gt;.  If these conditions are
present, you should insert "string" into a type names table, such that
your lexical analyzer returns CLASS_NAME when it sees <code>string</code>.

<dt> Your new reference parser reports a bogus error on this simple
      120++ program that declares a class:
<pre>
class Foo{
public:
   Foo();   
   int play();
};
Foo::play(){
  return 0;
}
</pre>
<dd> Aside from probably needing the reserved word "int" before
Foo::play, the reference code posted does not populate the
"type names table" with the names of classes that it encounters.
Part of HW#2 would include this feedback from the parser to the
lexical analyzer.
-->

<dt> Do I need to add <code>%type &lt;treeptr&gt; nonterm</code> for every
non-terminal symbol in the grammar in order to have everything work
<dd> yes. If you are lucky, the %type's are in there in a comment, and all
you have to do is uncomment them and add the <code>&lt;treeptr&gt;</code>
(or whatever) part.
<!--
<dt> when we run into using namespace std; we place string into our
      type name table, but what about cin/cout/endl ?
<dd> In HW#2 we only need the names of types, because they are needed in
      order to parse successfully and not get syntax errors. In addition
      to string, the type names ifstream, ofstream, and fstream
      appear in 120++ and should get added if the include(s) and
      "using namespace std" appear in the program.
-->
<dt> Are we supporting (syntactically) nested classes/structs?
<dd> no
<!--
<dt> Do we have to parse anything with ::
<dd> classname::function name (including classname::constructor) appear to
     be the only uses of :: in 120++.
-->
<dt> What do I do with epsilon rules? Empty tree nodes?
<dd> I previously said to use either $$ = NULL or
     <code>$$ = alctree(RULE, 0)</code>.
     Whether the latter is preferable depends on what will make your
     tree traversals easier later on, in HW#3, and maybe whether the
     encoding of an empty leaf with RULE would help you in reading the
     tree and knowing what to do with it.  Saying $$=NULL
     implies you will have to check children to see if they are NULL
     before you try to visit them.  Never setting $$ to NULL means you
     can "blindly" traverse child pointers if a parent has nkids &gt; 0.

<dt>
All of the leaves in the tree structure are/can be made of lex tokens. To
that point then, what are the non-leaves supposed to be? I think I may have
over thought this point so I am not quite sure.

<dd> Non-leaves (i.e. internal nodes) correspond to non-terminal symbols,
built from particular production rules.

<dt> For the structure of the tree, HW#2 provides a possible "setup".
<pre>
struct tree {
   int prodrule;
   int nkids;
   struct tree *kids[9];
   struct token *leaf;
}
</pre>

While I understand nkids (number of kids this node has), *kids[9] (a pointer
array to up to 9 kids), and leaf (the lex token), what exactly is the
prodrule?  I am fairly certain that this is the production rule, but I am
not exactly sure what it associates with.

<dd> The prodrule integer encodes what production rule was used
to build this node, which includes (of course) what non-terminal it represents,
and what syntactic role its children played.  By the way, *kids[9] is
an array of 9 pointers to kids, not a pointer to an array of nine kids.


<!--
<dt>  When I add implicit concatenation, Bison doesn't know whether (x - y)
      is a subtraction, or a concatenation of (x) and (-y).  It gives me
      33 reduce/reduce conflicts!  What do I do?

<dd> Possible solutions include:
<ol>
<li> get rid of implicit concatenation (the "Sorry Dr J" approach)
<li> get rid of unary minus, let's use ~ (eeww!) for unary minus
<li> wiggle around the reduce-reduce conflict, perhaps using Bison's
     precedence and associativity, or just the default tie-breaker
<li> get fancier about lexical rules in which unary minus would apply.
     For example, we could say the spaces are not so optional for one or the
     other.
<li> restrict concatenation to only apply to a subset of expressions such
     as adjacent string literals, or those plus variable names
<li> ... several others in class have worked on it, what have you come up with?
</ol>
-->


<!--
<dt> Will we be using any of the following features?
<dd>
By "using" you mean: supporting in your compiler.
Based on my current understanding:

<dl>
<dt>C++-style constructors for native types (i.e. double d(1.0);)
<dd>Not required.
<dt>The sizeof operator
<dd>Not required.
<dt>Array new/delete
<dd>Not required. new/delete only of single class instances. The book
    mentions "new int" in passing, but it is not used in programs.
<dt>The ternary operator (?:)
<dd>Not required.
<dt>Function pointers
<dd>Not required.
<dt>Fixed-size array declarations (i.e. int i[10];)
<dd>Required. These are used in Chapter 6 of 120++.
<dt>Brace initializers (i.e. int i[] = {1, 2, 3};)
<dd>Not required.
</dl>
-->

<dt>
What exactly is in $1 or $2 or ... when I am at a reduction building a
tree node in $$ for some non-terminal?
<dd>
<ul>
<li> If the rule's first righthandside symbol is a terminal, what is in
$1 is whatever you assigned to yylval when that terminal was matched in yylex.
<li> If the rule's first righthandside symbol is a non-terminal, what
is in $1 is whatever you assigned to $$ when that non-terminal was reduced.
</ul>

<!--
<dt>
Even though open hashing is recommended, do you lose points for
implementing hash tables with closed hashing instead?
<dd>
Hashing is not required until homework #3.
Not unless the tester constructs a test that exceeds your limits...which he
might. If you use closed hashing, use a bigger bucket size since you won't
handle overflow gracefully. 10K for global symbol table, 1K for local symbol
tables is probably sufficient.  Actually, we could calculate a much smaller
lower bound for g0, how would we go about doing that?
-->

<dt>
I was wondering if it is ok to have a linked list of syntax trees, where the
syntax tree for the current source file be inserted into a linked list (of
syntax trees), then at the end of main(), after generating syntax trees for
each file in command line argument, walk through the linked list and print
out each syntax tree.

<dd>
What is expected is that for each file, you build the tree,
return to main(), print it out, and then move on to the next filename. But
building a linked list of trees and looping again over that to print things
out would be fine. The main thing between each file on the command line is to
clear out the type name table; each file is being compiled independently of
whatever came before them during that compilation process.

</dl>

<h3> Improving YACC's Error Reporting </h3>

yyerror(s) overrides the default error message, which usually just says either
"syntax error" or "parse error", or "stack overflow".
<p>

You can easily add information in your own yyerror() function, for example
GCC emits messages that look like:
<pre>
goof.c:1: parse error before '}' token
</pre>
using a yyerror function that looks like
<pre>
void yyerror(char *s)
{
   fprintf(stderr, "%s:%d: %s before '%s' token\n",
	   yyfilename, yylineno, s, yytext);
}
</pre>
<p>

You could instead, use the error recovery mechanism to produce better messages.
For example
<pre>
lbrace : LBRACE | { error_code=MISSING_LBRACE; } error ;
</pre>
Where LBRACE is an expected token {<br>
This uses a global variable error_code to pass parse information to yyerror().
<P>


<h3> Improving YACC's Error Reporting, cont'd </h3>
<p>
Another related option is to call yyerror() explicitly with a better message
string, and tell the parser to recover explicitly:
<pre>
package_declaration: PACKAGE_TK error
	{ yyerror("Missing name"); yyerrok; } ;
</pre>
<p>

But, using error recovery to perform better error reporting runs against
conventional wisdom that you should use error tokens very sparingly.
What information from the parser determined we had an error in the first
place?  Can we use that information to produce a better error message?



<h3> LR Syntax Error Messages: Advanced Methods </h3>

The pieces of information that YACC/Bison use to determine that there
is an error in the first place are the parse state (yystate) and the
current input token (yychar). These are exactly the pieces of information
one might use to produce better diagnostic error messages without
relying on the error recovery mechanism and mucking up the grammar
with a lot of extra production rules that feature the <code>error</code> token.
<p>

Even just the parse state is enough to do pretty good error messages.
yystate is not part of YACC's public interface, though, so you may
have to play some tricks to pass it as a parameter into yyerror() from
yyparse().  Say, for example:
<pre>
#define yyerror(s) __yyerror(s,yystate)
</pre>

Inside __yyerror(msg, yystate) you can use a switch statement or a global
array to associate messages with specific parse states.  But, figuring
out which parse state means which syntax error message would be by trial
and error.
<p>

A tool called Merr is available that let's you generate this yyerror
function from examples: you supply the sample syntax errors and messages,
and Merr figures out which parse state integer goes with which message.
Merr also uses the yychar (current input token) to refine the diagnostics
in the event that two of your example errors occur on the same parse state.
See the <A href="http://unicon.sf.net/merr/">Merr</A> web page.



<h3> Recursive Descent Parsing </h3>

Perhaps the simplest parsing method, for a large subset of context free
grammars, is called recursive descent.  It is simple because the algorithm
closely follows the production rules of nonterminal symbols.

<ul>
<li> Write 1 procedure per nonterminal rule
<li> Within each procedure, a) match terminals at appropriate positions,
     and b) call procedures for non-terminals.
<li> Pitfalls:
<ol><li> left recursion is FATAL
<li> must distinguish between several
     production rules, or potentially, one has to
     try all of them via <em>backtracking</em>.
</ol>
</ul>


<p>
<font size=1> <A name=15>lecture #15</A> began here</font>
<p>

<h3>Mailbag</h3>

<dl>
<dt> I have mysterious syntax errors, what do I do?
<dd>
<ul>
<li> make sure that your lexer is including the .tab.h that corresponds to
     your bison file
<li> #define YYDEBUG and set yydebug=1 and read the glorious output, especially
   the last couple shifts or reduces before the syntax error.
<li> implement semi-colon insertion
</ul>
<dt> I can't fix some of the shift/reduce conflicts, what do I do?
<dd> Nothing. You do not have to fix shift/reduce conflicts.
<dt> I can't fix some of the reduce/reduce conflicts, what do I do?
<dd> These generally reflect a real bug and will cost you a few points on HW,
     but they mighty or might not cost you more points on test cases.
     It is only
     a deal breaker and has to be fixed if it prevents us from parsing
     correctly and building our tree. Sometimes epsilon
     rules can be removed successfully by adding grammar rules in a
     parent non-terminal that omit an epsilon-deriving child, and then
     modifying the child to not derive epsilon. This might or might not
     help reduce your number of reduce/reduce conflicts.

<dt>With the default error handling, I am getting an error on the last line of
the file: syntax error before '' token. It looks like an EOF error, but I
cannot figure out how to fix it, as when I add an &lt;&lt;EOF&gt;&gt; rule to my lexer,
it just hangs there, and still produces this error.

<dd> Error on EOF might be because the grammar expects one more semi-colon,
     maybe your EOF regex should return one the first time it hits in each
     file.  By the way, I usually don't have to write a &lt;&lt;EOF&gt;&gt;
     regex, yylex() returns the value on EOF that yyparse() expects.
     If you enable YYDEBUG and turn on yydebug you will get a detailed
     explanation of the parse and where it is failing when you run your
     parser, which may help you.  Feel free to schedule a Zoom session.

</dl>


<h4> Recursive Descent Parsing Example #1</h4>

<pre>
E -> E + T
E -> T
T -> T * F
T -> F
F -> ( E )
F -> ident
</pre>

Consider the grammar we gave above.  There will be functions for
E, T, and F.  The function for F() is the "easiest" in some sense: based
on a single token it can decide which production rule to use.  The
parsing functions return 0 (failed to parse) if the nonterminal in
question cannot be derived from the tokens at the current point.
A nonzero return value of N would indicate success in parsing using
production rule #N.

<pre>
int F()
{
   int t = yylex();
   if (t == IDENT) return 6;
   else if (t == LP) {
      if (E() && (yylex()==RP) return 5;
      }
   return 0;
}
</pre>

Comment #1: if F() is in the middle of a larger parse of E() or T(), F()
may succeed, but the subsequent parsing may fail. The parse may have
to <em>backtrack</em>, which would mean we'd have to be able to put
tokens back for later parsing.  Add a memory (say, a gigantic array or
link list for example) of already-parsed tokens
to the lexical analyzer, plus backtracking logic to E() or T() as needed.
The call to F() may get repeated following a different production rule
for a higher nonterminal.
<p>

Comment #2: in a real compiler we need more than "yes it parsed" or
"no it didn't": we need a parse tree if it succeeds, and we need a
useful error message if it didn't.
<p>

Question: for E() and T(), how do we know which production rule to try?
Option A: just blindly try each one in turn.
Option B: look at the first (current) token, only try those rules that
start with that token (1 character lookahead).  If you are lucky, that
one character will uniquely select a production rule. If that is always
true through the whole grammar, no backtracking is needed.
<p>


Question: how do we know which rules start with whatever token we are
looking at?  Can anyone suggest a solution, or are we stuck?
<p>

Below is an industrious start of an implementation of the
corresponding recursive descent parser for non-terminal <code>T</code>.
Now is student-author time, what is our next step?  What is wrong with
this picture?


<pre>
int T()
{  // save where the current token is
   if (T() && (yylex()==ASTERISK) && F()) return 3;
   // restore the current input pointer to the saved location
   if (F()) return 4;
   return 0;
}
</pre>


<h3> Removing Left Recursion </h3>


<pre>
E -> E + T | T
T -> T * F | F
F -> ( E ) | ident
</pre>

We can remove the left recursion by introducing new nonterminals
and new production rules.

<pre>
E  -> T E'
E' -> + T E' | &epsilon;
T  -> F T'
T' -> * F T' | &epsilon;
F  -> ( E ) | ident
</pre>

Getting rid of such <em>immediate left recursion</em> is not enough, one must
get rid of indirect left recursion, where two or more nonterminals are
mutually left-recursive.
One can rewrite <em>any</em> CFG to remove left recursion (Algorithm 4.19). 

<pre>
for i := 1 to n do
   for j := 1 to i-1 do begin
      replace each A<sub>i</sub> -&gt; A<sub>j</sub> &gamma; with productions
         A<sub>i</sub> -&gt; &delta;<sub>1</sub>&gamma; | &delta;<sub>2</sub>&gamma; | ... | &delta;<sub>k</sub>&gamma;, where
            A<sub>j</sub> -&gt; &delta;<sub>1</sub> | &delta;<sub>2</sub> | ... | &delta;<sub>k</sub> are all current A<sub>j</sub>-productions
      end
   eliminate immediate left recursion
</pre>


<h3> Where We Are </h3>

<ul>
<li> We started in on recursive descent parsing by observing that for some
grammar rules, we could just write the code easy peasy by  matching
the first token and then calling nonterminal functions.
<li> Then we hit a wall, because the other nonterminals were left recursive,
we had to solve the infinite recursion problem, which is detailed in your
dragon book.
<li> If we ever clear the left recursion hurdle, THEN we can worry about the
backtracking problem: if we try to parse rule 1, and get into it a ways, and
find that it doesn't work, we have to "undo" all our parsing (and possibly
lexing) back to the starting point in order to try subsequent grammar rules
for a given nonterminal.
</ul>


<h3> Removing Left Recursion, part 2 </h3>

Left recursion can be broken into three cases
<p>
<h4>case 1: trivial</h4>

<pre>
A : A &alpha; | &beta;
</pre>

The recursion must always terminate by A finally deriving &beta; so you
can rewrite it to the equivalent
<pre>
A : &beta; A'
A' : &alpha; A' | &epsilon;
</pre>

Example:
<pre>
E : E op T | T
</pre>
can be rewritten
<pre>
E : T E'
E' : op T E' | &epsilon;
</pre>

<h4>case 2: non-trivial, but immediate</h4>

In the more general case, there may be multiple recursive productions
and/or multiple non-recursive productions.
<pre>
A : A &alpha;<sub>1</sub> | A &alpha;<sub>2</sub> | ... | &beta;<sub>1</sub> | &beta;<sub>2</sub>
</pre>

As in the trivial case, you get rid of left-recursing A and introduce an A'

<pre>
A :  &beta;<sub>1</sub> A' | &beta;<sub>2</sub> A' | ...
A' : &alpha;<sub>1</sub> A' | &alpha;<sub>2</sub> A' | ... | &epsilon;
</pre>


<h4> case 3: mutual recursion </h4>

<ol>
<li> Order the nonterminals in some order 1 to N.
<li> Rewrite production rules to eliminate all
     nonterminals in leftmost positions that refer to a "previous" nonterminal.
     When finished, all productions' right hand symbols start with a terminal
     or a nonterminal that is numbered equal or higher than the nonterminal
     no the left hand side.
<li> Eliminate the direct left recusion as per cases 1-2.
</ol>


<h4> Left Recursion Versus Right Recursion: When does it Matter? </h4>

A student came to me once with what they described as an operator precedence
problem where 5-4+3 was computing the wrong value (-2 instead of 4).  What
it really was, was an associativity problem due to the grammar:
<pre>
E : T + E | T - E | T
</pre>

The problem here is that right recursion is forcing right associativity, but
normal arithmetic requires left associativity.  Several solutions are:
(a) rewrite the grammar to be left recursive, or (b) rewrite the grammar
with more nonterminals to force the correct precedence/associativity,
or (c) if using YACC or Bison, there are "cheat codes" we will discuss later
to allow it to be majorly ambiguous and specify associativity separately
(look for %left and %right in YACC manuals).


<h3> Recursive Descent Parsing Example #2</h3>

The grammar

<pre>
S -> A B C
A -> a A
A -> <em>&epsilon;</em>
B -> b
C -> c
</pre>

maps to pseudocode like the following. (:= is an assignment operator)

<pre>
procedure S()
  if A() & B() & C() then succeed # matched S, we win
end

procedure A()
  if yychar == a then { # use production 2
     yychar := scan()
     return A()
     }
  else
     succeed # production rule 3, match &epsilon;
end

procedure B()
   if yychar == b then {
      yychar := scan()
      succeed
      }
   else fail
end

procedure C()
   if yychar == c then {
      yychar := scan()
      succeed
      }
   else fail
end
</pre>

<h3> Backtracking? </h3>


Could your current token begin more than one of your possible production rules?
Try all of them, remember and reset state for each try.
<pre>
S -> cAd
A -> ab
A -> a
</pre>

<em>Left factoring</em> can often solve such problems:

<pre>
S -> cAd
A -> a A'
A'-> b
A'-> (&epsilon;)
</pre>

One can also perform left factoring <!--(Algorithm 4.2)--> to reduce or
eliminate the lookahead or backtracking needed to tell which production rule
to use.  If the end result has no lookahead or backtracking needed, the
resulting CFG can be solved by a "predictive parser" and coded easily in a
conventional language.  If backtracking is needed, a recursive descent
parser takes more work to implement, but is still feasible.

As a more concrete example:

<pre>
S -> <b>if</b> E <b>then</b> S
S -> <b>if</b> E <b>then</b> S<sub>1</sub> else S<sub>2</sub>
</pre>

can be factored to:

<pre>
S -> <b>if</b> E <b>then</b> S S'
S'-> else S<sub>2</sub> | &epsilon;
</pre>

<p>
<font size=1> <A name=16>lecture #16</A> began here</font>
<p>

<h3> Mailbag </h3>

<dl>
<dt> I got my trees printing for the tests you gave us for HW#1, am I done?
<dd> You are responsible for thoroughly testing your code, including constructing
test cases. You might want to specifically make sure that each tree-constructor
code fragment that you write gets used by at least one test case (this is called
statement-level coverage).  Having said that constructing tests is on you,
I went and looked at what was lying around handy, and came up with the
<A href="vgotest/">go 1.2.2 test suite</A>.  Can we use it as is?  Almost every
test will use features in Go but not in VGo (things like :=), so we have to translate
them into VGo to use them.  We can either leave this all up to you, or we can
collaborate on it, your choice.

<dt> I get syntax errors on <code>else</code>. What up?
<dd> By running code samples on the real Go compiler ("go build foo.go") one
can tell whether a given test case was legal Go or not. It turns out, if you
do an else, it has to be on the same line as the closing curly brace that
precedes it.  I have adjusted the <A href="vgo.html">VGo Specification</A>
accordingly.

</dl>


<h3> Some More Parsing Theory </h3>

Automatic techniques for constructing parsers start with computing some
basic functions for symbols in the grammar.  These functions are useful
in understanding both recursive descent and bottom-up LR parsers.

<h3> First(&alpha;) </h3>

First(&alpha;) is the set of terminals that begin strings derived from &alpha;,
which can include &epsilon;.

<ol>
<li> First(X) starts with the empty set.
<li> if X is a terminal, First(X) is {X}.
<li> if X -> &epsilon; is a production, add &epsilon; to First(X).
<li> if X is a non-terminal and X -> Y<sub>1</sub> Y<sub>2</sub> ... Y<sub>k</sub> is a production,
     add First(Y<sub>1</sub>) to First(X).
<li><pre>for (i = 1; if Y<sub>i</sub> can derive &epsilon;; i++)
        add First(Y<sub>i+1</sub>) to First(X)
</pre>
</ol>


<h3> First(a) examples </h3>

by the way, this stuff is all in section 4.3 in your text.
<p>
Last time we looked at an example with E, T, and F, and + and *.
The first-set computation was not too exciting and we need more
examples.

<pre>
stmt : if-stmt | OTHER
if-stmt:  IF LP expr RP stmt else-part
else-part: ELSE stmt | &epsilon;
expr: IDENT | INTLIT
</pre>

What are the First() sets of each nonterminal?



<h3> Follow(A) </h3>

(The helper function that goes along with First(X)) <p>

Follow(A) for nonterminal A is the set of terminals that can appear
immediately to the right of A in some sentential form S -> aAxB...
To compute Follow, apply these rules to all nonterminals in the grammar:

<ol>
<li> Add $ to Follow(S)
<li> if A -> aB&beta; then add First(b) - &epsilon; to Follow(B)
<li> if A -> aB or A -> aB&beta; where &epsilon; is in First(&beta;), then add
     Follow(A) to Follow(B).
</ol>


<h3> Follow() Example </h3>

For the grammar:

<pre>
stmt : if-stmt | OTHER
if-stmt:  IF LP expr RP stmt else-part
else-part: ELSE stmt | &epsilon;
expr: IDENT | INTLIT
</pre>

It can get pretty muddy on the Follow() function, for even this simple grammar.
It helps if you follow the algorithm, instead of just "eyeballing it".

<pre>
For all non-terminals X in the grammar do
   1. if X is the start symbol, add $ to Follow(X)
   2. if N -&gt; &alpha;X&beta; then add First(&beta;) - &epsilon; to Follow(X)
   3. if N -&gt; &alpha;X or N -&gt; &alpha;X&beta; where &epsilon; is in
       First(&beta;) then add Follow(N) to Follow(X)
</pre>

Since the algorithm depends on First(), what are First sets again?
<pre>
First(stmt) = {IF, OTHER}
First(if-stmt) = {IF}
First(else-part) = {ELSE, &epsilon;}
First(expr) = {IDENT, INTLIT}
</pre>


Because each non-terminal has three steps, and our toy grammar has
4 non-terminals, there are 12 steps.
When you just apply these twelve steps, brute force, it is clear
that the statement of what to do to compute them was not an algorithm,
it was only a declarative specification, and there is an ordering needed
in order to compute the result.
<pre>
   1. stmt is the start symbol, add $ to Follow(stmt)
   2. if N -&gt; &alpha; stmt &beta; then add First(&beta;) - &epsilon; to Follow(stmt)
	---- add First(else-part)-&epsilon; to Follow(stmt)
   3. if N -&gt; &alpha; stmt or N -&gt; &alpha; stmt &beta; where &epsilon;
	 is in First(&beta;) then add Follow(N) to Follow(stmt)
	---- add Follow(else-part) to Follow(stmt)
   4. if-stmt is not the start symbol (noop)
   5. if N -&gt; &alpha;if-stmt&beta; then add First(&beta;) - &epsilon; to Follow(if-stmt)
	---- n/a
   6. if N -&gt; &alpha;if-stmt or N -&gt; &alpha;if-stmt&beta; where &epsilon; is in
       First(&beta;) then add Follow(N) to Follow(if-stmt)
	---- add Follow(stmt) to Follow(if-stmt)
   7. else-part is not the start symbol (noop)
   8. if N -&gt; &alpha;else-part&beta; then add First(&beta;) - &epsilon; to Follow(else-part)
	---- n/a
   9. if N -&gt; &alpha;else-part or N -&gt; &alpha;else-part&beta; where &epsilon; is in
       First(&beta;) then add Follow(N) to Follow(else-part)
	--- add Follow(if-stmt) to Follow(else-part)
   10. expr is not the start symbol (noop)
   11. if N -&gt; &alpha;expr&beta; then add First(&beta;) - &epsilon; to Follow(expr)
	---- add RP to Follow(expr)
   12. if N -&gt; &alpha;expr or N -&gt; &alpha;expr&beta; where &epsilon; is in
       First(&beta;) then add Follow(N) to Follow(expr)
	---- n/a
</pre>

What is the dependency graph? Does it have any cycles?  If it has cycles,
you will have to iterate to a fixed point.
<pre>
Follow(stmt) depends on Follow(else-part)
Follow(if-stmt) depends on Follow(stmt)
Follow(else-part) depends on Follow(if-stmt)
</pre>
If I read this right, there is a 3-way mutual recursion cycle.


<h3> Can we First/Follow Anything Else </h3>

Like preferably, a real-world grammar example?  Please remember that real
world grammars for languages like ANSI C are around 400+ production rules,
so in-class examples will by necessity be toys.  If I pick a random* (*LOL)
<A href="unigram.y">YACC grammar</A>, can we First/Follow any of its non-terminals?




<h3> LR vs. LL vs. LR(0) vs. LR(1) vs. LALR(1) </h3>

The first char ("L") means input tokens are read from the left
(left to right).  The second char ("R" or "L") means parsing
finds the rightmost, or leftmost, derivation.  Relevant
if there is ambiguity in the grammar.  (0) or (1) or (k) after
the main lettering indicates how many lookahead characters are
used.  (0) means you only look at the parse stack, (1) means you
use the current token in deciding what to do, shift or reduce.
(k) means you look at the next k tokens before deciding what
to do at the current position.

<p>
<font size=1> <A name=17>lecture #17</A> began here</font>
<p>

<h3> Mailbag </h3>

<dl>
<dt> VGo spec says no colons, but then the map constructor uses colons
<dd> Good catch. VGo has maps but not "map literals".  You should have
a colon token in your lexer, even though colons are a Go-not-VGo thing.
Here's a Pepsi Challenge question: is it right and good to just die if
you see a colon, or should you return the colon as a token, and in the
syntax check, distinguish between legal uses of Go that VGo doesn't
handle, versus crazy non-Go uses of a colon operator.
 
<dt> ...
</dl>

<h3> LR Parsers </h3>

LR denotes a class of bottom up parsers that is capable of handling virtually
all programming language constructs.  LR is efficient; it runs in linear time
with no backtracking needed.  The class of languages handled by LR is a proper
superset of the class of languages handled by top down "predictive parsers".
LR parsing detects an error as soon as it is possible to do so.  Generally
building an LR parser is too big and complicated a job to do by hand, we use
tools to generate LR parsers.
<p>

The LR parsing algorithm is given below.<!--See Figure 4.29 for a schematic.-->
<pre>
ip = first symbol of input
repeat {
   s = state on top of parse stack
   a = *ip
   case action[s,a] of {
      SHIFT s': { push(a); push(s') }
      REDUCE A->&beta;: {
         pop 2*|&beta;| symbols; s' = new state on top
         push A
         push goto(s', A)
         }
      ACCEPT: return 0 /* success */
      ERROR: { error("syntax error", s, a); halt }
      }
   }
</pre>



<!--
<h3> Little-known Mysteries of the BASIC Language </h3>

<ul>
<li> BASIC has arrays.  They default to a size of 11 elements.
     Other array sizes are specified via a DIM statement, as in:<br>
     10 DIM A(100)
<li> BASIC has three versions of every variable name (number, string, array)
<li> Variables in BASIC are preinitialized to 0.
<li> PRINT statements have multiple arguments (implicit concatenation?)
<li> PRINT statements can have commas or semicolons between their arguments
<li> Some of our tests have syntax errors; others use features (e.g. graphics)
     that are beyond our scope. Extra credit, but only if you catch up first.
<li> cocogram.y is not infallible, you are to fix it, and then brag about it
<li> Jimenez' COCO emulator is how I test what should and should not work.
</ul>
-->


<p>

<H3>Constructing SLR Parsing Tables: </H3>

<P>
<DFN>Definition: An LR(0) item of a grammar G is a production
of G with a dot at some position of the RHS.</DFN>
<P>
Example: The production A-&gt;aAb gives the items: 
<P>
A -&gt; . a A b<br>
A -&gt; a . A b<br>
A -&gt; a A . b<br>
A -&gt; a A b .
<P>
Note: A production A-&gt; &epsilon; generates
only one item:
<P>
A -&gt; .
<P>
Intuition: an item A-&gt; &alpha; . &beta; denotes:
<OL>
<LI>&alpha; - we have already seen a string
derivable from &alpha;
<LI>&beta; - we hope to see a string derivable
from &beta;
</OL>

<H3>Functions on Sets of Items </H3>

<P>
<DFN>Closure: if I is a set of items for a grammar G, then closure(I)
is the set of items constructed as follows:</DFN>
<OL>
<LI><DFN>Every item in I is in closure(I).</DFN>
<LI><DFN>If A-&gt;</DFN>&alpha; . <DFN>B</DFN>&beta;<DFN>
is in closure(I) and B-&gt;</DFN>&gamma;<DFN>
is a production, then add B-&gt; .</DFN>&gamma;<DFN>
to closure(I).</DFN> 
</OL>

<P>
These two rules are applied repeatedly until no new items can
be added.
<P>
Intuition: If A -&gt; &alpha; . B &beta; is in
closure(I) then we hope to see a string derivable from B in the
input. So if B-&gt; &gamma; is a production,
we should hope to see a string derivable from &gamma;.
Hence, B-&gt;.&gamma; is in closure(I).<BR>

<P>
Goto: if I is a set of items and X is a grammar symbol, then goto(I,X)
is defined to be:
<P>
goto(I,X) = closure({[A-&gt;&alpha;X.&beta;] | [A-&gt;&alpha;.X&beta;]
is in I})
<P>
Intuition: 
<UL>
<LI>[A-&gt;&alpha;.X&beta;]
is in I =&gt; we've seen a string derivable
from &alpha;; we hope to see a string derivable
from X&beta;.
<LI>Now suppose we see a string derivable from X
<LI>Then, we should &quot;goto&quot; a state where we've seen
a string derivable from &alpha;X, and where
we hope to see a string derivable from &beta;.
The item corresponding to this is [A-&gt;&alpha;X.&beta;] 
</UL>


<UL>
<LI>Example: Consider the grammar
</UL>

<PRE>
<FONT SIZE=3>	E -&gt; E+T | T
	T -&gt; T*F | F
	F -&gt; (E) | id 
</font></pre>

&nbsp;
&nbsp;
&nbsp;
&nbsp;
&nbsp;
&nbsp;
&nbsp;
Let I = {[E -&gt; E . + T]} then:
<pre><font size=3>        goto(I,+) = closure({[E -&gt; E+.T]})
		  = closure({[E -&gt; E+.T], [T -&gt; .T*F], [T -&gt; .F]})
		  = closure({[E -&gt; E+.T], [T -&gt; .T*F], [T -&gt; .F], [F-&gt; .(E)], [F -&gt; .id]})
		  = { [E -&gt; E + .T],[T -&gt; .T * F],[T -&gt; .F],[F -&gt; .(E)],[F -&gt; .id]}</FONT>
</PRE>

<p>
<font size=1> <A name=18>lecture #18</A> began here</font>
<p>

<h3> Mailbag </h3>

<dl>
<dt> What-all do you see in <A href="Test2.go">this</A> example?
     It gives me errors on Vertex at the bottom.
<dd> <ol>
<li>In general, if you have to debug something, simplify it to the simplest
     possible version that produces the error.  In this example, Vertex
     would not be legal unless it was previous declared via a <code>type</code>
     declaration.  Is that semantic analysis, or does it impact our parsing?
<li> In debugging VGo, using the Go compiler is a primary sanity check.
     Running the Go compiler, it sees a syntax error on line 69 unrelated to
     your question about Vertex.  See rule #1.
</ol>
I then boiled the Vertex part of your example down to the following, which
does compile with "go build":
<pre>
package main
type Vertex struct {x, y float64}
func main() {
	var m map[string]Vertex
	m["Bell Labs"] = Vertex{ 40.68433, -74.39967 }
	m["Google"] = Vertex{37.42202, -122.08408 }
}
</pre>
As far as I can see, this parsed successfully with my reference VGo
lexer/parser, without Vertex posing any special problems.  If my
interpretation of this is correct, the lexer returning LNAME for Vertex
is OK as a type name according to the go grammar, so the part of HW#2
that reads "Resolve matters regarding type names" is a no-op this semester
thanks to our reference grammar. It has kicked the can down the road on
the question of legal type names, deferring that to semantic analysis
(i.e. HW#3-4) where arguably, it belongs.  If you get syntax errors, maybe
you have changed the grammar in some way that you may want to fix.
</dl>

<H3>The Set of Sets of Items Construction</H3>

<OL>
<LI>Given a grammar G with start symbol S, construct the augmented
grammar by adding a special production S'-&gt;S where S' does
not appear in G.
<LI>Algorithm for constructing the canonical collection of
sets of LR(0) items for an augmented grammar G': 
</OL>

<P>
<FONT SIZE=3 FACE="Courier New"></FONT>
<PRE>
<TT>	begin
	   C := { closure({[S' -&gt; .S]}) };
</TT>	   <TT>repeat
	      for each set of items I in C:
		  for each grammar symbol X:
   		     if goto(I,X) != 0 and goto(I,X) is not in C then
		 	 add goto(I,X) to C;
	   until no new sets of items can be added to C;
	   return C;
	end<BR>
</TT>
</PRE>




<P>
<DFN>Valid Items: an item A -&gt; </DFN>&beta;<DFN><SUB>
1</SUB>. </DFN>&beta;<DFN> <SUB>2</SUB>
 is valid for a viable prefix </DFN>&alpha;<DFN>
</DFN>&beta;<DFN><SUB> 1  </SUB>if
there is a derivation:</DFN>
<PRE>
<FONT SIZE=3 FACE="Courier New">S' =&gt;<SUP>*</SUP><SUB>rm</SUB> </FONT>&alpha;<FONT SIZE=3 FACE="Courier New">A</FONT>&omega;<FONT SIZE=3 FACE="Courier New"> =&gt;<SUP>*</SUP><SUB>rm</SUB></FONT>&alpha; &beta;<SUB><FONT SIZE=3 FACE="Courier New">1</FONT></SUB>&beta;<SUB><FONT SIZE=3 FACE="Courier New"> 2</FONT></SUB>&omega;
</PRE>

<P>
Suppose A -&gt; &beta;<SUB>1</SUB>.&beta; <sub>2</sub> is valid for &alpha;&beta;<SUB>1</SUB>,
and &alpha;B<SUB>1</SUB> is on the parsing
stack
<OL>
<LI>if &beta;<SUB>2</SUB> != &epsilon;,
we should shift
<LI>if &beta;<SUB>2</SUB> = &epsilon;,
A -&gt; &beta;<SUB>1</SUB> is the handle,
and we should reduce by this production 
</OL>

<P>
Note: two valid items may tell us to do different things for the
same viable prefix. Some of these conflicts can be resolved using
lookahead on the input string. 



<H3>Constructing an SLR Parsing Table</H3>

<OL>
<LI>Given a grammar G, construct the augmented grammar by adding
the production S' -&gt; S.
<LI>Construct C = {I<SUB>0</SUB>, I<SUB>1</SUB>, &#133; I<SUB>n</SUB>},
the set of sets of LR(0) items for G'.
<LI>State I is constructed from I<SUB>i</SUB>, with parsing action
determined as follows:
<UL>
<LI>[A -&gt; &alpha;.aB] is in
I<SUB>i</SUB>, where a is a terminal; goto(I<SUB>i</SUB>,a) = I<SUB>j</SUB>
: set action[i,a] = &quot;shift j&quot;
<LI>[A -&gt; &alpha;.] is in
I<SUB>i</SUB> : set action[i,a] to &quot;reduce A -&gt; x&quot;
for all a &isin; FOLLOW(A), where A != S'
<LI>[S' -&gt; S .] is in I<SUB>i</SUB> :
set action[i,$] to &quot;accept&quot; 
</UL>

<LI>goto transitions constructed as follows: for all non-terminals:
if goto(I<SUB>i</SUB>, A) = I<SUB>j</SUB>, then goto[i,A] = j
<LI>All entries not defined by (3) &amp; (4) are made &quot;error&quot;.
If there are any multiply defined entries, grammar is not SLR.
<LI>Initial state S<SUB>0</SUB> of parser: that constructed from
I<SUB>0</SUB> or [S' -&gt; S] 
</OL>


<H3>Constructing an SLR Parsing Table: Example</H3>

<PRE>
<FONT SIZE=3>	S -&gt; aABe		FIRST(S) = {a}		FOLLOW(S) = {$}
	A -&gt; Abc		FIRST{A} = {b}		FOLLOW(A) = {b,d}
	A -&gt; b			FIRST{B} = {d}		FOLLOW{B} = {e}
	B -&gt; d			FIRST{S'}= {a}		FOLLOW{S'}= {$}
</FONT>I<SUB>0</SUB><FONT FACE="Courier New"> = closure([S'-&gt;.S]
   = closure([S'-&gt;.S],[S-&gt;.aABe])
goto(I<SUB>0</SUB>,S) = closure([S'-&gt;S.]) = I<SUB>1
</SUB>goto(I<SUB>0</SUB>,a) = closure([S-&gt;a.ABe])
	    = closure([S-&gt;a.ABe],[A-&gt;.Abc],[A-&gt;.b]) = I<SUB>2
</SUB>goto(I<SUB>2</SUB>,A) = closure([S-&gt;aA.Be],[A-&gt;A.bc])
	    = closure([S-&gt;aA.Be],[A-&gt;A.bc],[B-&gt;.d]) = I<SUB>3
</SUB>goto(I<SUB>2</SUB>,b) = closure([A-&gt;b.]) = I<SUB>4
</SUB>goto(I<SUB>3</SUB>,B) = closure([S-&gt;aAB.e]) = I<SUB>5
</SUB>goto(I<SUB>3</SUB>,b) = closure([A-&gt;Ab.c]) = I<SUB>6
</SUB>goto(I<SUB>3</SUB>,d) = closure([B-&gt;d.]) = I<SUB>7
</SUB>goto(I<SUB>5</SUB>,e) = closure([S-&gt;aABe.]) = I<SUB>8
</SUB>goto(I<SUB>6</SUB>,c) = closure([A-&gt;Abc.]) = I<SUB>9</SUB></FONT>
</PRE>


<h3> Fun with Parsing </h3>

Let's play a "new fun game"* and see what we can do with the following subset
of the C grammar:

<table>
<tr><th> C grammar subset <th> First sets
<tr><td>
<pre>
ats : INT | TYPEDEF_NAME | s_u_spec ;
s_u_spec : s_u LC struct_decl_lst RC |
	s_u IDENT LC struct_decl_lst RC |
	s_u IDENT ;
s_u : STRUCT | UNION ;
struct_decl_lst : s_d | struct_decl_lst s_d ;
s_d : s_q_l SM |
	s_q_l struct_declarator_lst SM ;
s_q_l : ats | ats s_q_l ;
struct_declarator_lst:
	declarator |
	struct_declarator_list CM declarator ;
declarator: IDENT |
	declarator LB INTCONST RB ;
</pre>
<td>
<pre>
First(ats) = { INT, TYPEDEF_NAME, STRUCT, UNION }
First(s_u_spec) = { STRUCT, UNION }
First(s_u) = { STRUCT, UNION }
First(struct_decl_lst) = { INT, TYPEDEF_NAME, STRUCT, UNION }
First(s_d) = { INT, TYPEDEF_NAME, STRUCT, UNION }
First(s_q_l) = { INT, TYPEDEF_NAME, STRUCT, UNION}
First(struct_declarator_lst) = { IDENT }
First(declarator) = { IDENT }
</pre>
</table>

<pre>
Follow(ats) = { $, INT, TYPEDEF_NAME, STRUCT, UNION, IDENT, SM }
Follow(s_u_spec) = { $, INT, TYPEDEF_NAME, STRUCT, UNION, IDENT, SM }
Follow(s_u) = { LC, IDENT }
Follow(struct_decl_lst) = { RC, INT, TYPEDEF_NAME, STRUCT, UNION }
Follow(s_d) = { RC, INT, TYPEDEF_NAME, STRUCT, UNION }
Follow(s_q_l) = { IDENT, SM }
Follow(struct_declarator_lst) = { CM, SM }
Follow(declarator) = { LB , CM, SM }
</pre>

Now, Canonical Sets of Items for this Grammar:

<pre>
I<sub>0</sub> = closure([S' -&gt; . ats]) =
	 closure({[S' -&gt; . ats], [ ats -&gt; . INT ],
	 	  [ ats -&gt; . TYPEDEF_NAME ], [ ats -&gt; . s_u_spec ],
		  [ s_u_spec -&gt; . s_u LC struct_decl_lst RC],
		  [ s_u_spec -&gt; . s_u IDENT LC struct_decl_lst RC],
		  [ s_u_spec -&gt; . s_u IDENT ],
		  [ s_u -&gt; . STRUCT ],
		  [ s_u -&gt; . UNION ]
		  })

goto(I<sub>0</sub>, ats) = closure({[S' -&gt; ats .]}) = {[S' -&gt; ats .]} = I<sub>1</sub>

goto(I<sub>0</sub>, INT) = closure({[ats -&gt; INT .]}) = {[ats -&gt; INT .]} = I<sub>2</sub>
goto(I<sub>0</sub>, TYPEDEF) = closure({[ats -&gt; TYPEDEF_NAME .]}) = {[ats -&gt; TYPEDEF_NAME .]} = I<sub>3</sub>
goto(I<sub>0</sub>, s_u_spec) = closure({[ats -&gt; s_u_spec .]}) = {[ats -&gt; s_u_spec .]} = I<sub>4</sub>

goto(I<sub>0</sub>, s_u) = closure({
		  [ s_u_spec -&gt; s_u . LC struct_decl_lst RC],
		  [ s_u_spec -&gt; s_u . IDENT LC struct_decl_lst RC],
		  [ s_u_spec -&gt; s_u . IDENT ]}) = I<sub>5</sub>

goto(I<sub>0</sub>, STRUCT) = closure({[ s_u -&gt; STRUCT .]}) = I<sub>6</sub>
goto(I<sub>0</sub>, UNION) = closure({[ s_u -&gt; UNION .]}) = I<sub>7</sub>

goto(I<sub>5</sub>, LC) = closure({[ s_u_spec -&gt; s_u LC . struct_decl_lst RC],
[ struct_decl_lst -&gt; . s_d ],
[ struct_decl_lst -&gt; . struct_decl_lst s_d ],
[ s_d -&gt; . s_q_l SM],
[ s_d -&gt; . s_q_l struct_declarator_lst SM],
[ s_q_l -&gt; . ats ],
[ s_q_l -&gt; . ats s_q_l ],
[ ats -&gt; . INT ],
[ ats -&gt; . TYPEDEF_NAME ],
[ ats -&gt; . s_u_spec ],
})
</pre>

<font size=1>* Arnold Schwartzenegger. Do you know the movie? </font>

<p>
<font size=1> <A name=19>lecture #19</A> began here</font>
<p>

<h3> Mailbag </h3>

<dl>
<dt>
What exactly gives the
shape of the tree? I know that it is formed from the rules defined in bison,
but I am having trouble visualizing it.
<dd>
At each node of the tree, the shape (a.k.a. "fan-out", or # of children)
is defined by the # of symbols on the
righthand side of the production rule used to construct that node.
For go.y, the ~273 rules after we've deleted a lot of "hidden" things,
the distribution is about as follows:
<p>

<table border>
<tr><th> Size of RHS <th> # of Rules of that size
<tr><td> 0 <td> 19
<tr><td> 1 <td> 98
<tr><td> 2 <td> 46
<tr><td> 3 <td> 67
<tr><td> 4 <td> 17
<tr><td> 5 <td> 21
<tr><td> 6 <td> 2
<tr><td> 7 <td> 1
<tr><td> 8 <td> 2
</table>

<!--
<dt>
For homework #2, how should we handle user includes?  Should we open the
user include file(s) and generate/output the parse tree for everything in
that file?

<dd>
If HW#1 did the right thing, which was for includes to be handled seamlessly
with a continued sequence of yylex() tokens, HW#2 will generally not have to
do anything special or extra for the included file(s).  HW#2 does
need to clear out its type table and system-includes flags, reset the lexical
analyzer, and call a new yyparse() for each file named on its command line.
-->

<dt> I totally have an example where a shift-reduce conflict was a Real
     Problem even though you said we could ignore shift-reduce conflicts!

<dd> Ouch! When you showed me this in my office, you found that you could
     fix it by simply changing a right recursion to a left recursion!
     Very cool, we finally know why Bison warns of this kind of ambiguity
     in the grammar: sometimes it is really a problem.  I have taken the
     liberty of reducing your example to just about its simplest form:

<pre>
%%
Program:	DeclarationList ProgramBody ;
ProgramBody: 	Function SEMICOLON ProgramBody	| ;
Function:	Declaration OPEN_PAREN CLOSE_PAREN ;
DeclarationList:Declaration SEMICOLON DeclarationList | ;
Declaration:		    INT IDENTIFIER ;
</pre>

The corresponding input that dies on this is:
<pre>
int x;
int main();
</pre>

<dt> How about a tool that would generate numbers
automatically from our grammar .y files?  It should perhaps use negative
numbers (to avoid overlap/conflicts with Bison-generated numbers for
terminal symbols).
<dd> We looked again to see if Bison had an option to generate that, but I
am not aware of one.  Awhile back
I wrote a <A href="nonterms.icn">cheap hack version 0</A>
of such a tool...feel free to adapt it or rewrite something similar.
</dl>

<h3> Status of HW#2 </h3>

<ul>
<li> As of ~2pm I have received about 21 submissions, i.e. about 2/3rds
     of the class has turned something in.
<li> The late fee on HW#2 is 8% per day.
<li> I may sometimes charge a lower late fee, depending on individual
circumstances.
<li> If you have not submitted HW#2 yet, you are not alone. If you are in
this boat, you are encouraged to continue to work on it, seek help from
me as needed, and turn HW#2 in when it is working.
</ul>

<h3> <A href="hw3.html">HW#3</A> </h3>

We need to wrap up discussion of parsing and move lectures on to
semantic analysis.  Read the corresponding chapters in your text.


<h3> On Trees </h3>

Trees are classic data structures.
<ul>
<li> Trees have nodes and edges; they are
a special case of graphs.
<li> Tree edges are directional, with roles "parent"
and "child" attributed to the source and destination of the edge.
<li> A tree has the property that every node has zero or one parent.
<li> A node with no parents is called a root.
<li> A node with no children is called a leaf.
<li> A node that is neither a root nor a leaf is an "internal node".
<li> Trees have a size (total # of nodes), a height (maximum count
     of nodes from root to a leaf),
     and an "arity" (maximum number of children in any one node).
</ul>
<p>

Parse trees are k-ary, where there is a
variable number of children bounded by a value k determined by the grammar.
You may wish to consult your old data structures book, or look at some books
from the library, to learn more about trees if you are not totally
comfortable with them.

<p>
<pre>
#include &lt;stdarg.h&gt;

struct tree {
   short label;			/* what production rule this came from */
   short nkids;			/* how many children it really has */
   struct tree *child[1];	/* array of children, size varies 0..k */
				/* Such an array has to be the LAST
				   field of a struct, and "there can
				   be only ONE" for this to work. */
};

struct tree *alctree(int label, int nkids, ...)
{
   int i;
   va_list ap;
   struct tree *ptr = malloc(sizeof(struct tree) +
                             (nkids-1)*sizeof(struct tree *));
   if (ptr == NULL) {fprintf(stderr, "alctree out of memory\n"); exit(1); }
   ptr-&gt;label = label;
   ptr-&gt;nkids = nkids;
   va_start(ap, nkids);
   for(i=0; i &lt; nkids; i++)
      ptr-&gt;child[i] = va_arg(ap, struct tree *);
   va_end(ap);
   return ptr;
}
</pre>
<P>



<!--
<h3> Changes to Sigala's ISO 96 C++ Grammar Made for 120++ in 120gram.y </h3>

The actual draft ISO 96 C++ grammar was modified a fair bit for use
in this class, to produce a subset C++ grammar that was Bison-friendly.
For what its worth, here is a summary of those changes.  You are at least
nominally charged with looking at what grammar additions would be needed
to handle (as much as possible of) C++14, although such additions would
be met with "C++14 feature XXX is not part of 120++" error messages.

<ul>
<li> changes were motivated by a need to eliminate reduce/reduce
     conflicts.
<li> removing adjacent optional items was generally mandatory
<li> removing optional items at beginning and ending of a rule
       was usually required
<li> optional items in the middle of a rule were often OK
</ul>

Specific changes include:

<dl>
<dt> removed namespace_alias from namespace_name
<dd> ambiguity of these identifier-like rules not needed since we aren't
     doing namespaces properly in 120++.
<dt> removed :: prefixed primary expressions
<dd> overriding current namespace not necessary since we aren't doing
     namespaces properly in 120++.
<dt> removed template_id from unqualified_id
<dd> we aren't doing templates in 120++
<dt> refactored TEMPLATE_opt into two productions in qualified_id
<dt> refactored class_or_namespace_name and nested_name_specifier_opt in
      nested_name_specifier
<dd> class_or_namespace_name basically gave two ways to use an identifier;
      difference is semantic
<dt> removed a rule starting with simple_type_specifier in postfix_expression
<dt> factored out adjacent optionals in postfix_expression
<dt> remove pseudo_destructor names
<dt> pulled '*' and '&' out of unary_operator to avoid reduce/reduce conflicts
<dd> but allow them explicitly in unary_expression
<dt> factored out COLONCOLON_opt in new_expression and delete_expression
<dt> removed possibility of empty simple_declaration (empty ; is not a
     declaration) and init_declarator_list with no decl_specifier_seq
     in front of it
<dt> refactored adjacent optionals in
     simple_declaration,
     simple_type_specifier, elaborated_type_specifier
      qualified_namespace_specifier, using_declaration, direct_declarator,
      direct_abstract_declarator, parameter_declaration_clause,
      member_declaration, base_specifier
<dt> removed optionality of ENUM_opt in enum_specifier
<dd> not that 120++ has to do enum's
<dt> removed optionals at beginning and end of ptr_operator
<dt> refactored optional at end of cv_qualifier_seq
<dt> refactored optional begin of declarator_id
<dt> refactored optional beginning and internal element of function_definition
<dt> refactored class_head to avoid adjacent optionals, removed
      possibility of class head with no identifier
<dt> refactored optionals at end of member_declarator
<dt> removed optionality of identifiers in type_parameter
</dl>
-->

<h3> Having Trouble Debugging? </h3>

To save yourself on the semester project in this class, you should
learn gdb (or some other source level debugger) as well as you can.
Sometimes it can help you find your bug in seconds where you would have
spent hours without it.  But only if you take the time to read the manual
and learn the debugger.

<p>

To work on segmentation faults: recompile all .c files with -g and run your
program inside gdb to the point of the segmentation fault.  Type the gdb
"where" command.  Print the values of variables on the line mentioned in the
debugger as the point of failure.  If it is inside a C library function, use
the "up" command until you are back in your own code, and then print the
values of all variables mentioned on that line.

<p>

After gdb, the second tool I recommend strongly is valgrind.  valgrind
catches some kinds of errors that gdb misses.  It is a non-interactive
tool that runs your program and reports issues as they occur, with a big
report at the end.
<p>

<!--
There is another tool you should know about, although it is a little long in
the tooth at this point. It is useful for certain kinds of bugs, primarily
subtle memory violations.  It is called electric fence.  To use electric
fence you add

<pre>
	/home/.../libefence.a
</pre>

to the line in your makefile that links your object files together to
form an executable.  Assuming you can find or build a copy of libefence.a
somewhere.
-->


<h3> Reading Tree Leaves </h3>

In order to work with your tree, you must be able to tell, preferably
trivially easily, which nodes are tree leaves and which are internal nodes,
and for the leaves, how to access the lexical attributes.
<p>
Options:
<ol>
<li> encode in the parent what the types of children are
<li> encode in each child what its own type is (better)
</ol>
How do you do option #2 here?
<p>
There are actually nonterminal symbols with 0 children (nonterminal with
a righthand side with 0 symbols) so you don't necessarily want to use
an nkids of 0 is your flag to say that you are a leaf.

Perhaps the best approach to all this is to unify the tokens and parse tree
nodes with something like the following, where perhaps an nkids value of -1
is treated as a flag that tells the reader to use
lexical information instead of pointers to children:

<pre>
struct node {
int code;		/* terminal or nonterminal symbol */
int nkids;
union {
   struct token { ...  } leaf; // or: struct token *leaf;
   struct node *kids[9];
   }u;
} ;
</pre>




<h3> Tree Traversals </h3>

Besides a function to allocate trees, you need to write one or more recursive
functions to visit each node in the tree, either top to bottom (preorder),
or bottom to top (postorder).  You might do many different traversals on the
tree in order to write a whole compiler: check types, generate machine-
independent intermediate code, analyze the code to make it shorter, etc.
You can write 4 or more different traversal functions, or you can write
1 traversal function that does different work at each node, determined by
passing in a function pointer, to be called for each node.

<pre>
void postorder(struct tree *t, void (*f)(struct tree *))
{
   /* postorder means visit each child, then do work at the parent */
   int i;
   if (t == NULL) return;

   /* visit each child */
   for (i=0; i &lt; t-&gt; nkids; i++)
      postorder(t->child[i], f);

   /* do work at parent */
   f(t);
}
</pre>

You would then be free to write as many little helper functions as you
want, for different tree traversals, for example:
<pre>
void printer(struct tree *t)
{
   if (t == NULL) return;
   printf("%p: %d, %d children\n", t, t->label, t->nkids);
}
</pre>


<!--
<h3> Compiling <A href="cgram.y">cgram.y</A> </h3>

It was ripped out of an anesthetized patient...for transplanting,
the buck ultimately stops with you.  Cgram.y was already legal Bison,
but to compile the resulting cgram.tab.c, cgram.y needed a %union
definition.  In order to link or work properly, it will still need
you to write helper functions and coordinate its token definitions
with your lexical analyzer / flex output.  The -d flag causes Bison
to write out a compatible header file to define tokens for flex.
-->

<h3> Parse Tree Example </h3>

Let's do this by way of demonstrating what yydebug=1 does for you, on a
very simple example such as:

<pre>
int fac(unsigned n)
{
   return !n ? 1 : n*fac(n-1);
}
</pre>

Short summary: yydebug generates 1100 lines of tracing output
that explains the parse in Complete Detail.  From which we ought
to be able to build our parse tree example.


<h3> Observations on Debugging the ANSI C++ Grammar to be more YACC-able </h3>

<dl>
<dt>Expectation
<dd> not that you pick it up by magic and debug it all yourself,
     but rather that you spend enough time monkeying with yacc grammars
     to be familiar with the tools and approach, and to ask the right questions.
<dt> Tools
<dd> YYDEBUG/yydebug, --verbose/--debug/y.output
<dt> Approach
<dd>
<ul>
<li> Run with yydebug=1 to study current behavior
<li> Do the minimum number of edits necessary to fix*
<li> reduce obvious epsilon vs. epsilon
<li>  Examine y.output to understand remaining reduce/reduce conflicts.
<li>  Delete the causes if they are not in 120++
<li> Refactor the causes if they are in 120++
</ul>
</dl>
<p>

*why?  why not?
<p>

<!--
<h3> Bison debugging example </h3>

<ul>
<li> turned on yydebug=1
<li> trace shows reduce to ctor_initializer_opt before '{', looks good
<li> shift of '{' OK
<li> shift of INT leads to reduce of simple_type_specifier, seems OK
<li> should reduce to type_specifier, decl_specifier, decl_specifier_seq,
      decl_specifier_seq_opt: should be OK
<li> init_declarator_list_opt should go to init_declarator_list,
      init_declarator, declarator, direct_declarator, declarator_id,
      id_expresssion, unqualified_id, identifier, IDENTIFIER
<li> _opt grammar rules introduce epsilons, they were for the convenience
     of the ISO C++ committee, but we know epsilons are evil
<li> removed _opt grammar rules; adjacent ones, at least, were trouble
<li> removing adjacent ones helped, but removing others did not
<li> built with --verbose and --debug, looked at y.output
<li> before removing _opt's, reduce/reduce conflicts were very
     distributed 2,1,5,6,5,3,4,4,6,6,2,6,6,6,6,2,6,6,6,6,6
<li> after removing _opt's, reduce/reduce conflicts were more concentrated:
     45, 13, 9, 9, 9, 9 and a couple strays
<li> about half of reduce/reduce were due to "pseudo-destructors". delete
<li> 13 due to template_id's not knowing whether they are class_name or unqualified_id's. could delete trivially for 120++ (no templates)
<li> four batches of 9 reduce/reduce: type_name could be simple_type_specifier or declarator_id, COLONCOLON type_name not knowing if it is a simple_type_specifier or declarator_id, nested_name_specifier type_name not knowing if it is a simple_type_specifier or a declarator_id, and COLONCOLON nested_name_specifier type_name not knowing if it is a simple_type_specifier or a declarator_id
<li> a couple oddballs: class_key identifier not knowing if it is an elaborated_type_specifier or a class_head, with and without a nested_name_specifier after the class_key
<li> ^-- these latter two bullets identify grammar rules we will either
      delete (if not in 120++) or refactor
</ul>
-->
<p>


<h3> On the mysterious TYPE_NAME </h3>

<em>This may have been covered earlier, it is here for review.
Soule's 120++ text introduces struct's and typedef in passing (interlude 3).
For Fall 2017 you do not
have to handle typedef but DO have to handle class names similarly.</em>
<p>

The C/C++ typedef construct is an example where all the beautiful
theory we've used up to this point breaks down.  Once a typedef is
introduced (which can first be recognized at the syntax level), certain
identifiers should be legal type names instead of identifiers.  To make
things worse, they are still legal variable names: the lexical analyzer
has to know whether the syntactic context needs a type name or an
identifier at each point in which it runs into one of these names. This
sort of feedback from syntax or semantic analysis back into lexical
analysis is not un-doable but it requires extensions added by hand to
the machine generated lexical and syntax analyzer code.
<p>
<pre>
typedef int foo;
foo x;                    /* a normal use of typedef... */
foo foo;                  /* try this on gcc! is it a legal global? */
void main() { foo foo; }  /* what about this ? */
</pre>
<p>

<h3> Suggestions on HW </h3>

<dl>
<dt> Did you Test your Work on lovecraft?
<dd> Lots of folks doing work on lots of OSes, but if it doesn't run well
     on the test machine, you won't get many points.
<dt> Warnings are seldom OK
<dd> shift/reduce warnings are "usually" OK (not
     always). Get rid of other warnings so that when warning of a real
     issue shows up, you don't ignore it like "the boy who cried Wolf!".
<dt> Using <code>{ $$ = $4; }</code> is probably a bad idea
<dd> Q: Why?  Q: under what circumstances is this fine?
<dt> Using <code>{ $$ = $1; }</code> goes without saying
<dd> It is the default... but epsilon rules had better not try it.
<dt> passing an fopen() or a malloc() as a parameter into a function is
     probably a bad idea
<dd> usually, this is a resource leak. It gives you no clean and safe
     way to close/free.
<dt> Some of you are still not commenting to a minimum professional level
     needed for you to understand your own code in 6 months
</dl>



<A name="semantic">
<h3> Semantic Analysis </h3>
</A>

Semantic ("meaning") analysis refers to a phase of compilation in which the
input program is studied in order to determine what operations are to be
carried out.  The two primary components of a classic semantic analysis
phase are variable reference analysis and type checking.  These components
both rely on an underlying symbol table.
<p>

What we <em>have</em> at the start of semantic analysis is a syntax tree that
corresponds to the source program as parsed using the context free grammar.
Semantic information is added by annotating grammar symbols with
<em>semantic attributes</em>, which are defined by <em>semantic rules</em>.
A semantic rule is a specification of how to calculate a semantic attribute
that is to be added to the parse tree.
<p>
So the input is a syntax tree...and the output is the same tree, only
"fatter" in the sense that nodes carry more information. 
Another output of semantic analysis are error messages detecting many
types of semantic errors.
<p>

Two typical examples of semantic analysis include:
<dl>
<dt> variable reference analysis
<dd> the compiler must determine, for each use of a variable, which
     variable declaration corresponds to that use.  This depends on
     the semantics of the source language being translated.
<dt> type checking
<dd> the compiler must determine, for each operation in the source code,
     the types of the operands and resulting value, if any.
</dl>
<p>

<p>
<font size=1> <A name=20>lecture #20</A> began here</font><p>
<p>

<h3> Mailbag </h3>

<dl>
<dt> You marked me down for Valgrind, but I didn't have illegal memory
     reads or writes!  What gives?
<dd> From hw1.html:
<blockquote>
     For the purposes of this class, a "memory error" is a
     message from valgrind indicating a
     read or write of one or more bytes of illegal, out-of-bounds,
     or uninitialized memory.
</blockquote>
The uninitialized memory part includes messages such as:
<pre>
==25504== Conditional jump or move depends on uninitialised value(s)
</pre>
You've been told that the valgrind header and summary,
including memory leaks, are not going to cost you points, I am only
interested in valgrind error messages reported for behavior at runtime.
Any stuff you see in between the valgrind header and summary is either
your output, or valgrind messages that may point at bugs in your code.
</dl>

<h3> Notations used in semantic analysis:</h3>
<dl>
<dt> <strong><u>syntax-directed definitions</u></strong> </dt>
<dd> high-level (<em>declarative</em>) specifications of semantic rules </dd>
<dt> <strong><u>translation schemes</u></strong> </dt>
<dd> semantic rules and the order in which they get evaluated </dd>
</dl>
<p>

In practice, attributes get <em>stored</em> in parse tree nodes, and the
semantic rules are evaluated either (a) during parsing (for easy rules) or
(b) during one or more (sub)tree traversals.
<p>


<h3> Two Types of Attributes:</h3>
<dl>
<dt> synthesized
<dd> attributes computed from information contained within one's children.
     These are generally easy to compute, even on-the-fly during parsing.
<dt> inherited
<dd> attributes computed from information obtained from one's parent or siblings
     These are generally harder to compute.  Compilers may be able to jump
     through hoops to compute some inherited attributes during parsing,
     but depending on the semantic rules this may not be possible in general.
     Compilers resort to tree traversals to move semantic information around
     the tree to where it will be used.
</dl>


<h3> Attribute Examples </h3>

<h4> Isconst and Value </h4>

Not all expressions have constant values; the ones that do may allow
various optimizations.

<table border>
<tr>
<th> CFG	<th> Semantic Rule
</tr>
<tr>
<td>
E<sub>1</sub> : E<sub>2</sub> + T
<td>
E<sub>1</sub>.isconst = E<sub>2</sub>.isconst && T.isconst<br>
if (E<sub>1</sub>.isconst)<br>
&nbsp;&nbsp;&nbsp; E<sub>1</sub>.value = E<sub>2</sub>.value + T.value<br>
</tr>
<tr>
<td>
E : T
<td>
E.isconst = T.isconst<br>
if (E.isconst)<br>
&nbsp;&nbsp;&nbsp; E.value = T.value<br>
</tr>
<tr>
<td>
T : T * F
<td>
T<sub>1</sub>.isconst = T<sub>2</sub>.isconst && F.isconst<br>
if (T<sub>1</sub>.isconst)<br>
&nbsp;&nbsp;&nbsp; T<sub>1</sub>.value = T<sub>2</sub>.value * F.value<br>
</tr>
<tr>
<td>
T : F
<td>
T.isconst = F.isconst<br>
if (T.isconst)<br>
&nbsp;&nbsp;&nbsp; T.value = F.value<br>
</tr>
<tr>
<td>
F : ( E )
<td>
F.isconst = E.isconst<br>
if (F.isconst)<br>
&nbsp;&nbsp;&nbsp; F.value = E.value<br>
</tr>
<tr>
<td>
F : ident
<td>
F.isconst = FALSE<br>
</tr>
<tr>
<td>
F : intlit
<td>
F.isconst = TRUE<br>
F.value = intlit.ival<br>
<td>
</tr>
</table>

<h3> HW Code Sharing Policy Reminder </h3>

<ul>
<li>You can share ideas but are not to share code with your classmates.
<li>If you used an external source, be sure to cite it and make clear
the scope/extent of code that is not your own.
<li>If anything is shared in this class (e.g. yacc grammars, or donuts) it must
be shared with the whole class.  Otherwise, it ruins the level playing field
and makes grading impossible...
<li>On anything else that gives me excessive deja vu in this class,
     I will give zeros, or refer you to the
     appropriate university committee.
</ul>



<h3> Symbol Table Module </h3>

Symbol tables are used to resolve names within name spaces. Symbol
tables are generally organized hierarchically according to the
scope rules of the language.  Although initially concerned with simply
storing the names of various that are visible in each scope, symbol
tables take on additional roles in the remaining phases of the compiler.
In semantic analysis, they store type information.  And for code generation,
they store memory addresses and sizes of variables.
<p>

<dl>
<dt> mktable(parent)
<dd> creates a new symbol table, whose scope is local to (or inside) parent
<dt> enter(table, symbolname, type, offset)
<dd> insert a symbol into a table
<dt> lookup(table, symbolname)
<dd> lookup a symbol in a table; returns structure pointer including type and offset.  lookup operations are often <em>chained</em> together progressively from most local scope on out to global scope.
<dt> addwidth(table)
<dd> sums the widths of all entries in the table.
<ul>
<li> "widths" = #bytes.
<li> The sum of widths is the #bytes needed for the entire memory region
   reserved for this scope.
<li> Examples: activation record (for a function call),
     global data section, or class/struct instance.
</ul>
   Worry not about this method until code generation you wish to implement.
<dt>enterproc(table, name, newtable)
<dd> enters the local scope of the named procedure
</dl>


Note: finish discussing addwidth() and enterproc(). <p>

<p>
<font size=1> <A name=21>lecture #21</A> began here</font>
<p>

<h3> Mailbag </h3>

<dl>
<dt> I was wondering if we should be printing anything out for this assignment
     like the symbol table or anything like that
<dd> Historically, the assignment has only required that students print error
     messages of various types.  However, you almost certainly need to print
     out your symbol tables in order to debug things, and I have no great
     objection to adding that requirement. Thanks for the request. Let's
     revisit <A href="hw3.html">HW#3</A>.
</dl>



<h3> Variable Reference Analysis </h3>

The simplest use of a symbol table would check:

<ul>
<li> for each variable, has it been declared?  (undeclared error)
<li> for each declaration, is it already declared? (redeclared error)
</ul>


<p>


<H3> Semantic Analysis in Concrete Terms </h3>

Broadly, we can envision the semantic analysis as two passes:

<dl>
<dt> Pass 1: Symbol Table Population
<dd> Symbol table population is a syntax tree traversal in which
we look for nodes that introduce symbols, including the creation
and population of local scopes and their associated symbol tables.
As you walk the tree, we look for specific nodes that indicate
symbols are introduced, or new local scopes are introduced. What
are the tree nodes that matter (from <A href="cgram.y">cgram.y</A>)
in this particular example?
<ol>
<li> create a global symbol table (initialization)
<li> each function_declarator introduces a symbol.
<li> each init_declarator introduces a symbol.
<li> oh by the way, we have to obtain the types for these.
<li> "types" for functions include parameter types and return type
<li> "types" for init_declarators come from declaration_specifiers,
     which are "uncles" of init_declarators
</ol>

<dt> Pass 2: Type Checking
<dd> Type checking occurs during a bottom up traversal of the expressions
within all the statements in the program.
</dl>

<p>
<font size=1> <A name=22>lecture #22</A> began here</font>
<p>

<h3> Mailbag </h3>
<dl>
<dt>  I was wondering if it would be better for the hash table to build
      it based on the terminals I find in the tree or the non-terminals?
<dd> the keys you are inserting and looking up in hash tables are
     the variable names declared in the program you are parsing --
     those names came into your tree as terminals/leaves, and not
     all the leaves -- only leaves that are names of things (identifier, or
     LNAME, or whatever you are calling them), and only when those leaves
     appear in particular subtrees/production rules where new variables or
     functions (or type names) are being introduced.
<dt> So as I am traversing the tree should I be looking for LNAMEs
     and other terminal symbols then to determine if I should insert
     or should I look for nonterminals and then as I see those
     non terminals grab the LNAME and the other important data
<dd> Sorta the latter, you are usually looking for non terminals or
     specific production rules, and then traversing selected children
     within which you know you have a list of names being declared.
</dl>

<h3> Announcement </h3>

Coeur D'Alene students: I am told your midterm must be taken at the NIC
Testing Center.  Please locate that facility, and see what requirements
they will have for you to take that exam at 2:30 on October 17.


<h3> Discussion of <A href="semantic.c">a Semantic Analysis Example</A></h3>

<ul>
<li> last lecture when I went into semantic.c, I quickly went into the weeds
     talking about representing type information -- we need all that, but
     we need tree traversal examples worse, and symbol table examples.
<li> semantic.c has example tree traversals that do different tasks
     during semantic analysis.
<li> this example's treewalks best understood in context of
     <A href="cgram.y">cgram.y</A>
<li> this was "ripped out" of a past project
<li> goal: give you ideas
<li> not meant to force you to use this code, or do things this way
</ul>

<p>

<p>
<font size=1> <A name=23>lecture #23</A> began here</font>
<p>

<h3> Mailbag </h3>

<dl>
<dt> So, how many symbol tables do we have to have?  More than one?
<dd> One for each package, one for each function, one for each struct type.
<dt> How do I know what symbol table I am using?
<dd> One could implement this as an inherited attribute, or one can
     track it with an auxiliary global as one walks around the tree.
     If you don't do the inherited attribut, you may have to maintain a
     stack of scopes.
     When you walk into something that has a more local scope, make that
     scope current and use enclosing scopes when more local scopes don't
     find a particular symbol you are looking for.  
</dl>


<h3> Symbol Table Basics </h3>

The goal of a symbol table is to allow storage and retrieval of variable
(and related) information by name.  We are <em>associating</em> a data payload
with that name, so we need a struct with the name and the data payload, and
lookup and insert functions on it.  What is the data payload?

<pre>
struct symtab_entry {
   char *sym;
   struct typeinfo *type; /* as seen previously, two lectures ago */
   /* ... more stuff added later ... */
}
</pre>

We have to be able to look up stuff by name.
We could just do this with a linked list:

<pre>
struct elem {
   struct symtab_entry *ste; // information about a symbol
   struct elem *next;
   };
struct elem *theEntireSymbolTable;
struct symtab_entry *lookup(struct elem *st, char *name) {
   if (st==NULL) return NULL;
   if (!strcmp(st->ste->sym, name)) return st->ste;
   return lookup(st->next, name);
}
struct elem *insert(struct elem *st, char *name, struct typeinfo *t) {
   struct elem *n;
   struct symtab_entry *ste = lookup(st, name);
   if (ste != NULL) {
      fprintf(stderr, "symbol is already inserted\n");
      exit(3);
      }
   /* ste was NULL, make a new one */
   ste = malloc(sizeof (struct symtab entry));
   ste->sym = strdup(name);
   ste->type = t;
   n = malloc(sizeof (struct elem));
   n->ste = ste;
   n->next = theEntireSymbolTable;
   theEntireSymbolTable = n;
}
</pre>

<ul>
<li> Pros: simple
<li> Cons: O(n) does not scale well as n gets big
</ul>

<h3> Aside on malloc() </h3>

malloc() can fail and return NULL. Consider something like the following,
that you can use everywhere in place of malloc():

<pre>
void *ckalloc(int n) // "checked" allocation
{
  void *p = malloc(n);
  if (p == NULL) {
     fprintf(stderr, "out of memory for request of %d bytes\n", n)
     exit(4);
  }
  return p;
}
</pre>


<h3> Hash Functions and Hash Tables for Symbol Tables </h3>

<ul>
<li> purpose: array-like performance for string lookups in large
     collections of strings.
<li> will be O(1) on average iff
<ul> <li> you have enough buckets and if
     <li> hash function is O(1) and if 
     <li> hash function distributes symbols perfectly across buckets
</ul>
<li> recommended implementation: array of linked lists
<li> goal of hash <em>function</em>: produce a unique random integer for
     each unique symbol. Then modulo it by # of buckets to pick array index
<li> How many buckets? Ideally, sized proportionally slightly larger than the
     # of symbols, but number of symbols varies widely across all possible
     source codes. We can certainly calculate averages and choose # of
     buckets large enough to handle the average case well.
     Serious/real compilers will grow the # of buckets if necessary.
</ul>

<pre>
int hash(char *s) { return 0; }   // linked list, O(n)
int hash(char *s) { return s[0];} // hash using first char, x1 x2 x3 hash same
int hash(char *s) {               // what does this one do?
   int len = strlen(s);
   return s[0] + (len>1 ? s[len-1] : 0);
}
int hash(char *s) {               // "good enough"; what's weak here?
   int i=0, sum = 0, len = strlen(s);
   for( ; i&lt;len; i++) sum += s[i];
   return sum;
}
</pre>


<h3> Lessons From the Godiva Project </h3>

By way of comparison, it may be useful for you to look at
some symbol tables and type representation code that were written for
the Godiva programming language project. Check out its hash function.
Being a dialect of Java, Godiva
has compile-time type checking and might provide relevant ideas for OOP
languages.

<ul>
<li> <A href="type.h">type.h</A>
<li> <A href="type.c">type.c</A>
<li> <A href="symtab.h">symtab.h</A>
<li> <A href="symtab.c">symtab.c</A>
</ul>

<p>
<!--<em> Ask about packages and "import" declarations
here, if the source language this semester supports them.</em>-->
<p>

<p>
<font size=1> <A name=24>lecture #24</A> began here</font>
<p>

<h3> Mailbag </h3>

<dl>
<dt> I feel like I am just starring at a wall...
     I am just kinda lost as to how to start.
<dd> Start by copying modifying your tree printer to only print
     out the names of variables at the point at which they are declared.
<dt>As I am creating new symbol tables, how should I keep track of them?
    Should I include like a *next pointer?
<dd>
 There is logically a tree of symbol tables.  Parent symbol tables (in our
 case the symbol table for our "global" package, package main) contain
 entries for symbols defined within them, such as functions, so the parent
 should be able to reach the children's symbol tables by looking them up by
 name within the parent symbol table.  On the other hand, children's symbol
 tables might want to know their parent enclosing symbol table. For general
 nested programming language the child symbol table should contain a parent
 pointer.  For the special case that is VGo, there isn't much nesting and
 you could just have a global variable that knows the root symbol table (for
 package main) and every symbol table that is not the root, can rest assured
 that its parent is the root.

<dt> Does VGo require the type to be given for every parameter? It kinda
sounds like it does.
<dd> The VGo spec mentions having to know the name and type for every
parameter. But the VGo spec also says you can omit the type of the next
item in a comma separated parameter list is the same type.

<dt> Does VGo support calling a function inside another call, as in
<pre>
   fmt.Println(Compare(t1, New(99,1)));
</pre>
<dd> Yes.

<dt>How to deal with imported packages: what does -in general- compiler do?
For example, when it imports “math” , does it copy the functions
declarations? Where can I find the “math” package file? Are there in Bison
built-in function to copy these stuff and added them to the source file, or
should I do copy content and edited the source file in C at the main
function?

<dd> Great question.  In a real compiler for Java or Go, an import is a
pretty big operation, probably reading from a database to get the declarations
of the package being imported.  For VGo we are doing a hardwired special case,
treating these packages as "built-ins", so the compiler can do whatever it
wants in order to get "fmt" and "math/rand" and "time" to work, just enough to
do fmt.Println, rand.Intn, and time.Now.


<dt> What about symbol table lookups related to structs in HW#3, Dr. J?  The
     homework doesn't talk about them much.
<dd> You should catch redeclared variables in all scopes. You should catch
     undeclared variables in all scopes.  If you see <code>x.y</code> in
     the source code, how many symbol lookups is that?
<dt> Are we supposed to create a separate symbol table for each function?
     Or just a symbol table for functions in general?
<dd> You are supposed to create one "global" symbol table for package main,
     one local symbol
     table for each function, and one local symbol table for each struct type.
<dt> I am struggling on figuring out how to detect undeclared variables.
<dd> We should talk about this in detail looking at the non-terminals used in
     your grammar. With any big vague software task,
     it is wise to break it up into smaller, well-defined pieces.  Before you
     try to find all undeclared variables, you could:
<ol>
<li> write a tree traversal that just lists
     all the <em>uses</em> of a variable (in expressions, where values are
     read or written), showing the variable name and line number.  These are
     the things that must be checked.
     <br> Still too big a job?  Break it into even smaller pieces:
     <ul>
     <li> write a tree traversal that just lists the names of functions for
          which you have a function body, and therefore a compound statement
          that contains executable expressions.
     <li> are there anything besides function bodies where you would have to
          check for undeclared variables?
     </ul>
<li> write a tree traversal that inserts all the variable declarations.
     print out the whole symbol table when finished, to show what you've got.
<li> modify the tree traversal #1 to lookup within the symbol table(s) and
     print semantic errors if any lookup fails.
</ol>
</dl>


<h3> Discussion of "Import", and more Generally, Packages </h3>

Suggested approaches for implementing semantic analysis of packages/imports:

<dl>
<dt> treat "import" like a special "include"
<dd>
<Ul>
<li> Pros: moderately easy to implement (<A href="fmt.go">fmt.go</A>,
     <A href="mathrand.go">mathrand.go</A>, <A href="time.go">time.go</A>)
<li> <code>import x.y.z</code> means class <code>z</code> out of
     package <code>x.y</code>.  (This is a Java thing. Not in VGo.)
<li> <code> import "math/rand"</code> means import the rand package from
     the math directory.  From the official
     <A href="https://golang.org/doc/code.html">Go site</A>:
<ul>
<li> a workspace contains repositories
<li> repositories contain packages
<li> packages consist of source files <b><em>in a single directory</em></b>
</ul>
Upshot: directories in Go can contain multiple packages.

<li> Cons: pain to make the VGo lexer/parser do this work.
</ul>
<dt> respond to "import" by inserting some symbol table entries (hardwired
     to the package name)
<dd>
<ul>
<li> Pro: don't have cons of the include approach
<li> Con: either have to reparse whole files in order to suck in types
     for symbols we import OR have to write out symbol tables as external
     files/repositories of info about compiled packages/classes
</ul>
</dl>



<h3> Representing Types </h3>

In statically-typecheck'ed languages,
the target language's type system must be represented using data
structures in the compiler's implementation language.
In the symbol table and in the parse tree attributes used in type checking,
there is a need to represent and compare source language types.  You might
start by trying to assign a numeric code to each type, kind of like the
integers used to denote each terminal symbol and each production rule of the
grammar.  But what about arrays?  What about structs?  There are an infinite
number of types; any attempt to enumerate them will fail.  Instead, you
should create a new data type to explicitly represent type information.
This might look something like the following:
<p>

<pre>struct type {
   /*
    * Integer code that says what kind of type this is.
    * Includes all primitive types: 1 = int, 2=float,
    * Also includes codes for compound types that then also
    * hold type information in a supporting union...
    * 7 = array, 8 = struct, 9 = pointer etc. */
   int base_type;
   union {
      struct array {
         int size; /* allow for missing size, e.g. -1 */
	 struct type *elemtype; /* pointer to type for elements in array,
	 				follow it to find its base type, etc.*/
      } a;
      struct struc {		/* structs */
         char *label;
	 int nfields;
         struct field **f;
	 } s;
      struct type *p;		/* pointer type, points at another type */
   } u;
}

struct field {			/* members (fields) of structs */
   char *name;
   struct type *elemtype;
}

</pre>

Given this representation, how would you initialize a variable to
represent each of the following types:

<pre>
int [10][20]
struct foo { int x; char *s; }
</pre>

<p>



<h3> Building a Type struct from a Syntax Tree Fragment </h3>

<pre>
/*
 * Build Type From Prototype (syntax tree) Example
 */
void btfp(nodeptr n)
{
   if (n==NULL) return;
   for(int i = 0; i < n->nkids; i++) btfp(n->child[i]);
   switch (n->prodrule) {
   case INT:
      n->type = get_type(INTEGER);
      break;
   case CHAR:
      n->type = get_type(CHARACTER);
      break;
   case IDENTIFIER:
      n->type = get_type(DONT_KNOW_YET);
      break;
   case '*':
      n->type = get_type(POINTER);
      break;
   case PARAMDECL_1:
      n->type = n->child[0]->type;
      break;
   case THINGY:
      n->type = n->child[0]->type;
      break;
   case PARAMDECL_2:
      n->type = clone_type(n->child[1]->type);
      n->type->u.p.elemtype = n->child[0]->type;
      break;
   case PARAMDECLLIST_2:
      n->type = get_type(TUPLE);
      n->type->u.t.nelems = 1;
      n->type->u.t.elems = calloc(1, sizeof(struct typeinfo *));
      n->type->u.t.elems[0] = n->child[0]->type;
      break;
   case PARAMDECLLIST_1:
      n->type = get_type(TUPLE)

      /* consider whether left child, guaranteed to be a PARAMDECLLIST,
         is guaranteed to be a tuple.  Maybe its not. */
      n->type->u.t.nelems = n->child[0]->type->u.t.nelems + 1;
      n->type->u.t.elems = calloc(n->type->u.t.nelems,
				      sizeof(struct typeinfo *));
      for(i=0;i < n->child[0]->type->u.t.nelems; i++)
         n->type->u.t.elems[i] = n->child[0]->type->u.t.elems[i];
      n->type->u.t.elems[i] = n->child[1]->type;

      break;
   case INITIALIZER_DECL:
      n->type = get_type(FUNC)
      n->type->u.f.returntype = get_type(DONT_KNOW);
      n->type->u.f.params = n->child[1].type;
      break;
   case SIMPLE_DECLARATION_1:
      n->type = clone_type(n->child[1]->type);
      n->type->u.f.returntype = n->child[0]->type;
   }
}
</pre>

<p>
<font size=1> <A name=25>lecture #25</A> began here</font>
<p>

<h3> Mailbag </h3>

<dl>
<dt> How should I focus my midterm studying? There is a lot of material
     in this class and I would like to try to optimize my study time.
     Should I focus on the lecture notes? Should I be studying the book?
<dd> Perhaps the best way to study for the exams in this course is to do
     your homework assignments.  I try to write exam questions that you
     should know if you have done your assignments.  Having said that,
     if I were picking and choosing between the lecture notes or the book
     I would hit the lecture notes the hardest, referring to the book
     when more (or different) explanations are needed.
</dl>

<h3> Resuming Discussion of Building Type Representation from Syntax Tree </h3>

What we saw last time:
<ul>
<li> add a .type field to struct treenode.
<li> some nodes can synthesize their type from their kids
<li> some nodes can pass type info from one kid down into another
</ul>

The class lecture went into an example parse tree for a function header.
In C it would be
<pre>
int f(int x, int y, float z)
</pre>

In Go the equivalent is
<pre>
func f(x int, y int, z float64)
</pre>

The discussion broached questions such as:
<ul>
<li> How is the parse tree different under the (left recursive)
     go grammar than it was under the (right recursive) example C grammar?
<li> why not just use the parse tree of the function header as the
     "type information" that we store in the symbol table entry for
     function f?
<li> how to construct type information for this function type?
</ul>

<p>
<font size=1> <A name=26>lecture #26</A> began here</font>
<p>

<h3>Mailbag </h3>

<dl>
<dt> I still have no idea where to start HW3!  What do I?
<dd> There is but a single, powerful magic tool at your
     disposal: recursion. Start with basis cases, at leaves.
     Make it work for the MOST SIMPLE CASES POSSIBLE before
     you worry about anything bigger.
     Work your way up the tree.
<dt> Where do I store my symbol tables?
<dd> well if I were you, I'd just get a single (global) symbol table working
     before I worried about local scopes, but... the obvious alternative
     answer to your question are:
<ul>
<li> in the node at the top of each local scope. For example XFNDCL.
     In this case, it is an attribute that can be inherited.
<li> in the symbol table entry for the symbol that owns the scope. For example
     main's local symbol table in main's symbol table entry.
</ul>
After thinking about this, I have come to the conclusion that it may
well be easier to do both, than to do either one by itself. So from now
on, I am going to pretend that you stick pointers to your symbol tables
in both places.

<dt> Is HW#3 really still due Sunday night
<dd> Yes.  Well, I was thinking we didn't
     want to stretch it out into Midterm week.
     Maybe there's a couple days of stretch
     possible, at the expense of midterms.
</dl>

<h3> Recursing through Trees Built from <A href="go.y">go.y</A> </h3>

<ul>
<li> start at the beginning
<li> compile programs with <code>go tool compile foo.go</code>
     when testing Go fragments too small to link.
<li> In the trees, the node names ending
with _N denote production rule #N that builds that nonterminal.
If no _N is given it is presumed to be production rule #1 for
that non-terminal.
</ul>

<p>

<table border>
<tr><th>code<th>tree<th>comments and/or symbol table
<tr><td>
<pre>
// empty file
</pre>
<td>n/a
<td> syntax error, missing package statement

<tr><td>
<pre>
package main
</pre>
<td>
<pre>
    FILE
     |
  PACKAGE_2
   /      \
package   LNAME
          "main"
</pre>
<td>
verify package LNAME (must be "main") <br>
create empty symbol table <br>
(nothing to insert)

<tr><td>
<pre>
package main
var x int
</pre>
<td>
<pre>
          FILE
        /      \
 PACKAGE_2     XDCLLIST_2
   /    \	|      \
package LNAME   &epsilon;     COMMON_DCL
        "main"          /     \
                      LVAR   VARDCL
                             /     \
                          LNAME   LNAME
                           "x"     "int"
</pre>
<td>
Construct a type from LNAME "int" because it is VARDCL kid #2.<br>
Insert "x" into current (global) symbol table because it is VARDCL kid #1.

<tr><td>
<pre>
package main
func main() { }
</pre>
<td>
<pre>
          FILE
        /      \
 PACKAGE_2     XDCLLIST_2
   /    \	|      \
package LNAME   &epsilon;     XFNDCL
        "main"       /  |   \
                LFUNC FNDCL  FNBODY_2
                     /  |  \       \
                 LNAME ATL FNRES  STMTLIST
                "main"  |    |       |
                        &epsilon;    &epsilon;       &epsilon;
</pre>
<td>
Construct a FUNC type from FNDCL
<ul>
<li>   Construct an TUPLE of length 0 from empty ATL
<li>   Construct a VOID type from empty FNRES
</ul>
Insert "main" into global symbol table
<br>
Create a local symbol table <br>
Insert parameters into local symbol table <br>
Insert local variables into local symbol table
</table>


<h3> Connecting Trees to Traversals </h3>

<ul>
<li> we've been looking at example code for building type
     information needed for declarations.
<li> for various "interesting" tree nodes, we need to know not
     only what name goes in the symbol table, but what type
<li> examples given have been for some variant of the C language
     and its non-terminals
<li> for your homework you have to find corresponding nodes in your trees.
<li> we ended up looking at <A href="go.y">go.y</A> and found its
     functions described in rules such as
<pre>xfndcl : LFUNC fndcl fnbody ;
fndcl : sym '(' oarg_type_list_ocomma ')' fnres ;
</pre>
</ul>

<pre>
/*
 * Semantic analysis from syntax tree, VGo Edition
 */
void semantic_anal(struct symtab *current_st, nodeptr n)
{
   if (n==NULL) return;
   for(int i = 0; i &lt; n->nkids; i++) semantic_anal(current_st, n->child[i]);
   switch (n->prodrule) {
   case XFNDCL : /* whole function */
      n->symtab = n->child[1]->symtab;
      populate_locals(n->symtab, n->child[2]);
      /*
       * visit body to check for undeclared/redeclared
       */
      check_variable_uses(n->child[2]);
      break;
   case FNDCL :  /* function header */
      char *name = get_func_name(n->child[0]);
      n->symtab = mk_symtab();

      n->type = get_type(FUNC);
      n->type->u.f.returntype = n->child[4]->type;
      n->type->u.f.params = n->child[2]->type;
      n->type->u.f.symtab = n->symtab;
      st_insert(current_st, name, n->type);

      populate_params(n->symtab, n->child[2]);
      break;
   }
}
</pre>


<h3>Discussion of Tree Traversals that perform Semantic Tests</h3>

This example illustrates just one of the
myriad-of-specialty-traversal-functions that might be used.
This mindset is one way
to implement semantic analysis. <p>

Suppose we have a grammar rule
<pre>
AssignStmt : Var EQU Expr
</pre>

We want to detect if a variable has not been initialized, before it is
used.  We can add a boolean field to the symbol table entry, and set it
if we see, during a tree traversal, an initialization of that variable.
What are the limitations or flaws in this approach?

<p>
We can write traversals of the whole tree after all parsing
is completed, but for some semantic rules, another option is to
extend the C semantic action for that rule with
extra code after building our parse tree node:
<pre>
AssignExpr : LorExpr '=' AssignExpr { $$ = alctree(..., $1, $2, $3);
	lvalue($1);
	rvalue($3);
	}
</pre>

<ul>
<li> In this example, <code>lvalue()</code> and <code>rvalue()</code>
are mini-tree traversals for the lefthand side
and righthand side of an assignment statement.
<li> Their missions are to
propagate information from the parent, namely, inherited attributes
that tell nodes whether their values are being assigned to (initialized)
or being read from.
<li> Warning: since this is happening during parsing,
it would only work if all semantic information that it depends on,
for example symbol tables, was also done during parsing.

<li> Side note: I might be equally or more interested in implementing a
semantic check to make sure the left-hand-side of an assignment is actually
an assignable variable. How would I check for that?
</ul>

<pre>
void lvalue(struct tree *t)
{
   if (t-&gt;label == IDENT) {
      struct symtabentry *ste = lookup(t->u.token.name);
      ste->lvalue = 1;
   }
   for (i=0; i&lt;t-&gt;nkids; i++) {
      lvalue(t->child[i]);
      }
}
void rvalue(struct tree *t)
{
   if (t-&gt;label == IDENT) {
      struct symtabentry *ste = lookup(t-&gt;u.token.name);
      if (ste-&gt;lvalue == 0) warn("possible use before assignment");
   }
   for (i=0; i&lt;t-&gt;nkids; i++) {
      rvalue(t-&gt;child[i]);
      }
}
</pre>

<p>
<font size=1> <A name=27>lecture #27</A> began here</font>
<p>


<dl>
<dt> Does VGo do prototypes?
<dd> I told a student "no" this afternoon, because I've already
     asked plenty of you all. What are the implications?

<dt> What is wrong with the following code? It compiles in Go but not VGo!
<pre>
package main
func main(){
    for sum < 1000 {
        sum += sum
    }
}
</pre>
<dd>

Great catch. I think several folks had run into this -- I heard rumors --
but until someone gave me a concrete example it was easy to ignore as a
possible case of operator error. But here it is. Not too shockingly, it is
related to the LBRACE vs. '{' hack that was previously addressed.  Due to
the syntax of compound literals, the curly brace in this for loop was being
parsed as the start of a compound literal expression, instead of the
for-loop body. I performed the following changes to the official CSE 423
<A href="go.y">go.y</A> in
order to address the problem:
<ul>
<li> removed epsilon non-terminal <code>start_complit</code>
<li> replaced nonterminal <code>lbrace</code> with <code>'{'</code>
</ul>

These changes got this sample program to parse OK for me. We may
yet find some other Go code that won't parse in VGo, particularly related to
the '{' vs LBRACE hack.  We shall see.

<dt> Is the following legal in VGo?  It is legal Go!
<pre>
func hello(int) {}
</pre>
<dd>
Interesting. <A href="https://stackoverflow.com/questions/40950877/is-unnamed-arguments-a-thing-in-go">Here</A> is a discussion of the feature in Go.
No, this is not legal in VGo. Per the VGo spec, parameters are "a
comma-separated list of zero or more variable names and types".

<dt>
What is the difference between a function declaration and a variable
declaration, when it comes to adding the symbols to the table?  as far as
the tree is concerned they are almost exactly the same, with the exception
of which parent node you had.  Is there (or should there be) a line in the
symbol entry which states the entry as a function vs a variable?

<dd>
You add the symbols to the same table. For HW#3 they are thus treated
basically identically. For HW#4 you put in different type information for
functions (whose basetype says they are a function, and whose typeinfo
includes their parameters and return type) than for simple variables.

<dt>

I have code written which (hopefully) creates the symbol table entry for
variables.  This code uses a function which spins down through non-terminals
to get the identifier. Can I use this same function to get the identifier for
a function? A function is
<pre>direct_function_declarator: direct_declarator LP ... RP ...</pre>
so after the direct_declarator it has other useful things that I'm not sure
need to be in the symbol table entry.

<dd>

You can re-use functions that work through similar subtrees, either as-is
(if the subtrees really use the same parts of the grammar) or by generalizing
or making generic the key decisions about what to do based on production rule.
For example, you might add a flag parameter to a function that spins through
nonterminals, indicating whether this was in a function
declaration or not; that might allow you to tweak the tree traversal to adjust
for minor differences.

<dt>

You state "You do not have to support nested local scopes".  Does this mean
there will only be a global scope, or will there be a global + function
scopes, but no secondary scopes inside the local functions?

<dd> Correct, function scopes for locals and parameters, but not nested
local scopes inside those.
</dl>

<h4> Real Life vs. toy lvalue/rvalue example</h4>

This example illustrated walking through subtrees looking for specific
nodes where some information was inserted into the tree.  In real life...
<ul>
<li> information passed down (i.e. inherited attributes) may be passed
     as a (second or subsequent)
     parameter after the tree node the traversal is visiting.
<li> this example might apply mainly to local variables whose definition
     and use are in this same (function definition) subtree
<li> if you wanted to ensure a class or global variable was initialized before
     use, you might build a flow graph (often used in an optimization or
     final code generation phase anyhow)
<li> variable definition and use attributes are more reliably analyzed
     using a flow graph instead of the syntax tree.
</ul>

For example, if the program starts by calling
a subroutine at the bottom of code which initializes all the
variables, the flow graph will not be fooled into generating warnings
like you would if you just started at the top of the code and checked
whether for each variable, assignments appear earlier in the source
code than the uses of that variable.

<h3> <code>(x, y, z int)</code> vs. <code>var a, b, c int</code> </h3>

<table border>
<tr><th>
In a parameter list
<th>
In a variable declaration
<tr><td>
<pre>
         ATL
       /  |  \
    ATL   ,    ARGTYPE
   / | \        |     \
ATL  , ARGTYPE  LNAME  LNAME
 |       |	 "z"   "int"
ARGTYPE LNAME
 |       "y"
LNAME
 "x"
</pre>
<td>
<pre>
     COMMONDCL
    /       \
  LVAR    VARDCL
          /    \
       DNL     NTYPE
       /|\       \
    DNL , LNAME  LNAME
    /|\    "c"   "int"
 DNL , LNAME
  |     "b"
LNAME
 "a"
</pre>
</table>

OK, how do we get type information down to the tree nodes where "x"?
Specialized subtraversals and/or multiple passes.  This sample is
probably a duplicate of some earlier sample code, just tied to the
non-terminal names of the go.y grammar a bit.

<pre>
void populate(struct tree *n, struct symtab *st)
{   int i;
    if (n==NULL) return;
    for(i=0; i&lt;n->nkids; i++)
       populate(n->kids[i], st);
    switch (n->prodrule) {
    case VARDCL:
       n->type = n->kid[1].type;         // synthesiz
       n->kid[0].type = n->type;         // inherit
       insert_w_typeinfo(n->kid[0], st);
       break;
    case NTYPE:
       n->type = n->kid[0].type;
       break;
    case LNAME:
       if (!strcmp(n->token->text, "int"))
          n->type = T_INTEGER;
       break;
    case ARG_TYPE_LIST_1: /* ATL: arg_type */
       break;
    case ARG_TYPE_LIST_2: /* ATL: ATL ',' arg_type */
       break;
    case ARG_TYPE_1: /* AT: name_or_type */
       break
    case ARG_TYPE_2: /* AT: sym name_or_type */
       break
    case ARG_TYPE_3: /* AT: sym dotdotdot */
       break
    case ARG_TYPE_4: /* AT: dotdotdot */
       break
    }
}

/*
 * "inherited attribute" for type could go down by copying from
 * parent node to child nodes, or by passing a parameter. Which is better?
 */
void insert_w_typeinfo(struct tree *n, struct symtab *st)
{ int i;
  if (n == NULL) return;
  for(i=0; i&lt;n->nkids; i++) {
     if (n->kids[i]) {
        n->kids[i]->type = n->type;
        insert_w_typeinfo(n->kids[i], st);
	}
     }
  switch (n->prodrule) {
  case DNL: /* ?? nothing needed */
    break;
  case LNAME:
    st_insert(st, n->token->text, n->type);
    break;
  }
}
</pre>


<p>
<font size=1> <A name=28>lecture #28</A> began here</font>
<p>

<h3> Midterm Info </h3>

<ul>
<li> Historically I've used the day before the midterm for a midterm review.
     However, some students may want to study for the midterm earlier than
     that. Should I be doing the review on Tuesday instead of Wednesday?
<li> CDA students: although the NIC Testing Center lists 2-3pm on Thursday
as an "walk-in testing" period, it also says that's for NIC and LCSC only.
Assume you have to schedule your exam time. If you can't get an appointment
for 2:30-3:20 on Thursday, please make one for as close to that time as you
can.  Friday is probably booked, so if you can't take it on Thursday you
are probably looking at taking it on Wednesday.
</ul>

<h3> Mailbag </h3>

<dl>
<dt> Do we have to check whether array or map subscripts are legal (in-range)
 in this homework?
<dd> Checking "legality" is HW#4's job. In HW#3 you are hopefully getting the
 full type information into the symbol table so that you can use it in HW#4. 
<dt> My tree's attributes aren't propagating from parent to child, why not?
<dd> If there are tree nodes in the middle, they may have to copy attributes
up or down in order for the information to get from source to destination.
<dt>
In some example code on the class site,
you have the type checking done at the same time as the symbol table entry.
Is there any reason not to break these out into 2 separate functions?
<dd> No, no reason at all. In the old days there were reasons.

<dt> What is wrong with this hash?
<pre>
for(i=0; i &lt; strlen(s); i++) {
   sum += s[i];
   sum %= ARRAYSIZE;
   }
</pre>
<dd> How many potential problems can <em>you</em> find in this code?

<!--
<dt>

In the enter_newscope() function in your sample code, what is
<pre>t = (typ==CLASS_TYPE) ?
      alcclasstype(s, new):alcmethodtype(NULL,NULL,new);
</pre>
It is code to deal with methods and classes, but what is
different about member functions ("methods") than ordinary functions?

<dd> Both regular functions and class member functions introduce a new
scope, the difference is that class member functions' enclosing scope is
the class, and within that class, they can find and use other members
(variables and functions) of the class, including private members.
In order to do this, they use an extra parameter (named "this" or "self"),
which will affect us mainly in code generation.
-->
</dl>


<h3> Type Checking </h3>

Perhaps the primary component of semantic analysis in many traditional
compilers consists of the type checker.  In order to check types, one first
must have a representation of those types (a type system) and then one must
implement comparison and composition operators on those types using the
semantic rules of the source language being compiled.  Lastly, type checking
will involve adding (mostly-) synthesized attributes through those parts of
the language grammar that involve expressions and values.

<h4> Type Systems </h4>

Types are defined recursively according to rules defined by the source
language being compiled. A type system might start with rules like:

<ul>
<li> Base types (int, char, etc.) are types
<li> Named types (via typedef, etc.) are types
<li> Types composed using other types are types, for example:
    <ul>
    <li> array(T, indices) is a type. In some
         languages indices always start with 0, so array(T, size) works.
    <li> T1 x T2 is a type (specifying, more or
         less, the tuple or sequence T1 followed by T2;
	 x is a so-called cross-product operator).
    <li> record((f1 x T1) x (f2 x T2) x ... x (fn x Tn)) is a type
    <li> in languages with pointers, pointer(T) is a type
    <li> (T<sub>1</sub> x ... T<sub>n</sub>) -> T<sub>n+1</sub> is a
         type denoting a function mapping parameter types to a return type
    </ul>
<li> In some language type expressions may contain variables whose values
     are types.
</ul>

In addition, a type system includes rules for assigning these types
to the various parts of the program; usually this will be performed
using attributes assigned to grammar symbols.



</dl>


<h3> Example Semantic Rules for Type Checking </h3>

<ul>
<li> We have previous seen: representation of types using C structs.
<li> We could maybe use an additional example of constructing such type
     structures from a syntax tree, but we saw a basic one, for parameters.
<li> Now it is time to consider: using such type structures to perform
     type checking.
<li> Type Checking is a primary example
     of using synthesized semantic attributes.
<li> Q before we start: what-all has to be checked?
</ul>

<table border>
<tr>
<th> grammar rule <th> semantic rule
<tr>
<td>E<sub>1</sub> : E<sub>2</sub> PLUS E<sub>3</sub>
<td>E<sub>1</sub>.type = check_types(PLUS, E<sub>2</sub>.type, E<sub>3</sub>.type)
<tr>
</table>

Where check_types() returns a (struct type *) value.  One of the values
it can return is TypeError.  The operator (PLUS) is passed in to
the check types function because behavior may depend on the operator --
the result type for array subscripting works different than the result
type for the arithmetic operators, which may work different (in some
languages) than the result type for logical operators that return booleans.

<h3> In-class brainstorming: what other type-check rules can we derive? </h3>

Consider the class project. What else will we need to check during semantic
analysis, and specifically during type checking?



<h3>Type Promotion and Type Equivalence</h3>

When is it legal to perform an assignment x = y?  When x and y are
identical types, sure.  Many languages such as C have automatic
promotion rules for scalar types such as shorts and longs.
The results of type checking may include not just a type attribute,
they may include a type conversion, which is best represented by
inserting a new node in the tree to denote the promoted value.
Example:
<pre>
int x;
long y;
y = y + x;
</pre>
<p>

For records/structures, some languages use name equivalence, while
others use structure equivalence.  Features like typedef complicate
matters.  If you have a new type name MY_INT that is defined to be
an int, is it compatible to pass as a parameter to a function that
expects regular int's?  Object-oriented languages also get interesting
during type checking, since subclasses usually are allowed anyplace
their superclass would be allowed.



<p>
<font size=1> <A name=29>lecture #29</A> began here</font>
<p>

<H3> Mailbag </h3>

<dl>

<dt> Am I understanding correctly that for Homework 3 we don't need any type
information? We could theoretically get full credit without storing type
details in our symbol tables?
<dd> Yes.  Well, you need the type information in the symbol table if possible,
but that is to set yourself up for HW#4.

<dt> Is it normal to feel like my code for adding to and checking the
symbol tables is messy, gross, and more hard-coded than I'd like?
<dd>HW#1 and HW#2 were using a declarative language. HW#3 will be
messy and gross by comparison, because from here on out we are using
the imperative paradigm. Walking trees and getting the details all in
there will require a lot of code. How gross it is, "Zis is all up to you"
(from a Geronimo Stilton book).

<dt> Does our language really require comma-separated lists of variables in
     declarations?  It would be <em>so</em> much easier if it only did one
     variable per declaration.
<dd> Don't exaggerate.  It would not be that much easier.
<!--
We want to be able to handle declarations like
<pre>
int x, y
</pre>
So maybe we should talk about how hard is that.
<ul>
<li> Find a variable declaration (whatever you call it). Let's call its
     lefthand (the type) a "declaration specifier" and its
     righthand subtree a "declarator list"
<li> An declarator_list that consisted of just an IDENTIFIER leaf might
     be easier, I admit, but...
<li> a declarator_list that is
     just a linked list of identifiers isn't that much harder.
<li> Write a helper function that does nothing but walk through
     a chain of declarator_list nodes.
<li> When HW#4 comes along, pass type information obtained from synthesizing
     the declaration_specifier into the traversal of the declarator list.
     Options include:
     <ol><li> pass it as a parameter into the helper function, or
     <li> add it as (another) field in the tree structure, and copy
     it downwards
     in the tree from the declartion into the declarator list nodes.</ol>
</ul>
-->
But it is FINE to start by just getting it working for one-variable
declarations, then detect and handle two-variable declarations
as a special case, then generalize to 3+ variables.

<!--
<dt> I am not sure what to do with
    <code>endl</code>, <code>cout</code>, and <code>cin</code>.
     I've checked that
    <code>namespace std</code> appears and that <code>iostream</code>
    is included, but I'm not sure what
    type to give them.  Should I mark them as methods... or perhaps class
    names?
<dd> There are different answers for: "what these really are in C++" and for
     "what our subset 120++ would find adequate".
     As you may recall, you are always allowed to do things more C++-ish
     than the toy behavior I will recommend.
<dt> OK so what about <code>endl</code>?
<dd> Really: <code>endl</code> is an "IO manipulator" that
     inserts a newline and flushes the stream.
     What 120++ could live with: insert into your global symbol table the
      equivalent of having seen:
<pre>
const char endl = '\n';
</pre>
<dt> And what about <code>cin</code> and <code>cout</code>?
<dd> Really: these are are predefined global symbols of type
     <code>ostream</code> and
     <code>istream</code>. What 120++ could live with: CS 120 does not
    distinguish <code>ostream</code> from <code>ofstream</code>, or
    <code>istream</code> from <code>ifstream</code>.
    Insert into your global symbol table the equivalent of:
<pre>
ofstream cout;
ifstream cin;
</pre>
<dt> Doesn't that beg the question of what to insert for these predefined
     classes?
<dd> Yes, and its worse than that.
     120++ does not go into operator overloading, but
     we need <code>&lt;&lt;</code> and <code>&gt;&gt;</code>
     to be predefined to work on them. Table A.5
     in Soule's appendix, also found in our 120++ reference manual, mentions
     a few methods defined on streams.

<dt> What about the class named <code>string</code>?
<dd> I would guess we need to predefine the class string, like we do
ofstream and ifstream.  I don't think defining it as char * will work,
unless 120++ never actually uses methods of class string, and only
passes them as parameters.
-->

<!--
<dt> Can you please clarify what to do with prototypes and what to do
    with Function Definitions?
<dd> You are not required to handle prototypes in g0. If you do,
     prototypes insert something into a global symbol table, enough to
     typecheck calls to the prototyped function.  They do not need
     a local symbol table, and would normally ignore names of parameters.
     They might have a boolean flag or other means of remembering
     in the global symbol table that they are just a prototype, so that
     they would not trigger a redeclaration error when the definition of that
     function finally shows up.  In fact, a prototype can appear multiple
     times with no redeclaration error.
     You would think that when the function definition occurs on a
     function that has an existing prototype, it should trigger a
     typecheck on the number and type of existing parameters.  In
     C++ there is function overloading, so the story is not so simple.
-->
</dl>

<h3> Midterm Exam Review </h3>

The Midterm will cover lexical analysis, finite automatas, context free
grammars, syntax analysis, parsing, and semantic analysis.
<p>

Q: What is likely to appear on the midterm?
<p>

A: questions that allow you to demonstrate that you know
<ul>
<li> regular expressions
<li> the difference between an DFA and an NFA
<li> lex and flex and tokens and lexical attributes
<li> the %union and yylval interface between flex and bison
<li> context free grammars:
   ambiguity, factoring, removing left recursion, etc.
<li> bison syntax and semantics
<li> parse trees
<li> symbol tables
<li> semantic attributes, type checking
</ul>


<p>

Sample problems:

<ol>
<li> Write a regular expression for numeric quantities of U.S. money
     that start with a dollar sign, followed by one or more digits.
     Require a comma between every three digits, as in $7,321,212.
     Also, allow but do not require a decimal point followed by two
     digits at the end, as in $5.99
<li> Write a non-deterministic finite
     automaton for the following regular expression, an abstraction
     of the expression used for real number literal values in C.<pre>
     (d+pd*|d*pd+)(ed+)? </pre>
<li> Write a regular expression, or explain why you can't write a
     regular expression, for Modula-2 comments which use (* *) as
     their boundaries.  Unlike C, Modula-2 comments may be nested,
     as in (* this is a (* nested *) comment *)
<li> Write a context free grammar for the subset of C expressions
     that include identifiers and function calls with parameters.
     Parameters may themselves be function calls, as in f(g(x)),
     or h(a,b,i(j(k,l)))
<li> What are the FIRST(E) and FOLLOW(T) in the grammar: <pre>
     E : E + T | T
     T : T * F | F
     F : ( E ) | <b>ident</b></pre>
<li> What is the &epsilon;-closure(move({2,4},b)) in the following NFA?
     That is, suppose you might be in either state 2 or 4 at the time
     you see a symbol b: what NFA states might you find yourself in
     after consuming b?<br> (<em>automata to be written on the board</em>)
<li> 



 (20 points) (a) Explain why a compiler might be less able to recover and
continue from a lexical error than from a syntax error. (b) Explain why a
compiler might be less able to recover and continue from a syntax error than
from a semantic error.



<li> (30 points) (a) Write a regular expression (you may use Flex extended
regular expression operators) for declarations of the form given by the
grammar below. You may use the usual regular expression for C/C++ variable
names for IDENT. (b) Under what circumstances is it better to use regular
expressions, and under what circumstances is it better to use context free
grammars?

<pre>
declaration : type_specifier decl_list ';' ;
type_specifier : INT | CHAR | DOUBLE ;
decl_list : decl | decl ',' decl_list ;
decl: IDENT | '*' IDENT | IDENT '[' INTCONST ']' ;
</pre>

<p>

<li> (30 points) Some early UNIX utilities, like grep and lex, implemented a
non-deterministic finite automata interpreter for each regular expression,
resulting in famously slow execution. Why is Flex able to run much faster
than these early UNIX tools?

<p>

<li> (20 points) Perhaps the most important thing to learn in homework #2
about Flex and Bison was how the two tools communicate information between
each other. Describe this communications interface.

<p>

<li> (30 points) Perhaps the second most important thing to learn in homework
#2 was how and when to build internal nodes in constructing your syntax
tree.
<br>
(a) Describe how and when internal nodes need to
be constructed, in order for a Bison-based parser to end up with a tree that holds all leaves/terminal
symbols. (b) Under what circumstances might a new non-terminal node construction site be skipped?
(c) Under what circumstances might some of the leaves/terminal symbols not be needed later during
compilation?


<li> (40 points) Consider the following grammar for C variable declarations,
given in YACC-style syntax.  sm  stands for semi-colon. cm stands for
comma. id stands for identifier. lb stands for left square
bracket. intconst stands for integer constant. rb stands for right
square bracket.

<pre>
VD : CL T DL sm ;
CL : static | register | /* epsilon */ ;
T : int ;
DL : D | D cm DL ;
D : id | AST D | D lb intconst rb ;
</pre>

a) What are the terminal symbols? b) What are the nonterminal symbols? c) Which nonterminals have
recursive productions? d) Remove left recursive rules from this grammar if there are any.


<li>(30 points) Write C code that is error free and produces no warnings,
which performs the following tasks: a) declare a variable of type pointer to
struct token, where struct token has an integer category, a string lexeme,
and an integer lineno, b) allocate some memory from the heap large enough to
hold a struct token and point your variable at it, and c) initialize your
memory to all zero bits. You may assume “struct token” with its field
definitions, has already been defined earlier in the C file before your code
fragment.


<li> (20 points) In looking at your yydebug output, several of you noticed
that it appeared like the same terminal symbol (for example, a semi-colon)
was repeated over and over again in the output, even through sections of
parsing where no syntax error occurred. Why might the same terminal symbol
appear on the input repeatedly through several iterations of a shift-reduce
parser. (30 points) What are semantic attributes? Briefly define and give
an example of the major kinds of semantic attributes that might be used in
semantic analysis for a language such as C++.

<li> (30 points) Symbol tables play a prominent role in semantic
analysis. How are symbol tables used in type checking? Give an example, with
a brief explanation of how the symbol table is involved.


</ol>

<p>
<font size=1> <A name=30>lecture #30</A> began here</font>
<p>


<h3> CDA Midterm Exam Revised Instructions </h3>

CDA students: our CDA Associate Chair Bob Rinker went over and looked at
the NIC Testing Center, and decided it would be better for you to take the
exam on Thursday at 2:30 at the Den if possible. See Carrie Morrison there,
who will proctor your exam.  If you cannot take the exam at the Den at
2:30, the NIC Testing Center is your backup plan and the midterm can be
taken there at your appointed time; in that case, your midterm grade next
Monday might or might not include your Midterm exam grade, since I might
or might not receive the exam from them before the weekend.

<h3> Implementing Structs </h3>

Some years, CSE 423 implements classes, not structs. But some languages such
as C or VGo have structs.  How much of this is similar, and how much needs
to be different, if you had to do classes?

<ol>
<li> In C/C++, storing and retrieving structs by their label -- 
    the struct label is how structs are identified.
     In Go/VGo, the reserved word <code>type</code> is more like
     a C/C++ <code>typedef</code>.
    If you were doing C/C++-style struct labels,
    the labels can be keys in a separate hash table, similar to the global
    symbol table.  You can put them in the global symbol table so long as
    you can tell the difference between them and regular symbol names, for
    example by storing them as "struct foo" (not a legal name) instead of
    just storing them as "foo".

<li> You have to store fieldnames and their types, from where the struct is
    declared. This is conceptually a new local scope. In a production language
    you would use a hash table for each struct, but in CSE 423 a link list
    would be OK as an alternative. Then again, if you've built a hash table
    data type for the global and local symbol tables, why not just use it
    for struct field scopes?

<li> You have to use the struct's type information to check the validity of
    each dot operator like in <code>rec.foo</code>.  To do this you'll have
    to lookup <code>rec</code>
    in the symbol table, where you store rec's type.  rec's type must be
    a struct type for the dot to be legal, and that struct type should
    include the hash table or link list that gives the names and types of
    the fields -- where you can lookup the name <code>foo</code> to find
    its type.
</ol>


<h3> Type Checking Example </h3>

Work through a type checking example for the function call to
<code>foo()</code> shown in <b>bold</b> in the example below.
This is a C language
example. The Go/VGo would be pretty similar; how much would be
different?

<p>

<table border
<tr><th> C <th> Go
<tr><td>
<pre>
int foo(int x, string y) {
   return x
   }

int main()
{
   int z
   <b>z = foo(5, "funf")</b>
   return 0
}
</pre>
<td>
<pre>
func foo(x int, y string) int {
   return x
   }

func main() int {
   var z int
   <b>z = foo(5, "funf")</b>
   return 0
}
</pre>
</table>

<p>

After parsing, the symbol table (left) and syntax tree for the call (right)
looks like:

<p>

<img src="typechk_args.png">
<p>

The typecheck of this tree proceeds as a post-fix traversal of the tree.
Type information starts from leaves, which either know their type if they
have one (constants) or look up their type in the symbol table (identifiers).
Can you hand-simulate this in the correct order, filling in .type fields for
each tree node?


<h3> Need Help with Type Checking? </h3>

<ul>
<li> Implement the C Type Representation given previously
<li> Read the Book
<li> What OPERATIONS (functions) do you need, in order to check
     whether types are correct?  What parameters will they take?
</ul>

<!--
<h3> g0 Language: what-all is under-specified? </h3>

We've had various reasonable requests for clarification, and corrections
needed for examples which were translated incompletely from C++. Are there
any for which you haven't got a straight answer yet?

<dl>
<dt> no need for prototypes
<dd> prototypes are a concession to single-pass
     compilers run on slow low-memory computers in the 1970's and 80's.
     Your g0 compiler is allowed to use a "big-inhale" model of compilation
     in which all source code is available and symbol tables can be fully
     populated before type checking.
<dt> switch to JSON syntax for list constructors
<dd> Yeah, I admit I like square bracket list constructors.
</dl>
-->

<h3> Type Checking Function Calls </h3>

<ul>
<li> at every node in our tree, we build a .type field
<li> Probably logically two separate jobs:
<ul>
<li> Build types for declarations, insert them into symbol table(s).
      Performed during the declarations pass of semantic analysis.
<li> Build types for expressions, lookup symbols from symbol table(s)
      Performed during the typecheck pass of semantic analysis.
</ul>

<li> For the typecheck pass, a recursive function, typecheck(n), traverses the
     tree sticking types into expression nodes.
<li> you may choose to write a helper function check_types(OPERATOR,
operandtype, operandtype) to do the heavy lifting at each node
<li> What will type checking a function call need?
<li> Can we just check the type of the symbol against the type of the call
expression?
<li> Type of symbol: constructed as per last lecture. In symbol table.
<li> Type of call expression (built within expression part of grammar), SANS
     return type.
<li> Type check verifies it and replaces it with return type.
</ul>

<pre>
void typecheck(nodeptr n)
{
   if (n==NULL) return;
   for(int i; i &lt; n-&gt;nkids; i++) typecheck(n->child[i]);
   switch(n->prodrule) {
   ...
   case POSTFIX_EXPRESSION_3: {
      n->type = check_types(FUNCALL, n->child[0]->type, n->child[2]->type);
      }
   }
}

...

typeptr check_types(int operand, typeptr x, typeptr y)
{
   switch (operand) {
   case  FUNCALL: {
      if (x->basetype != FUNC)
         return type_error("function expected", x);
      if (y->basetype != TUPLE)
         return type_error("tuple expected", y);
      if (x->u.f.nparams != y->u.t.nelems)
         return type_error("wrong number of parameters", y);

      /*
       * for-loop, compare types of arguments
       */
      for(int i = 0; i < x->u.f.nparams; i++)
         if (check_types(PARAM, x->u.f.params[i], y->u.t.elems[i]) ==
	     TYPE_ERROR) return TYPE_ERROR;
      /*
       * If the call is OK, our type is the function return type.
       */
      return x->u.f.returntype;
      break;
      }
   }
}
</pre>


<h3> Building Type Information </h3>

<ul>
<li> So far, the main discussion and pseudo-code for populating
     the symbol table that has been presented was for constructing
     tuple types for parameter lists, as needed for the type-check
     example that we then worked on.
<li> More generally, how do we construct type representations
     from syntax trees for other kinds of declarations?
<li> If we had time, we could stand to do a more concrete example of
     populating the symbol table
</ul>

<p>

<!--<img src="c_type_rep.png" width=1200>-->



<h3> Semantic Analysis and Classes </h3>

What work is performed during the semantic analysis phase, to support classes?

<ul>
<li> Build class-level symbol tables
<li> Within class member functions, three-level symbol lookup
     (local first, then class, then global).
<li> In the implementation of <code>x.y</code> (and <code>x->y</code>
     in languages that have it),
     lookup <code>y</code> within <code>x</code>'s type's symbol table,
     using privacy rules.
<li> ...what are the other issues for semantic analysis of objects in
     our language, as you understand it?
</ul>



<h3> How to TypeCheck Square Brackets </h3>

This is about the grammar production whose right-hand side is:
<pre>
postfix_expression LB expression RB
</pre>

<ol>
<li> recursively typecheck $1 and $3 ... compute/synthesize their .type fields.
<li> What type(s) does $1 have to be?  LIST/ARRAY (or TABLE, if a table type exists)
<li> What type(s) does $3 have to be?  INTEGER (or e.g. STRING/ARRAY OF CHAR, for tables)
<li> What is the result type we assign to $$?  Lookup the element type from $1
</ol>

Pseudo-code fragment.  Goal is to find errors and determine n's type.
<pre>
int typecheck_array(struct tree *n)
{
   struct tree *n1 = n->child[0];
   struct tree *n3 = n->child[2];
   /*
    * recursively typecheck children.
    */
   if (typecheck(n1) == TYPE_ERROR ||
       typecheck(n3) == TYPE_ERROR) {
      n->type = TYPE_ERROR;
      return TYPE_ERROR;
      }
   /*
    * Given the children's types, see whether n1[n3] is legal
    */
   switch (n1->type->basetype) {
   case LIST:
      /* ... insert list typecheck code here */
      break;
   case TABLE:
      /* ... insert table typecheck code here */
      break;
   default:
      bad_type("list or table expected in [] operation", n1);
      return TYPE_ERROR;
      }
}
</pre>



<h3>Typechecking Square Brackets Example, cont'd </h3>

Where we left off was:

<pre>
   /*
    * Given the children's types, see whether n1[n3] is legal
    */
   switch (n1->type->basetype) {
   case LIST:
      /* check if n3's type is integer */
      if (n3->type->basetype != BT_INTEGER) {
          bad_type("list must be subscripted with integers", n3);
	  return TYPE_ERROR;
          }
      /* assign n's type to be n1's element type */
      n->type = n1->type->u.l.elemtype;
      break;
   case TABLE:
      /* check if n3's type is n1's index type */
      if (n3->type->basetype != n1->type->u.t.indextype->basetype) {
          bad_type("table must be subscripted with its declared index type", n3);
	  return TYPE_ERROR;
         }
      /* assign n's type to be n1's element type */
      n->type = n1->type->u.t.elemtype;
      break;
   default:
      bad_type("list or table expected in [] operation", n1);
      /* what does n's type field hold, then */
      n->type = /* ?? */
      return TYPE_ERROR;
      }
</pre>

<br>
<br>
<br>
<br>
<br>
Did we get something like:

<pre>
      if (n3->type->basetype != INTEGER) {
         bad_type("index must be integer in [] operation", n3);
         }
      n->type = n1->type->elemtype;
</pre>
and
<pre>
      if (n3->type->basetype != n1->type->indextype) {
         bad_type("index type must be compatible in [] operation", n3);
         }
      n->type = n1->type->elemtype;
</pre>

<h3> What other type checking examples should we be doing? </h3>

So far in lecture we have seen possibly-too-handwavy examples of
<ul>
<li> Operators like x + y
<li> Parameters for a function call f(x,y) where tuple types must be checked
<li> Subscript operator x[y]
</ul>

What else would help you wrap your brains around type checking?

<!--
<h3> Mailbag </h3>

<dl>
<dt> When putting together my grammar for Homework 2, I didn't implement any
postfix expressions. Instead my grammar rules for a list access looks
something like this:

<pre>
ArrayAccess: IDENTIFIER '[' Expression ']' ;
</pre>

i.e. I only allow brackets after an identifier, so something like
<code>function_that_returns_list()[1]</code> is invalid.
Will I need to implement postfix expressions, so that expressions
like that one are valid?
<dd> While in real languages such expressions are supported, in g0
tests will only get as complicated as those that come
up in CS120. I don't think function returns are subsequently
subscripted, so f()[i] is out, and we have ruled out L[i][j] even
though CS120 does that much. The main postscript expressions that
might be chained together involve the dot operator, so x.y.z or maybe
L[i].x[j] for example.

</dl>
-->

<p>
<font size=1> <A name=midtermsolutions>lecture #m</A> began here</font>
<p>



<h3> Midterm Exam Discussion </h3>

<p>
<font size=1> <A name=31>lecture #31</A> began here</font>
<p>

<h3> HW#3 Discussion </h3>

<ul>
<li> As of 10/22, there are 17 submissions out of 29 enrollees.
     I am working vigorously on grading them.  Maybe by tomorrow.
<li> I will update, if possible, midterm grades to reflect HW#3;
     at that point those who have a decent HW#3 score may see a boost
     relative to those who do not. Midterm grades are not used for
     anything, they are merely advisory.
<li> If you need assistance with HW, please make an appointment and come visit.
     I can also do Zoom appointments. Screen sharing is great.
<li> I am not very concerned about "lateness"
<li> I am concerned about preserving enough time for you to finish
     semantic analysis and write a code generator.
<li> <A href="hw4.html">HW#4</A> is due in a couple weeks.
</ul>

<h3>"Mailbag"</h3>

<dl>
<dt> I am having a problem with a segmentation fault.  Can you help?
<dd> When sticking print statements into your program no longer cuts it,
     your two best hopes are GDB and Valgrind.  Yes, I can help.
<ul>
<li> the first thing I will want to see is your valgrind run on your segfault
<li> the second thing I am going to want to see is your open gdb session
     at the point of the segfault, with the "where" output, and the "print"
     command run on each variable on the line where the segfault occurred
</ul>

<dt>
The problem is, there's just so much to type check (I mean, literally
everything has a type!); can you suggest any ways to go about this in a
quicker manner, or anything in the aforementioned list that could be
pruned/ignored?
<dd>
<ul>
<li> Not literally. The expression grammar.
     And the subset of declarations that you must support.
<li>
     The type checking will typically not happen on $$=$1 rules, so
     the expression grammar has around 18 productions where type checking
     goes.
<li> Feel free to rewrite the grammar to reduce the number of productions
     where you do type checking.
<li> Type checking rules for like-minded operators are identical; use that.
<li> Write helper functions, share common logic.
</ul>


<dt> Hey, look how easy it is to modify our tree-print function to instead
generate a .dot file which the <code>dot(1)</code> program on cs-course42
can turn into a tree that looks like this:
<p>

<img src="am-tree.png">
<p>

[Student shows <A href="graph.c">~110 lines of C code</A> that writes
two .dot files with different levels of detail via a traversal function
similar to your HW#2 tree printer.]

<dd> That is pretty darned awesome, thank you. Folks are encouraged to check
out <A href="https://linux.die.net/man/1/dot"><code>dot(1)</code></A>.
This kind of tree could be extended with type info that might be really
useful for debugging HW#4!

</dl>

<h3>Another Typecheck Example</h3>

Consider the following small program.

<table>
<tr><th> C <th> Go
<tr><td>
<pre>
int fib(int n)
{
  if (n &lt; 3) { return 1; }
  return fib(n-2) + fib(n-1);
}
void main()
{
   int i;
   i = 0;
   while (i &lt; 5) {
      write(fib(i));
      i += 1;
      }
}
</pre>
<td>
<pre>
package main
import "fmt"
func fib(n int) int {
  if n &lt; 3 { return 1 }
  return fib(n-2) + fib(n-1)
}
func main() {
   var i int
   for i &lt; 7 {
      fmt.Println(fib(i))
      i += 1
      }
}
</pre>
</table>

<ul>
<li> given a parse tree, we want to compute the types of all
     symbols and expressions.
<li> You have exactly one hammer to use: tree traversal
<pre>
   void visit(struct tree *n) {
      /* pass inherited attribs into children */
      /* visit children */
      /* make use of synthesized attribs in children */
   }
</pre>
<li> Previous Sample Tree traversal code described populating symbol tables.
     Let's simulate/visualize that code on the tree for this program.
<li> Previous Sample Tree traversal code described type checking.
     Let's simulate/visualize that code on the tree for this program.
</ul>

<p>
<font size=1> <A name=32>lecture #32</A> began here</font>
<p>

<h3> HW#3 Status </h3>

<ul>
<li> First batch graded. Later submitters will be graded real soon.
<li> Many in the first batch will want to resubmit, with fixes
<li> Run the test cases yourself on lovecraft.
     If I didn't give you points for a test case that runs OK for you,
     I want to know about it so I can correct your grade.
<li> Some folks confused about redeclarations: a global can be redeclared
     in a local scope. You can't have the same symbol defined within the
     same (global or local) scope.
<li> Ideas regarding built-ins.  Do functions like Println really have to
     be in a separate (package fmt) symbol table?
</ul>

<h3> <code>fib()</code> Type Checking Example, cont'd </h3>

For what it's worth, I did work on gearing up to use the student-suggested
parse tree generator via the <code>dot</code> program.
<ul>
<li> official go.y was tweaked with some updates
<li> Student's <A href="graph.c">graph.c</A> hacked a bit for the purpose
<li> But between grading and other obligations, I have not got it all wired
     up into my VGo reference implementation yet.
</ul>

<p>
<font size=1> <A name=33>lecture #33</A> began here</font>
<p>

<h3> Mailbag </h3>
<dl> 
<dt> When creating an array VGo allows for the following:
<pre>
   var x []int 
</pre>

What should the array size be when this happens? Is this supposed to be an
all-knowing infinite array or an empty array?

<dd> I think we discussed this in class last time -- this syntax is in Go
but not in VGo.

</dl>


<h3>From Type Checking on Towards Code Generation</h3>

<ul>
<li> We may yet want to do a larger example of type checking.
<li> It is fair game for you to ask more questions as you work on it.
<li> Main reason to compute all this type information was: we need it
     for code generation.  And we need it because different types are
     different sizes and call for different machine instructions.
<li> Fancy words for adding information to the syntax tree (and symbol tables,
     which are mainly used so you can look up things in the syntax tree):
     decoration, annotation... basically, it is a fundamental task of computing
     to turn <em>data</em> into <em>information</em> by analyzing it
     and adding value.
</ul>

<h3>Run-time Environments </h3>

<dl>
<dt>How does a compiler (or a linker) compute the addresses for the various
instructions and references to data that appear in the program source code?
<dd>To generate code for it, the compiler has to "lay out" the data as it will
be used at runtime, deciding how big things are, and where they will go.
</dl>

<ul>
<li> Relationship between source code names and data objects during execution
<li> Procedure activations
<li> Memory management and layout
<li> Library functions
</ul>





<h4> Scopes and Bindings </h4>

<ul>
<li> Variables may be declared explicitly or implicitly in some languages

<li> Scope rules for each language determine how to go from names to
     declarations.
<li> Each use of a variable name must be associated with a declaration.
</ul>

This last item is generally done via a symbol table. In most compiled
languages it happens at compile time (in contrast, for example ,with LISP).

<h4> Environment and State </h4>

Environment maps source code names onto storage addresses (at compile time),
while state maps storage addresses into values (at runtime).  Environment
relies on binding rules and is used in code generation; state operations
are loads/stores into memory, as well as allocations and deallocations.
Environment is concerned with scope rules, state is concerned with things
like the lifetimes of variables.
<p>


<!--
<h3> Thoughts on the Predefined Classes </h3>

Tables 1.4 and 1.5 of the 120++ manual present Dr. Soule's reference
on built-in classes such as string, ifstream, and ofstream.

One way to implement these would be to write actual source code for (the
     tiny subset of) these classes that we need, and feed it into your
     compiler as if it were an #include.  Another way would be to just
     execute code that performs the corresponding symbol table inserts and
     type constructors.

<pre>
class ifstream {
   public:
      ignore();
   }
class ofstream {
   }
</pre>
-->

<!--
<h3> Semantics Things Checked </h3>

<dl>
<dt> extern
<dd> this word does not appear in 120++
<dt> static
<dd> this word does not appear in 120++
<dt> default constructor
<dd> this is used (without discussion) in an example in 120++
     Your semantic rule would be: if no constructor is present,
     insert a default constructor into the symbol table for a class.
<dt> delete
<dd> this is used in a trivial way on a simple pointer variable.
     Your typecheck rule would be: its operand must be a pointer.
</dl>
-->


<h3> Runtime Memory Regions </h3>

Operating systems vary in terms of how the organize program memory
for runtime execution, but a typical scheme looks like this:

<table border>
<tr><th>code
<tr><th>static data
<tr><th>stack (grows down)
<tr><td>heap (may grow up, from bottom of address space)
</table>

The code section may be read-only, and shared among multiple instances
of a program.  Dynamic loading may introduce multiple code regions, which
may not be contiguous, and some of them may be shared by different programs.
The static data area may consist of two sections, one for "initialized data",
and one section for uninitialized (i.e. all zero's at the beginning).
Some OS'es place the heap at the very end of the address space, with a big
hole so either the stack or the heap may grow arbitrarily large.  Other OS'es
fix the stack size and place the heap above the stack and grow it down.


<h4> Questions to ask about a language, before writing its code generator</h4>

<ol>
<li> May procedures be recursive? (Duh, all modern languages...)
<li> What happens to locals when a procedure returns? (Lazy deallocation rare)
<li> May a procedure refer to non-local, non-global names?
     (Pascal-style nested procedures, and object field names)
<li> How are parameters passed? (Many styles possible, different
     declarations for each (Pascal), rules hardwired by type (C)?)
<li> May procedures be passed as parameters?  (Not too awful)
<li> May procedures be return values? (Adds complexity for non-local names)
<li> May storage be allocated dynamically (Duh, all modern languages...
     but some languages do it with syntax (new) others with library (malloc))
<li> Must storage by deallocated explicitly (garbage collector?)
</ol>




<!--
<h4>Mailbag </h4>

<dl>
<dt> Regarding pointers, are we only supporting char *? Or are we supporting
all pointer types, like int*, double*? I also wasn't sure if we were
supporting char * as a return type for functions, like char *func().

<dd> Professor Soule uses pointer types like <code>FILE *</code>, but
we are skipping C stdio in favor of a small subset
of C++ iostreams.   When professor Soule explcitly introduces
pointer types he uses int *ptr, and ptr = &x; but these are in
artificial toy fragments. The program example of chapter 7, however,
declares a 2D array of pointers to objects (i.e. class instances),
and uses a pointer to object to swap elements within the 2D array.
Later on he explicitly uses object pointer to implement linked lists.
<blockquote>
Your official charge is to support pointers, except you do not have
to support pointer arithmetic (p + i). Unofficially it seems that
you could get away without supporting pointers to types other than
char and class instances, but I am not sure that will save you much.
</blockquote>

</dl>
-->

<p>
<font size=1> <A name=34>lecture #34</A> began here</font>
<p>

<h3> Mailbag </h3>
<dl>
<dt>I'm still working on hw3 since I can't get my assignment 3 working clean
enough for hw4. I know thet we are half way through hw4 time. So what should
I do? I do not wanna fail this class and its not like I haven't been putting
lots of effort into it.
<dd> You are graded relative to your peers, and many
of your peers are also far behind. If you have been putting lots of effort,
and you are getting instructor help when you get stuck, you should be able
to make progress on your HW#3. This week is your last week to decide
whether to drop, and possibly try Dr. Heckendorn next semester, or whether
to stay in.  If you stay in, and give it your best shot, odds are good
that relative to your peers, you will be OK.

</dl>

<!--

<dl>
<dt> You talked about promotion from <code>int</code> to <code>double</code>.
     Do we ever have to demote from  <code>double</code> to <code>int</code>?
<dd> What should happen if the g0 program contains:
<pre>
   int i
   double r
   r = 27.0
   i = 3.1415 * r * r // error, no autodemotion
   i = (int) (3.1415 * r * r) // error, no typecasting
</pre>
No, we do not have to support type demotion in g0.
</dl>
-->

<h3> "Modern" Runtime Systems </h3>

Modern languages' runtime systems have extra properties compared with
that of a traditional language like C. Here are a few examples.
<p>

<dl>
<dt> A "self" or "this" in every method call.
<dd> Possibly implemented via a dedicated register, or an implicit,
     extra parameter.  Either way, OO slightly alters the activation record.

<dt> Garbage collection.
<dd> Automatic (heap) storage management is one of the most important features
     that makes programming easier.
The Basic problem in garbage collection is: given a piece of memory, are there
any pointers to it?  (And if so, where exactly are all of them please).
Approaches:

<ul>
<li> reference counting
<li> traversal of known pointers (marking)
	<ul>
	<li> copying (2 heaps approach)
	<li> compacting (mark and sweep)
	<li> generational
	</ul>
<li> conservative collection
</ul>
Note that there is a fine 
<A href="http://www.cs.virginia.edu/~cs415/reading/bacon-garbage.pdf">
paper</A> presenting a "unified theory of garbage collection</A>

<dt> Reflection.
<dd> Objects can describe themselves, via a set of member functions.
     This plays a central role in Visual GUI builders, IDE's,
     component architectures and other uses.

<dt> Just-in-time compilation.
<dd> A virtual machine ("byte code") execution model...can be augmented
     by a compiler built-in to the VM that converts VM instructions
     to native code <em>for frequently executed methods or code blocks</em>.

<dt> Security model.
<dd>  Modern languages may attempt to guarantee certain
     security properties, or prevent certain kinds of attacks.
</dl>

For what its worth, goal-directed programs in languages such as Unicon have
an activation tree each instant, due to suspended activations that may be
resumed for additional results.  The lifetime view is a sort of
multidimensional tree, with three types of nodes.

<p>

<h4>Activation Records</h4>

Activation records organize the stack, one record per method/function call.

<p>

<table border>
<tr><td><td>return value
<tr><td><td>parameter
<tr><td><td>...
<tr><td><td>parameter
<tr><td><td>previous frame pointer (FP)
<tr><td><td>saved registers
<tr><td><td>...
<tr><td>FP--&gt;<td>saved PC
<tr><td><td>local
<tr><td><td>...
<tr><td><td>local
<tr><td><td>temporaries
<tr><td>SP--&gt;<td>...
</table>

<p>

At any given instant, the live activation records form a chain and
follow a stack (push/pop) discipline for allocation/deallocation.
Since each activation record contains a pointer to the previous one,
it is really pretty much a linked list we are talking about, with a
base pointer register holding the pointer to the top of the stack.
<p>

Over the lifetime of the program, all these activation records,
if saved, would form a gigantic tree.  If you remember all
prior execution up to a current point, you have a big tree in which
its rightmost edge are live activation records, and the non-rightmost
tree nodes are an execution history of prior calls. (Program Monitoring
and Visualization could allow us to depict and inspect this history tree.)

<p>

<!--<h3> Reference Implementation Files </h3>

Here are some files containing example code you may use in your compiler
project.  Note that understanding and using someone else's code may require
just as much or more work than writing it yourself, and that no warranty
is expressed or implied: you are responsible for your compiler working,
even if it uses code from these files and it turns out they have a bug!

<ul>
<li> <A href="hw4/main.c">main.c</A>
<li> <A href="hw4/tree.h">tree.h</A>
<li> <A href="hw4/type.h">type.h</A>
<li> <A href="hw4/sym.h">sym.h</A>
<li> <A href="hw4/sym.c">sym.c</A>
<li> <A href="hw4/semantic.c">semantic.c</A>
</ul>-->


<!--
<h3> Reduction in Typecheck Work </h3>

<dl>
<dt> 120++ does not use pointer arithmetic
<dd> so no pointer + integer.
<dt> 120++ does not mention any type promotion
<dd> so no char + integer or integer + double.
</dl>


<h3> On Type-checking of &lt;&lt; </h3>

Consider

<pre>
   cout &lt;&lt;"Player"&lt;&lt;current_player&lt;&lt;endl;
</pre>

We deduce:
<ul>
<li> &lt;&lt; requires a stream on its left side
<li> &lt;&lt; accepts string, char *, int, or double on its right side
       (but not: ... what?)
<li> &lt;&lt; is left-associative
<li> &lt;&lt; produces a value of type ifstream as its result
</ul>
-->




<h3> Variable Allocation and Access Issues</h3>

Given a variable name, how do we compute its address?
<dl>
<dt> globals
<dd> easy, symbol table lookup... once we have figured out how to
     allocate addresses in a process that does not exist yet.
<dt> locals
<dd> easy, symbol table gives offset in (current) activation record
<dt> objects
<dd> Is it "easy"? If no virtual semantics*, symbol table gives offset in
     object, activation record has
     pointer to current object in a standard location. (<em>This is the
     reason C++ does not use virtual semantics by default</em>.)
     <br>
     For virtual semantics, generate code to look up offset
     in a table at runtime, based on the current object's type/class.
<dt> locals in some enclosing block/method/procedure
<dd> ugh.  Pascal, Ada, and friends offer their own unique kind of pain.
     Q: does the current block support recursion?  Example: for procedures
     the answer would be yes; for nested { { } } blocks in C the answer
     would be no.
<ul>
<li> if no recursion, just count back some number of frame pointers based
     on source code nesting
<li> if recursion, you need an extra pointer field in activation record
     to keep track of the "static link", follow static link back some
     # of times to find a name defined in an enclosing scope
</dl>

<h3> *What are "Virtual" Semantics? </h3>

C++ is (just about) the only major object-oriented language
that has to compete with C in the performance arena. For this
reason, it chose early on to be different than every other
OO language. By default, if you are working on a class Foo
object, you can find Foo's member variables and call Foo's
methods by compile-time-determinable memory offsets and
addresses.  So a class is basically no worse than a struct to
generate code for.
<p>

If you say the keyword "virtual" in C++, or if you use just
about any other OOP language, subclassing and interfacing
semantics mean that the address referred to by o.x or o.m()
has to be calculated at runtime by looking up o's actual
class, using runtime type information.





<h3> Sizing up your Regions and Activation Records </h3>

Add a size field to every symbol table entry. Many types are not required
for your project but we might want to discuss them anyhow.<br>

<ul>
<li> The size of chars is 1. We could make them use an alignment of 8,
     but then arrays of char would be all...wrong.<br>
<li> The size of integers is 8 (for x86_64; varies by CPU).<br>
<li> The size of reals is... 8 (for x86_64 doubles; varies by CPU).<br>
<li> The size of strings is... 8? (varies by CPU and language)
<li> The size of arrays is (sizeof (elementype)) * the number of elements.
      In static languages.
   The size of arrays/lists in dynamic languages might be more complicated.
<li> what about sizes of structs/objects?  They are the size of the sum of
     their members... after adding in padding to meet alignment requirements.
</ul>
<p>

You do this sizing up once for each scope.  The size of each scope is the
sum of the sizes of symbols in its symbol table.

<p>
<font size=1> <A name=35>lecture #35</A> began here</font>
<p>


<A name="codegen">
<h3> Intermediate Code Generation </h3>
</A>

Goal: list of machine-independent instructions for each procedure/method
in the program.  Basic data layout of all variables.
<p>

Can be formulated as syntax-directed translation
<ul>
<li> add new semantic attributes where necessary.
     For expression E we might have
<dl>
<dt> <code>E.addr</code>
<dd> the location that at run-time will hold the value of E
<dt> <code>E.icode</code>
<dd> the sequence of intermediate code statements evaluating E.
</dl>
</ul>
     How does the compiler talk at compile-time about addresses that
     will exist at runtime?
<ul>
<li>  Option (A): leave everything as names for now.  "declare" the names
     in intermediate code, specifying which memory region they live in, and
     how many bytes big they are. assume an assembler will convert names to
     addresses during final code generation.
<li> Option (B): designate only four names for the four memory regions:
     code, global/static, stack, and heap. Specify all addresses as offsets
     in one of those regions. For first two, offsets are relative to a base
     pointer that is the start of the two region. For the latter two, offsets
     are relative to a register (current activation record/base pointer, and
     current "this/self" object pointer).
</ul>
</ul>

<h3> Helper Functions for Intermediate Code Generation </h3>

<ul>
<li> new helper functions, e.g.
<dl>
<dt><code>newtemp(n)</code>
<dd> returns a new temporary variable each time it is called.
     Parameter <code>n</code> could be #words, or #bytes. Let's say it
     is the number of 8-byte words.  Default is
     one word (8 bytes), always out of the local region, on the stack.
<dt><code>newlabel()</code>
<dd> returns a new label each time it is called.  A label is a name for
     a code region address, but for practical purposes newlabel() could
     just return a unique integer i by incrementing a counter each time,
     or string "L"||i (e.g. "L29") each time it is called.
</dl>
<li> actions that generate intermediate code formulated as semantic rules
</ul>

These helper functions might really be best described
as returning "addresses". Intermediate code addresses
are described down below.

<h3>Semantic Rules for Intermediate Code Generation</h3>

Code for evaluating traditional expressions can be synthesized
via bottom-up traversal.  If the location where an expression's
computed result can be read is called <code>addr</code> and the
sequence of intermediate code instructions that compute that
value is called <code>icode</code>, you can postulate the
following semantic rules. This is a simplifying abstraction of
what would be needed for an entire modern programming language
expression grammar, and your non-terminal names might be different.
Operator ||| is a list concatenation.

<p>

<table border>
<tr><th>Production</th><th>Semantic Rules</th></tr>

<tr>
<td>Assignment : IDENT '=' AddExpr  <td>
<pre>Assignment.addr = IDENT.addr
Assignment.icode = AddExpr.icode |||
                   gen(ASN, IDENT.addr, AddExpr.addr)</pre>
<tr>
<td> AddExpr : AddExpr<sub>1</sub> '+' MulExpr <td>
<pre>AddExpr.addr = newtemp()
AddExpr.icode = AddExpr<sub>1</sub>.icode ||| MulExpr.icode |||
                gen(ADD,AddExpr.addr,AddExpr<sub>1</sub>.addr,MulExpr.addr)</pre>
<tr>
<td>AddExpr : AddExpr<sub>1</sub> '-' MulExpr <td>
<pre>AddExpr.addr = newtemp()
AddExpr.icode = AddExpr<sub>1</sub>.icode ||| MulExpr.icode |||
                gen(SUB,AddExpr.addr,AddExpr<sub>1</sub>.addr,MulExpr.addr)</pre>
<tr>
<td>MulExpr : MulExpr<sub>1</sub> '*' UnaryExpr <td>
<pre>MulExpr.addr = newtemp()
MulExpr.icode = MulExpr<sub>1</sub>.icode ||| UnaryExpr.icode |||
                gen(MUL,MulExpr.addr,MulExpr<sub>1</sub>.addr,UnaryExpr.addr)</pre>
<tr>
<td>MulExpr : MulExpr<sub>1</sub> '/' UnaryExpr <td>
<pre>MulExpr.addr = newtemp()
MulExpr.icode = MulExpr<sub>1</sub>.icode ||| UnaryExpr.icode |||
                gen(DIV,MulExpr.addr,MulExpr<sub>1</sub>.addr,UnaryExpr.addr)</pre>
<tr>
<td>UnaryExpr : '-' UnaryExpr<sub>1</sub> <td>
<pre>UnaryExpr.addr = newtemp()
UnaryExpr.icode = UnaryExpr<sub>1</sub>.icode |||
                  gen(NEG,UnaryExpr.addr,UnaryExpr<sub>1</sub>.addr)</pre>
<tr>
<td>UnaryExpr : '(' AddExpr ')' <td>
<pre>UnaryExpr.addr = AddExpr.addr
UnaryExpr.icode = AddExpr.icode</pre>
<tr>
<td>UnaryExpr : IDENT <td>
<pre>UnaryExpr.addr = IDENT.addr
UnaryExpr.icode = emptylist()</pre>
</table>

<A name="tac">
<h4> Three-Address Code </h4>
</A>

Basic idea: break down source language expressions into simple pieces that:
<ul>
<li> translate easily into real machine code
<li> form a linearized representation of a syntax tree
<li> allow us to check our own work to this point
<li> allow machine independent code optimizations to be performed
<li> increase the portability of the compiler
</ul>

You can literally just make up this intermediate code file format. It
should be human readable and resemble assembler code.

<p>

<b>Instructions:</b> with the exception of immediate mode, operands are addresses and
instructions implicitly dereference values in memory located at those addresses.
Words are understood to be a 64-bit size unit. Offsets are in bytes (nwords * 8).

<p>

<table>
<tr><th>opcode/mnemonic<th>C equivalent</th><th> description
<tr><td><code>ADD,SUB,MUL,DIV</code><th>x = y <em>op</em> z<td> store result of binary operation on y and z to x
<tr><td><code>NEG</code><th>x = -y </th><td> store result of unary operation on y to x
<tr><td><code>ASN</code><th>x = y </th><td> store y to x
<tr><td><code>ADDR</code><th>x = &y </th><td> store address of y to x
<tr><td><code>LCON</code><th>x = *y </th><td> store contents pointed to by y to x
<tr><td><code>SCON </code><th>*x = y </th><td> store y to location pointed to by x
<tr><td><code>GOTO</code><th>goto L </th><td> unconditional jump to L
<tr><td><code>BLT,BLE,BGT,BGE</code><th>if (x <em>rop</em> y) goto L </th><td> test relation and conditional jump to L
<tr><td><code>BIF</code><th>if (x) goto L </th><td> conditional jump to L if x==0
<tr><td><code>BIFN</code><th>if (!x) goto L </th><td> conditional jump to L if x!=0
<tr><td><code>PARM</code><th>param x </th><td> store x as a parameter
<tr><td><code>CALL</code><th>call p,n,x </th><td> call procedure p with n words of parameters, store result in x
<tr><td><code>RET</code><th>return x </th><td> return from procedure, use x as the result
</table>
<p>

<b>Declarations (Pseudo instructions):</b>

<p>

<table>
<tr><th>declaration<th>description
<tr><td><pre>glob x,n &nbsp;&nbsp;&nbsp;</pre></td><td>declare a global named x that has n words of space
<tr><td><pre>proc x,n1,n2</pre></td><td>declare a procedure named x with n1 words of parameter space and n2 words of local variable space
<tr><td><pre>loc x,n</pre></td><td>use name x to refer to offset n in the local region (the procedure frame);
replaces any prior definiton of x that may exist.
<tr><td><pre>lab L<sub>n</sub></pre></td><td>designate that label <code>L<sub>n</sub></code> refers to the next instruction
<tr><td><pre>end</pre></td><td>declare the end of the current procedure
</table>

<p>
<font size=1> <A name=36>lecture #36</A> began here</font>
<p>
<h3> Mailbag </h3>

<dl>
<dt> How do I get started on code generation?
<dd> Start at the leaves, a.k.a. basis cases.
<ul>
<li>     Fill in attributes, possibly one at a time.
<li>     For example, assign .addr values for everything.
<li>     Allocate all your labels and temporary variables
<li>     Assign .true and .false fields in your condition exprs
<li>     You can do all this in 1, 2, or 3 or more tree traversals
</ul>     
       After you have done these things (you may need to print trees
       that show), you are ready to start allocating .icode

</dl>


<h3>TAC for Composites/Containers and Object Oriented Code</h3>

<ul>
<li> Arrays and structs hold multiple values.
<li> the address of a value is computed as an offset from a base
address for the entire composite object.
<li> One can use the existing TAC instructions, by
loading a base address explicitly using ADDR and then performing explicit
arithmetic on it.
<li> Or one can add new TAC instructions as needed e.g. for array, struct,
    or map objects.
</ul>

<p>
The sketchiness of the following table is pretty good evidence that we are
just making this up as we go along.

<p>

<table>
<tr><th>mnemonic<th>equivalent<th>description
<tr><td><pre>MEMBER</pre><th>x = y.z</th><td>lookup field named z within y, store address to x
<tr><td><pre>NEW</pre><th>x = new Foo,n<td>create a new instance of class named x, store
address to x.<br> Constructor is called with n parameters (previously pushed
on the stack).
<tr><td><pre>class</pre><th>class x,n1,n2<td>pseudoinstruction to declare a class named x with n1 bytes of class variables and n2 bytes of class method pointers
<tr><td><pre>field</pre><th>field x,n<td>pseudoinstruction to declare a field named x at offset n in the class frame
</table>

<p>

Note: no new instructions are introduced for a member function call.  In a
non-virtual OO language, a member function call <code>o.m(x)</code> might be
translated as <code>Foo__m(o,x)</code>, where <code>Foo</code> is
<code>o</code>'s class.  Other translation schemes are possible.


<h3> Variable Reference, Dereference, and Assignment Semantics </h3>

Given, say, x having a value of 2, what does the following compute?

<pre>
   int y = x + (x = x + 1) + x;
</pre>

OK, what about

<pre>
   int y = x + x + (x = x + 1) + x;
</pre>

In order to get the answers right, one has to understand the moment at which
a variable reference is computed versus the moment at which it is dereferenced
to obtain its value, versus the moment at which it is assigned a new value.
<p>

Operator precedence (and parentheses) determine what order the expressions
are evaluated.  But evaluating something as simple as
<em>expr</em>+<em>expr</em> can give surprise results if variables' values
can change between their reference construction and dereferencing operation.



<h3> Tree Traversals for Moving Information Around </h3>

Like with semantic analysis, the intermediate code generation game is
largely one of moving information around in the tree.

<ul>
<li> NOT a "blind" traversal that does the same thing at each node.
<li> often a switch statement pre- or post- the traversal of children
<li> switch cases are the grammar rules used to build each node
<li> lots of similar-but-different cases, for similar-but-different
       production rules for the same non-terminal.
</ul>

The alternative to writing one huge recursion
consisting of gigantic switch statements is the "swarm" model:
write a suite of mutually-recursive functions that know
how to do work for each different rule or each different type of
non-terminal node for that traversal.



<h4> Traversal code example </h4>

The following code sample illustrates a code generation tree traversal.
Note the gigantic switch statement.  A student once asked the question
of whether the link lists might grow longish, and if one is usually appending
instructions on to the end, wouldn't a naive link list do a terrible
O(n<sup>2</sup>) job.  To which the answer was: yes, and it would be good
to use a smarter data structure, such as one which stores both the head
and the tail of each list.

<pre>
void codegen(nodeptr t)
{
   int i, j;
   if (t==NULL) return;

   /*
    * this is a post-order traversal, so visit children first
    */
   for(i=0;i&lt;t-&gt;nkids;i++)
      codegen(t-&gt;child[i]);

   /*
    * back from children, consider what we have to do with
    * this node. The main thing we have to do, one way or
    * another, is assign t-&gt;code
    */
   switch (t-&gt;label) {
   case PLUS: {
      t-&gt;code = concat(t-&gt;child[0].icode, t-&gt;child[1].icode);
      g = gen(PLUS, t-&gt;address,
              t-&gt;child[0].address, t-&gt;child[1].address);
      t-&gt;code = concat(t-&gt;code, g);
      break;
      }
   /*
    * ... really, a bazillion cases, up to one for each
    * production rule (in the worst case)
    */
   default:
      /* default is: concatenate our children's code */
      t-&gt;code = NULL;
      for(i=0;i&lt;t-&gt;nkids;i++)
         t-&gt;code = concat(t-&gt;code, t-&gt;child[i].icode);
   }
}
</pre>




<!--
Decisions made 10/25: int does not autoconvert to bool, && and || are
allowed to require bool arguments.  Strings can be compared with == and !=.
-->

<h3> Codegen Example #1 </h3>

<ul>
<li> A lecture or two ago we had a request in class to do an example
     of intermediate code generation.
<li> But we aren't ready to do any non-toy example yet, you
have to get through some more lecture material on code generation for
control flow.
<li>  But consider the following example.
</ul>

<pre>
void main()
{
   int i
   i = 5
   i = i * i + 1
   write(i)
}
</pre>

We want something like

<pre>
proc main,0,32
	ASN	loc:0,const:5
	MUL	loc:8,loc:0,loc:0
	ADD	loc:16,loc:8,const:1
	ASN	loc:0,loc:16
	PARAM	loc:0
	CALL	write,1,loc:24
	RETURN
</pre>

We will do more substantive examples, in a bit.

<!--
<h3> Run Time Type Information </h3>

Some languages would need the type information around at runtime; for
example, dynamic object-oriented languages.  Its almost the case that one
just writes the type information, or symbol table information that includes
type information, into the generated code in this case, but perhaps one
wants to attach it to the actual values held at runtime.

<pre>
struct descrip {
   short type;
   short size;
   union {
      char *string;
      int ival;
      float rval;
      struct descrip *array;
      /* ... for other types */
      } value;
   };
</pre>
-->

<p>
<font size=1> <A name=37>lecture #37</A> began here</font>
<p>

<h3> Mailbag </h3>

<dl>
<dt> the following is legal in Go. 
<pre>var x int
var y float64
x, y = 5, 10.4
</pre>

Is this legal VGo? Are they allowed to have different types in the
declaration at once such as this having both int and float64?

<dd> I think we've said that "multiple assignment" was not in VGo. The only
possible waffle I've done was about reading input, because the most
fundamental functions for reading input in Go require multiple assignment
syntax.

</dl>

<h3> Reading input in VGo </h3>

Based on current information about the alternatives, I think we
want to support fmt.Scanln().  That means that there is exactly
one kind of pointer we should allow in VGo.

<p>
Options were:

<ol>
<li> Use the blank identifier and introduce a package bufio with a NewReader
that returns a predefined type *Reader and a package os with Stdin.
Support a very limited multiple
assignment in order to accomodate ReadString(), which returns both a string
and a failure.
<pre>
var reader *bufio.Reader
reader = bufio.NewReader(os.Stdin)
text, _ = reader.ReadString('\n')
</pre>
Note that if I had this class to do over again, I might just tell us to support
multiple assignment, since it is about the same logic (type tuples) as what
you have to do for parameter passing, anyhow.

<li> Use a pointer:
<pre>
fmt.Scanln(&text)
</pre>

<li> ... your better option here?
</ol>


While we are at it, how do you compare strings in Go?

<pre>
if strings.Compare("exit", text) == 0 {
   ...
   }
</pre>


<h3> Compute the Offset of Each Variable </h3>

<dl>
<dt> Add an address field to every symbol table entry.
<dd> The address contains a region plus an offset in that region.
<dt> No two variables may occupy the same memory at the same time.
<dd> At the intermediate code level, do not bother to re-use memory.
     In optimization and then in final code, re-use will be a big thing.
</dl>

<h3> Locals and Parameters are not Contiguous! </h3>

For each function you need either to manage two separate regions
for locals and for parameters, or else you need to track where
in that region the split between locals and parameters will be.
This may become more "interesting" if parameters are passed in registers.

<h3> Basic Blocks </h3>

A basic block is a sequence of 1+ instructions in which
there are no jumps into or out of the middle.  In the most extreme
case, every instruction is a basic block.  Start from that perspective
and then lump adjacent instructions together if nothing can come between
them.<p>

What are the basic blocks in the following 3-address code?
("read" is a 3-address code to read in an integer.)

<pre>
	read x
	t1 = x > 0
	if t1 == 0 goto L1
	fact = 1
	label L2
	t2 = fact * x
	fact = t2
	t3 = x - 1
	x = t3
	t4 = x == 0
	if t4 == 0 goto L2
	t5 = addr const:0
	param t5		; "%d\n"
	param fact
	call p,2
	label L1
	halt
</pre>


<h4> Discussion of Basic Blocks </h4>

<dl>
<dt> Basic blocks are often used in order to talk about
     specific types of optimizations.
<dd> For example, there are optimizations that are only safe to do
     within a basic block, such as "instruction reordering for superscalar
     pipeline filling".
<dt> So, why introduce basic blocks here?
<dd> our next topic is intermediate code for control flow, which includes
     gotos and labels, so maybe we ought to start thinking in terms of
     basic blocks and flow graphs, not just linked lists of instructions.
<dt> view every basic block as a hamburger
<dd> it will be a lot easier to eat if you
     sandwich it inside a pair of labels:
<pre>
	label START_OF_BLOCK_7031
	<em>...code for this basic block...</em>
	label END_OF_BLOCK_7031
</pre>
<dt> the label sandwich lets you:
<dd> <ul>
     <li> target any basic block as a control flow destination
     <li> skip over any basic block
     </ul>
      For example, for an if-then statement, you may need to jump to
      the beginning of the statement in the then-part...or you may need
      to jump over it, the choice depending on the outcome of a boolean.
</dl>

Yeah, these lecture notes repeat themselves about the label sandwich, almost
immediately. That must be on purpose.


<h4> C Operators </h4>

In case you were fuzzy on the operators you need to support:

<table border><tr><th> Essential <th> Non-essential
<tr><td> = += -= <td> *= /= %= &lt;&lt;= &gt;&gt;= &amp;= ^= |=
<tr><td> + - * / % <td> &gt;&gt; &lt;&lt; ++ -- ^
<tr><td> &amp;&amp; || ! <td> &amp; | ~
<tr><td> &lt; &lt;= &gt; &gt;= == != <td> ternary x ? y : z
<tr><td> expr[expr] x.y <td> &amp;x x-&gt;y *x
<tr><td> x:=:y; d x; y d x; #x expr[i:j]
</table>

Plus concatenation, which is invisible, but not unimportant.

<p>
<font size=1> <A name=38>lecture #38</A> began here</font>
<p>

<h3> Fully Committed and Past the Drop Date </h3>

After last week's drop deadline, there are now 29 in the class, including
two EO and three in CDA.  Congratulations on sticking it out.
<p>

HW#4 is due tonight at 11:59pm.  There should be lots of juicy questions!

<h3>Mailbag</h3>

<dl>
<dt> How late is the late fee on HW#4?
<dd> According to the complex late fee schedule I published earlier, the HW#4
late fee is 4% per day. I reserve the right to reduce that late fee if
individual circumstances (health, etc.) warrant. The bigger cost of
lateness is if you end up with goose eggs in HW#5 and HW#6 -- those can really
cost you in your final grade.

<dt> How do I typecheck Go's <code>make(x)</code> function?
<dd> Good catch: this is not a normal function, is it?  If I say
<pre>m = make(map[string]Vertex)
</pre>
I am constructing a map, and the argument is not a regular value at all --
it is a type. I suggest you treat make as a special case. You can verify
that the type is a map type. You can make the return type of make() be
whatever type was passed in as its argument.  To generate
code for it, we need a strategy.

<dt> What string operations do we have to support?
<dd> Strings are a built-in immutable type with subscript and len(s) built-in
     function.  Although I would really like to strings.Compare() and a few
     other items from the package strings...nope you do not have to do them.

<dt> Are we supporting comparisons of doubles with ==, !=, <=, and >=?
<dd> Yes.

<dt> Is it possible/legal to have variables of type void?
<dd> No.

<dt> To what types of variable is it legal to assign 'nil'? 
<dd> Reference types: list, tables and class instances can be nil.
     But you almost never have to say 'nil' in Go because variables
     all start with the value nil automatically.
</dl>

<h4>Intermediate Code for Control Flow </h4>

Code for control flow (if-then, switches, and loops) consists of
code to test conditions, and the use of goto instructions and
labels to route execution to the correct code.  Each chunk of code
that is executed together (no jumps into or out of it) is called
a <em>basic block</em>.  The basic blocks are nodes in a control flow graph,
where goto instructions, as well as falling through from one basic block
to another, are edges connecting basic blocks.
<p>

Depending on your source language's semantic rules for things like
"short-circuit" evaluation for boolean operators, the operators
like || and && might be similar to + and * (non-short-circuit) or
they might be more like if-then code.
<p>

A general technique for implementing control flow code:
<ul>
<li> add new attributes to tree nodes to hold labels that denote the
possible targets of jumps.
<li>  The labels in question are sort of
analogous to FIRST and FOLLOW
<li>for any given list of instructions
corresponding to a given tree node,
add a .first attribute to the tree to hold the label for the beginning
of the list, and a <code>.follow</code> attribute to hold the label for the next
instruction that comes after the list of instructions.
<li>The .first attribute can be easily synthesized.
<li> The <code>.follow</code> attribute must be
inherited from a sibling.
</ul>


<h3> If-Then and If-Then-Else </h3>

The labels have to actually be allocated and attached to instructions
at appropriate nodes in the tree corresponding to grammar production
rules that govern control flow.  An instruction in the middle of a
basic block need neither a first nor a follow.

<table border>
<tr><th>Production<th>Semantic Rules
<tr><td>IfThenStmt :<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
     if '(' Expr ')' Stmt<td>Expr.onTrue = Stmt.first<br>
					Expr.onFalse = IfThenStmt.follow<br>
					Stmt.follow = IfThenStmt.follow</br>
					IfThenStmt.icode = Expr.icode ||| gen(LABEL, Expr.onTrue) ||| Stmt.icode
<tr><td>IfThenElseStmt :<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
     if '(' Expr ')' Stmt<sub>1</sub> else Stmt<sub>2</sub>
<td>Expr.onTrue = Stmt<sub>1</sub>.first<br>
    Expr.onFalse = Stmt<sub>2</sub>.first<br>
	Stmt<sub>1</sub>.follow = IfThenElseStmt.follow;</br>
	Stmt<sub>2</sub>.follow = IfThenElseStmt.follow;</br>
	IfThenElseStmt.icode = Expr.icode ||| gen(LABEL, Expr.onTrue) ||| Stmt<sub>1</sub>.icode |||<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            gen(GOTO, IfThenElseStmt.follow) ||| gen(LABEL, Expr.onFalse) ||| Stmt<sub>2</sub>.icode
</table>


<!--
<h4> BASIC </h4>

As a student reported in class, Color BASIC supports statements in
the bodies of THEN and ELSE as an alternative to a line number to GOTO.
Indeed, it supports colon-separated lists of statements.<p>

This means the discussion in class about generating labels for the
starts and ends of then-parts and else-parts applies to BASIC, not
just C.<p>

BASIC also supports boolean AND, OR and NOT operators, and computes them
as integer (0 = FALSE, -1 = TRUE) but they are not short-circuit so the
handling of them is identical to (and simpler than) arithmetic operators
such as + and -.  Since we have not considered them up to now, and they
do not introduce interesting new challenges but instead are just handled
the same as required operators, Booleans are OPTIONAL EXTRA CREDIT for
your homework #4 and 5.  Don't bother with them unless everything else
in your assignment is finished.<p>
-->

<p>
<p>
<font size=1> <A name=39>lecture #39</A> began here</font>
<p>

<h3>Mailbag</h3>
<dl>

<dt> When we are inputting multiple files for the compiler, should we be
resetting the global table or allowing for redeclarations of global
variables to carry over to the other files?  I noticed that this was the
first assignment in the specification that we should be treating all the
files as one with a very large name space and wanted to get clarification.

<dd> I previously said in class that we would skip multi-file translation
for HW#3 and beyond, back before we understood that Go (and VGo) would
require a full separate pass to populate the symbol table.

If I had it to do over again, I would say: handle multiple files, and allow
redeclarations of packages, and leave the package main global symbol table
around across all specified files.  Not sure I want to change anything to be
harder at this point, only want to change things to be easier, so at the
moment as things stand, you do not have to handle multiple files.

<dt> I can easily fix some of my HW#3 problems. Can I turn in HW#3 to try
     and grind a couple more points out of you?
<dd> BBlearn will let you resubmit.
     If you lost catastrophic points, it is definitely worth resubmitting.
     If you only missed a few, I probably will assess a late fee that makes
     the resubmit mostly moot. Fix issues anyhow so you don't lose points
     on HW#4-6.
<dt> Do we need separate intermediate code instructions for floating point
     and for integer operations?
<dd> Good question.  What do you think?
</dl>
<p>




<h3> Generating Code for Conditions </h3>

Understanding the big picture on code generation for control structures such
as if's and while's requires an understanding of how to generate code for
the boolean expressions that control these constructs.
<ul>
<li> Consider the inherited attributes such as E.true and E.false.
<li> These are the destination instruction labels that say where to
      go if the condition is true, or false, respectively.
<li> The parent statement creates or inherits (from its parent
     or sibling) these destination goto labels
<li> They have to get passed down into boolean subexpressions
<li> Options for inherited attributes:
<ul>
<li> Allocate them ahead of time and pass them down in
     an extra tree-traversal before code generation, <b>OR</b>
<li> Go back into E.icode afterwards and fill them in after the
     information becomes known! For
     that you'll have to remember/store/track spots where such labels
     are missing. This implies more attributes and/or auxiliary structures.
</ul>
</ul>

<h4> Comparing Regular and Short Circuit Control Flow </h4>

Different languages have different semantics for booleans.
<ul>
<li> Pascal and similar languages treat them similar to arithmetic operators.
<ul>
<li> allocate a temporary variable to store E.addr at each tree node
     where a new boolean value is computed.
<li> compute a true or a false result into an E.addr.
<li> The .icode of the statement using the result inserts, after the E.icode, a
     <code>gen(BNIF, E.addr, E.false)</code> to skip over a then-part
     for an if with no else, or <br>
     <code>gen(BIF, E.addr, E.true) ||| gen(GOTO, E.false)</code>
     for an if with an else.
</ul>
<li> C (and C++, and many others) specify "short-circuit"
evaluation in which operands are not evaluated once the answer to
the boolean result is known.
<ul>
<li> <b>add extra attributes</b> to keep track of code locations that are
     targets of jumps. The attributes store link lists of those instructions
     that are <em>targets to backpatch</em> once a destination label is known.
     Boolean expressions' results evaluate to jump instructions and program
     counter values (where you get to in the code implies what the boolean
     expression results were).
<li> at each level you have a .true target and a .false target.
<li> naive version may have many unnecessary goto instructions and
      extra labels. This is OK in CSE 423. Optimizer can simplify.
</ul>
<li> Some ("kitchen-sink" design) languages have both
     short circuit and non-short-circuit boolean operators!
     (Can you name a language that has both?)
<li> Extra for experts: only the coolest languages utilize a
      Kobayashi Maru solution: change the machine
      instruction semantics to implicitly route
     control from expression failure to the appropriate location.  In
     order to do this one might
     <ul>
     <li> mark boundaries of code in which failure propagates
     <li> maintain a stack of such marked "expression frames"
     </ul>
</ul>
<p>


<h4> Boolean Expression Example</h4>

<pre>
a&lt;b || c&lt;d && e&lt;f
</pre>

Compare three intermediate code solutions given below.
<ul>
<li> The left uses the intermediate code presented earlier.
<li> The middle uses some new three address instructions. Is it cheating?
<li> Both left and middle end with E.addr in t<sub>5</sub> which must
     then be tested/used in some conditional branch to do control flow.
<li> The right side uses short-circuits as per C/C++
</ul>
<p>

<table border>
<tr><th> conditional branches <th> relop instructions <th> short circuit
<tr><td>
<pre>
100:	if a&lt;b goto 103
	t<sub>1</sub> = 0
	goto 104
103:	t<sub>1</sub> = 1
104:	if c&lt;d goto 107
	t<sub>2</sub> = 0
	goto 108
107:	t<sub>2</sub> = 1
108:	if e&lt;f goto 111
	t<sub>3</sub> = 0
	goto 112
111:	t<sub>3</sub> = 1
112:	t<sub>4</sub> = t<sub>2</sub> AND t<sub>3</sub>
	t<sub>5</sub> = t<sub>1</sub> OR t<sub>4</sub>
</pre>
<td>
<pre>
t<sub>1</sub> := a LT b
t<sub>2</sub> := c LT d
t<sub>3</sub> := e LT f
t<sub>4</sub> := t<sub>2</sub> AND t<sub>3</sub>
t<sub>5</sub> := t<sub>1</sub> OR t<sub>4</sub>
</pre>
<td>
<pre>
    if a&lt;b goto E.true
    if c&lt;d goto L1
    goto E.false
L1: if e&lt;f goto E.true
    goto E.false
</pre>
</table>

<P>
Short circuit semantics is short, fast, and can be used to play parlor tricks.

<p>
Q: do we know enough now to write the code generation rules for booleans?
<p>

<table border>
<tr>
<th>Production<th> Semantic Rules
<tr>
<td> AndExpr :<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        AndExpr<sub>1</sub> &amp;&amp; EqExpr
<td>
<pre>
 EqExpr.first = newlabel();
 AndExpr<sub>1</sub>.true = EqExpr.first;
 AndExpr<sub>1</sub>.false = AndExpr.false;
 EqExpr.true = AndExpr.true;
 EqExpr.false = AndExpr.false;
 AndExpr.icode = AndExpr<sub>1</sub>.icode ||| gen(LABEL, EqExpr.first) ||| EqExpr.icode;
</pre>
<tr>
<td> OrExpr :<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
       OrExpr<sub>1</sub> || AndExpr
<td>
<pre>
 AndExpr.first = newlabel();
 OrExpr<sub>1</sub>.true = OrExpr.true;
 OrExpr<sub>1</sub>.false = AndExpr.first;
 AndExpr.true = OrExpr.true;
 AndExpr.false = OrExpr.false;
 OrExpr.icode = OrExpr<sub>1</sub>.icode ||| gen(LABEL, AndExpr.first) ||| AndExpr.icode;
</pre>
<tr>
<td> UnaryExpr : ! UnaryExpr<sub>1</sub>
<td> 
<pre>
UnaryExpr<sub>1</sub>.true = UnaryExpr.false
UnaryExpr<sub>1</sub>.false = UnaryExpr.true
UnaryExpr.icode = UnaryExpr1.icode
</pre>
<tr>
<td> E : x
<td>
<pre>
  gen(BIF, E.false, x.addr, con:0) |||
  gen(GOTO, E.true)
</pre>
</table>

<p>

Hints: parent fill's out childrens' inherited attributes...

<p>
<font size=1> <A name=40>lecture #40</A> began here</font>
<p>

<h3> Mailbag </h3>

<dl>
<dt> 
I understand for hw 5 we are supposed to do intermediate code
generation. And I sorta understand that we are supposed to get label points
added at key places in our tree as semantic properties for the next
step. What I don't understand is what I will be doing in more detail. For c
what should this be looking like.

<dd> Tree traversals that compute more attributes.
     A lot of small do-able pieces of work that will be combined.
     Steps to intermediate code generation include:
<ul>
<li> Before you generate any code, implement and test the building blocks:
<ul>
<li> Define structs for address (region and offset) and for three-address
     intermediate code instructions.
<li> Build a linked list data type for lists of three-address instructions.
<li> Write a gen() function to create a linked list of length one, containing
     a single 3-address instruction
<li> Write a copycode(L) function to copy a linked list.
<li> Write a concatenate function concat(L1, L2) that builds
     a new linked list that consists of a copy of L1 followed by L2.
<li> Write a printcode(L) function that prints a list of code readably.
<li> Build a counter and a genlabel() function for generating labels
<li> Extend your symbol tables so that they track sizes of variables
     inserted into them, and can report how many bytes the whole table
     will need.
</ul>
<li> straight line code
<ul>
<li> Assign a .addr for all treenodes that represent anything with a value
<li> Allocate temporary variables for all operators/calls.
<li> Probably need to extend your tree printer so you can see/debug these.
<li> Generate linked lists of intermediate code instructions for straight
     line expressions and statements, with no control flow.
<li>     Generate header/ender pseudoinstructions for procedure main().
</ul>
<li> control flow
<ul>
<li> Allocate LABEL #'s to all treenodes that can be targets of goto
     instructions
<li> Push LABEL #'s around to where they are needed, through inherited
     and/or synthesized attributes via one or more tree traversals
<li> Need to extend your tree printer so you can see/debug these.
<li> Generate linked lists of intermediate code for if's and loops.
<li> Generate linked lists of intermediate code for call (no params) and void return
<li> Generate linked lists of intermediate code for return values, and parameters.
</ul>
</ul>



<dt> Traditionally, % only works on integer arguments.
Do I need to ensure that, or do I need to worry
about modulus for other types?

<dd> % requires integer arguments.

<dt>For structs <!--class <em>definitions</em>-->, how do we size them?
<dd>The size of the <em>instances</em> will be the sum of
the sizes of the member variables (rounding up each variable
to the next 8 byte (machine word) boundary), allocated out of the heap.
The class itself occupies no space.  Variables that hold
references to instances are sized as pointers
(8 bytes) in the global or local regions.

<dt> Do I need to give them a region/offset before I create an instance?
My thought is to give them a size, but only assign a region/offset to an
instance of the class.  Does this sound right?

<dd> Sure, size yes, location no.  In fact, at compile time you can only give
the region/offset of the object reference; the address of the actual object
in the heap is not known until runtime.

<dt> Does the size of a method include the size of the private
members that are declared inside the class but used inside the function?

<dd> VGo is not doing methods.  But if we were...
private members are allocated/sized in the instances, not the functions.
The member functions that use
class variables must do so using byte offsets relative to the beginning of an
object reference, and these byte offsets are consistent, for a given instance,
and do not vary depending on which function is called.

<dt>
How do I designate float constants?

<dd>
Most CPU's do not have float immediate instructions.  We need an actual
constant region, we need that for string constants too.  So create a region
for them, perhaps R_FLOAT and R_STRING, with byte offsets starting at word
boundaries.  Or you can have one combined region, perhaps R_RODATA.
</dl>



<h3> Intermediate Code for Relational Operators </h3>

<ul>
<li> intermediate code can have either
     relational operators in conditional branch statements, or
     relationals as standalone instructions that compute a
     boolean result.
<li> operands to relationals must be valid (numeric?) type.
<li> inherited attributes get used here, not pushed down further
     to the operands
<li> You could analyze
     whether to generate gotos to E.true/E.false or instead to
     generate values that compute a boolean result. Maybe surrounding
     code only sets your E.true/E.false to non-NULL if result
     should be expressed as gotos?
<li> You might instead compute a result AND generate gotos. The gotos
     might get optimized out if they are not needed.
</ul>

<p>

<table border>
<tr><th>C syntax<th>gotos<th> bool value <th> both ?
<tr><td>E-&gt; E<sub>1</sub> &lt; E<sub>2</sub>
<td>
E.icode = E<sub>1</sub>.icode || E<sub>2</sub>.icode ||<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
           gen(BLT, E<sub>1</sub>.addr, E<sub>2</sub>.addr, E.true) || <br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
           gen(GOTO, E.false)
<td>
E.addr = newtemp() <br>
E.icode = E<sub>1</sub>.icode || E<sub>2</sub>.icode ||<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
           gen(LT, E.addr, E<sub>1</sub>.addr, E<sub>2</sub>.addr)
<td>
E.addr = newtemp() <br>
E.icode = E<sub>1</sub>.icode || E<sub>2</sub>.icode ||<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
           gen(LT, E.addr, E<sub>1</sub>.addr, E<sub>2</sub>.addr) || <br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
           gen(BIF, E.addr, E.true) || <br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
           gen(GOTO, E.false)

</table>

<h3> Intermediate Code for Loops </h3>

<h4> While Loops </h4>

A while loop has semantic attributes and rules for intermediate code that
are very similar to an if-statement. There is almost only one difference,
the goto back to the beginning. Is there anything else missing or wrong here?

<p>

<table border>
<tr><th>C syntax<th>Attribute Manipulations
<tr><td>S-&gt;while '(' E ')' S<sub>1</sub><td>E.true = newlabel();<br>
					E.first = newlabel();<br>
					E.false = S.follow;<br>
					S<sub>1</sub>.follow = E.first;</br>
					S.icode = gen(LABEL, E.first) ||<br>&nbsp;&nbsp;&nbsp;E.icode || gen(LABEL, E.true)||<br>
					&nbsp;&nbsp;&nbsp;S<sub>1</sub>.icode || <br>
					&nbsp;&nbsp;&nbsp;gen(GOTO, E.first)
</table>

<p>
Finishing touches: what attributes and/or labels does this plan
need in order to support <code>break</code> and <code>continue</code>
statements?

<p>

<h4> For Loops </h4>

For-loops can be trivially transformed into while loops, so they pose just
about no new code generation issues.  Notice that only some expressions
need .true/.false: the ones used as conditionals.

<p>

<table border>
<tr><th>C syntax<th>equivalent<th>Attribute Manipulations
<tr><td>S-&gt;for( E<sub>1</sub>; E<sub>2</sub>; E<sub>3</sub> ) <br>
        &nbsp;&nbsp;&nbsp; S<sub>1</sub>
<td>
E<sub>1</sub>; <br>
while (E<sub>2</sub>) { <br>
   &nbsp;&nbsp;&nbsp;
   S<sub>1</sub> <br>
   &nbsp;&nbsp;&nbsp;
   E<sub>3</sub> <br>
}
<td>		E<sub>2</sub>.true = newlabel();<br>
		E<sub>2</sub>.first = newlabel();<br>
		E<sub>2</sub>.false = S.follow;<br>
		S<sub>1</sub>.follow = E<sub>3</sub>.first;</br>
		S.icode = E<sub>1</sub>.icode || <br> 
			&nbsp;&nbsp;&nbsp;gen(LABEL, E<sub>2</sub>.first) ||<br>
			&nbsp;&nbsp;&nbsp;E<sub>2</sub>.icode || gen(LABEL, E<sub>2</sub>.true)||<br>
			&nbsp;&nbsp;&nbsp;S<sub>1</sub>.icode || <br>
			&nbsp;&nbsp;&nbsp;E<sub>3</sub>.icode || <br>
			&nbsp;&nbsp;&nbsp;gen(GOTO, E<sub>2</sub>.first)
</table>
<p>

Again: what attributes and/or labels does this plan
need in order to support <code>break</code> and <code>continue</code>
statements?



<!--
<h4> BASIC FOR Loops </h4>

Is the same true for a BASIC FOR loop?  If not,
So how is a FOR loop different from C while loop?
Well, for one thing, there are two separate statements (FOR and NEXT)
that are matched together only by the variable name that controls the loop.

<p>
Example BASIC FOR-loop:
<pre>
10 FOR I = 1 to 10
20 PRINT I
30 NEXT I
</pre>

One possible 3-address code equivalent for this is:
<pre>
L10:				; line 10
	asn G:24 C:1		; I = 1
L10A:				; "end of line 10" == loop test
	bgr G:24 C:10 L30A	; How did we decide to go to end of 30?
L20:				; line 20
	param G:24		; push I onto stack for print
	call  print,1		; call print
L30:				; line 30
	add G:24 G:24 C:1	; I = I + 1
	goto L10A		; go to end of line 10
L30A:
	...
</pre>

There is an obvious question, which is how do the FOR and the NEXT find
each other?  Minimally, one might be looking at writing tree traversal
code to match up FOR and NEXT statements.
-->
<!--
<p>
<h3> FOR loops, continued </h3>

Last time we considered generating code for simple FOR-loops.
In reality FOR loops are stickier than this; FOR really isn't like
a C-style for- or while-loop.
There can be several NEXT statements corresponding to a given
FOR statement.  A FOR statement cannot determine a destination
to which to branch when the loop is finished; it never fails.
If you execute the following lines, BASIC prints a "2":
<pre>
10 FOR I = 2 TO 1
20 PRINT I
30 NEXT I
</pre>

Instead, a NEXT statement must not only do the increment, but also
test the loop's exit condition, and either branch back up to the
top of the loop (if the loop is not finished) or fall through.
In order to communicate between a FOR and any of several NEXT's,
use <em>variables</em>.  As I see it, you need about two variables
to do FOR loops: one variable to store: what code region address
to goto to jump back to do the next iteration of the loop, and
one to store the upper limit of the loop (for STEP versions of FOR
you need a third variable to hold the increment).  With these two
variables, the simple FOR loop looks more like:
<p>
<pre>
L10:				; line 10
	asn G:24 C:1		; I = 1
	asn G:28 L10A
	asn G:32 C:10
	asn G:36 C:1
L10A:				; "end of line 10" == place for NEXT to go
L20:				; line 20
	param G:24		; push I onto stack for print
	call  print,1		; call print
L30:				; line 30
	add G:24 G:24 G:36	; I = I + 1
	bleq G:24 G:32 G:28	; if i <= 10 goto L10A
L30A:
	...
</pre>


<!--
<h4> Note on BASIC's INPUT statement </h4>

By the way, Color BASIC's INPUT statement
has a convenient, optional, PRINT-like prompt clause.  Instead of
<pre>
10 PRINT "Enter your Mastercard Number: "
20 INPUT M$
</pre>
you can write:
<pre>
10 INPUT "Enter your Mastercard Number: "; M$
</pre>
This is shown in Chapter 11 of the Color BASIC book.
-->

<p>
<font size=1> <A name=41>lecture #41</A> began here</font>
<p>

<h3>Homework Status</h3>

<ul>
<li> As of 1:20 or so this afternoon, 10 students have turned in a HW#4;
     this will be my first HW#4 graded batch.
<li> If you aren't finished with HW#4, you are not alone, and you are graded
     relative to your peers.  But, please continue working on your project,
     and keep me updated.  Do not stay stuck for a week at a time. Do not
     choose not to get help when needed.
<Li> Discussion of <A href="hw5.html">HW#5</A>
</ul>


<h3> Code generation for Switch Statements </h3>

Consider the C switch statement
<pre>
switch(e) of {
   case v<sub>1</sub>:
      S<sub>1</sub>;
   case v<sub>2</sub>:
      S<sub>2</sub>;
   ...
   case v<sub>n-1</sub>:
      S<sub>n-1</sub>;
   default:
      S<sub>n</sub>;
}
</pre>

The intermediate code for this might look like:

<table><td>
<pre>
	<em>code for e, storing result in temp var t</em>
	goto Test
L<sub>1</sub>:
	<em>code for S<sub>1</sub>
L<sub>2</sub>:
	<em>code for S<sub>2</sub>
	...
L<sub>n-1</sub>:
	<em>code for S<sub>n-1</sub>
L<sub>n</sub>:
	<em>code for S<sub>n</sub>
	goto Next
Test:
	if t=v<sub>1</sub> goto L<sub>1</sub>
	if t=v<sub>2</sub> goto L<sub>2</sub>
	...
	if t=v<sub>n-1</sub> goto L<sub>n-1</sub>
	goto L<sub>n</sub>
Next:
</pre>
<td>
Note that C "break" statements<br>
are implemented in S<sub>1</sub>-S<sub>n</sub><br>
by "goto Next" instructions.
<br><br><br><br><br><br><br><br><br><br>
</table>


<!--
<h3> Brief Followup on Boolean-Integer Compatibility </h3>

Professor Soule's text <em>almost</em> cleanly separates bools and integers,
but not quite: he uses an int variable to hold a boolean value in one
example, and then uses
<pre>
   if (i) ...
</pre>
and suggests in a homework
exercise a feature that would extend it to
<pre>
if (i &amp;&amp; anotherbooleancondition...) ...
</pre>
-->

<h3> Intermediate Code Generation Examples </h3>

Consider the following small program.  It would be fair game as input
to your compiler project.  In order to show blow-by-blow what the code
generation process looks like, we need to construct the syntax tree and
do the semantic analysis steps.
<p>

<table><tr><th>C<th>Go
<tr><td>
<pre>
void print(int i);
void main()
{
   int i;
   i = 0;
   while (i < 20)
      i = i * i + 1;
   print(i);
}
</pre>
<td>
<pre>
package main
import "fmt"
func main() {
  var i int
  i = 0
  for i &lt; 20 {
    i = i * i + 1
    }
  fmt.Println(i)
}
</pre>
</table>
<p>

<p>

<img src="codegen.png" width=900 height=600>

<p>

We proceeded with a discussion of how to build the .icode fields.
One thing that got said was: .icode fields get built via a post-order
traversal (synthetised attribute) but .true, .false etc. are inherited
and may require a previous pass through the tree, or a pre-order
traversal.  If you are trying to do both in one pass it might look like
the following.

<p>
<p>
<font size=1> <A name=42>lecture #42</A> began here</font>
<p>

<h3>Mailbag </h3>

<dl>
<dt> Are you calling functions like they are variables???
<dd> No of course not. And you aren't supposed to be allowing that either.
<dt> Is there any chance I can resubmit for extra points from hw4?
<dd> Yeah, sure.
</dl>

<h3>Discussion of HW#4 </h3>

<ul>
<li> HW#4 grades are pretty rough at present; many/most who submitted in
     Batch 1 graded over the weekend will want to correct and resubmit.
<li> Without going into specifics, because many students haven't submitted
     HW#4 yet, there are many different illegal expressions to choose from
     that should generate type errors.  Everything should be an error until
     checked and shown to be OK.
<li> This is also the time in the semester when my strong sense of deja vu
     is starting to make me contemplate running roboflunk on student code
     solutions. Reminder: you are allowed to share ideas, but not code.
     If you have shared code already, it would be better for you to come
     tell me about it than to have me find out due to excessive deja vu.
</ul>


<p>
<font size=1> <A name=43>lecture #43</A> began here</font>
<p>
<dl>

<dt> Looking at Test case 5 you are trying to Println a float value but we
are not allowed to overload. So, should Println accept float or a string to
avoid overloading?
<dd> So, we danced around the question of how to print numbers before.
     Go seems to accept fmt.Println(i) for i being numberic, but
     I am trying to avoid making you implement type casts/conversions,
     and trying to avoid making you implement function overloading.

</dl>

<h3> itoa(i) and ftoa(f) in VGo </h3>

<table border>
<tr><th>itoa(i int) string <th> ftoa(f float64) string
<tr><td>
<pre>
func itoa(i int) string {
if i == 0 { return "0"}
if i == 1 { return "1"}
if i == 2 { return "2"}
if i == 3 { return "3"}
if i == 4 { return "4"}
if i == 5 { return "5"}
if i == 6 { return "6"}
if i == 7 { return "7"}
if i == 8 { return "8"}
if i == 9 { return "9"}
...
}
</pre>
<td>
<pre>
func ftoa(f float64) string {
??
}
</pre>
</table>




<h3> A Code Generation Function </h3>

<pre>
void codegen(struct tree *t)
{
   // pre-order stuff, e.g. label generation
   switch (t->prodrule) {
         ...
      case ITERATION_STMT: // inherited attributes for while loop
         // push an inherited attribute to child before visiting them
         t->child[2]->true = newlabel();
         break;
	 ...
      }
   // visit children
   for(i=0; i &lt; t-&gt;nkids; i++) codegen(t->child[0]);

   // post-order stuff, e.g. code generation
   switch (t->prodrule) {
         ...
      case CONDEXPR_2: // synthesized attribs for CondExpr: Expr &lt; Expr
         t->code = concat(
	        t->child[0]->code,
	        t->child[2]->code,
		gen(BLT, t->child[0]->place, t->child[2]->place, t->true),
		gen(GOTO, t->false)
		);
	 break;
      case ITERATION_STMT: // synthesized attributes for while loop
	 t->code = concat(
                    gen(LABEL, t->child[2]->first),
		    t->child[2]->code,
                    gen(LABEL, t->child[2]->true),
   		    t->child[4]->code,
		    gen(GOTO, t->child[2]->first));
	 break;
}
</pre>


<!--
<h3> Grammar Tweak: Casting and Implicit Type Conversion </h3>

<ul>
<li> you have been told that professor Soule's code examples do not include
      type casts, or at least, no implicit conversions.
<li> Maybe that's not quite true/correct.
<li> It is true that Soule's book uses implicit type conversion from int to
     double, <em>at least for the constant 0</em>.  He compares a double to
     0 (bad idea), and returns a 0 from a function that returns type double.
<li> Professor Soule's book also mentions implicit and explicit type
     conversion, including an example of the new-style cast syntax, int(d)
     for some double value.
<li> I had previously removed some of Sigala's grammar rules related to the
     new-style cast syntax due to reduce-reduce conflicts.
<li> I revised the reference 120gram.y to include new-style cast syntax for
     the scalar numeric built-in types.
<li> However, you are not required to do anything more with casts than is
     already stated in the 120++ Manual.
</ul>
-->


<!--
Here is an example BASIC program to compile:
<pre>
10	i = 0
20	IF i &gt;= 20 THEN 50
30	i = i * i + 1
40	GOTO 20
50	PRINT i
</pre>

This program corresponds to the following syntax tree, which a
successful homework #5 would build.  Note that it has a height of
approximately 10, and a maximum arity of approximately 4.  Also: your
exact tree might have more nodes, or slightly fewer; as long as the
information and general shape is there, such variations are not a problem.
<p>
<img src="syntree.jpg">
<em> A syntax tree, with attributes obtained from lexical and semantic
analysis, needs to be shown here.</em>
-->



The code for the boolean conditional expression controlling the while
loop is a list of length 1, containing the instruction t0 = i < 20,
or more formally

<table>
<tr><th> gotos <th> bool value
<tr><td>

<table border>
<tr><th>opcode<th>dest<th>src1<th>src2</tr>
<tr><td>BLT<td>i<td>20<td>E.true</tr>
<tr><td>GOTO<td>E.false<td>&Oslash;<td>&Oslash;</tr>
</table>

<td>

<table border>
<tr><th>opcode<th>dest<th>src1<th>src2</tr>
<tr><td>LT<td>t0<td>i<td>20</tr>
</table>
</table>
<p>

The actual C representation of addresses dest, src1, and src2 is a

<table border><td>region<br><hr>offset</table> pair, so the
picture of this intermediate code instruction really looks something like this:

<p>

<table>
<tr><th>gotos<th>bool value
<tr>
<td>
<table border>
<tr><th>opcode<th>dest<th>src1<th>src2</tr>
<tr><td>BLT<td>local<br><hr>i.offset<td>const<br><hr>20<td>code<br><hr>(E.true's label#)</tr>
</table>

<td>
<table border>
<tr><th>opcode<th>dest<th>src1<th>src2</tr>
<tr><td>LT<td>local<br><hr>t0.offset<td>local<br><hr>i.offset<td>const<br><hr>20</tr>
</table>
</table>

<p>

Regions are expressed with a simple integer encoding like:
global=1, local=2, const=3.
Note that address values in all regions are offsets from the start of the
region, except for region "const", which
stores the actual value of a single integer as its offset.

<p>

<table border>
<tr><th>opcode<th>dest<th>src1<th>src2</tr>
<tr><td>MUL<td>local<br><hr>t1.offset<td>local<br><hr>i.offset<td>local<br><hr>i.offset</tr>
</table>

<p>
The rest of class was spent elaborating on the linked list of instructions
for the preceding example.


<h3> <code>.first</code> and <code>.follow</code> for StmtList </h3>

<ul>
<li> As mentioned previously, attributes
     <code>.first</code> and <code>.follow</code>
     are an alternative to the "label sandwich" model of code generation
<li> <code>.first</code> holds a label denoting the first instruction to execute when
     control reaches a given subtree within a function body.
<li> <code>.first</code> is a synthesized attribute. Note that unlike
     FIRST(a), there is a unique and deterministic label. But worry-warts
     might want to ask if a given subtree can have epsilon code.
<li> <code>.follow</code> holds a label denoting the instruction that comes after
     a given subtree within a function body.
<li> <code>.follow</code> would be an inherited attribute, obtained from
     some ancestor's sibling.
</ul>

<p>

Suppose you have grammar rules

<pre>
FuncBody : '{' StatementList '}' ;
StatementList : StatementList Statement ;
StatementList :  ;
</pre>

What kind of <code>.first</code> and <code>.follow</code> values can we
develop and pass in to children from these rules?

<br>
<br>
<br>
<br>

<table border>
<tr><th> Syntax <th> Attribute Manipulations
<tr><td><pre>FuncBody : '{' StatementList '}'</pre>
    <td><pre>StatementList.follow = newlabel();
FuncBody.icode = StatementList.icode ||
                 gen(LABEL,StatementList.follow) ||
		 gen(RETURN)</pre>
<tr><td><pre>StatementList<sub>1</sub>: StatementList<sub>2</sub> Statement</pre>
    <td><pre>StatementList<sub>2</sub>.follow = Statement.first;
Statement.follow = StatementList<sub>1</sub>.follow ||
StatementList<sub>1</sub>.icode = StatementList<sub>2</sub>.icode || Statement.icode</pre>
<tr><td><pre>StatementList : ;</pre>
    <td><pre>/* no need for a StatementList.follow */
StatementList.first = newlabel()
StatementList.icode = gen(LABEL, StatementList.first) || gen(NOOP)</pre>
</table>

<!-- Using this same representation, the next instruction found by bottom-up
traversal of the tree is -->


<h3>More Code Generation Examples</h3>

You should implement your code generation one operator at a time,
simplest expressions first.

<p>

Zero operators.<p>

<pre>
if (x) S
</pre>
translates into

<pre>
if x != 0 goto L1
goto L2
label L1
...code for S
label L2
</pre>


or if you are being fancy

<pre>
if x == 0 goto L1
...code for S
label L1
</pre>
I may do this without comment in later examples, to keep them short.
<p>

One relational operator.<p>

<pre>
if (a &lt; b) S
</pre>
translates into

<pre>
if a &gt;= b goto L1
...code for S
label L1
</pre>

One boolean operator.<p>

<pre>
if (a &lt; b  &&  c &gt; d) S
</pre>
translates into

<pre>
if (a &lt; b)
   if (c &gt; d)
      ...code for S
</pre>
which if we expand it

<pre>
if a &gt;= b goto L1
if c &lt;= d goto L2
...code for S
label L2
label L1
</pre>

by mechanical means, we may wind up with lots of labels for the same
target (instruction), this is OK.<p>



Beware the following. A lazy code generator doing short-circuits might be
tempted to say that


<pre>
if (a &lt; b  ||  c &gt; d) S
</pre>
translates into

<pre>
if (a &lt; b) ...code for S
if (c &gt; d) ...code for S
</pre>
but its unacceptable to duplicate the code for S!  It might be huge!
Generate labels for boolean-true=yes-we-do-this-thing, not just for
boolean-false=we-skip-this-thing.

<pre>
if a &lt; b goto L1
if c &gt; d goto L2
goto L3
label L2
label L1
...code for S
label L3
</pre>

<p>
<font size=1> <A name=44>lecture #44</A> began here</font>
<p>
<dl>
<dt> Does VGo support this statement : gg=Vertex{15,199}?
<dd> Good question. The VGo references says no map literals,
     but indicates by example that object literals are supported.
     It also states that the named field initializer syntax
     Vertex{Y: 1} is not supported.

<dt> The VGo reference does not have any sizes for types. What are these
     sizes or where can I find this information?
<dd> Sizes have been discussed in lectures and some information are in
     lecture notes.  VGo also defers to Go on all matters unspecified in
     the VGo reference, so you could use Go documentation for sizes.
     Here is what I remember off-hand
<table border>
<tr><th>type<th>size (bytes)
<tr><td>bool<td> 1
<tr><td>rune<td> 4
<tr><td>int <td> 8
<tr><td>float64 <td> 8

<tr><th>Reference Types <th> variable is size 8 pointer, thing pointed at is:
<tr><td>array[n] <td> n * elementsize, round up to a multiple of 8
<tr><td>struct  <td> sum of field sizes, pad field sizes if needed
                     to a multiple of whatever field size comes next.
<tr><td>func    <td> assembler will take care of code sizes of functions
</table>

OK, now what have I left out?
</dl>


<h3> Object-Oriented Changes to Above Examples </h3>

The previous examples were assuming a C-like language semantics.
For an object-oriented language, the generated code for these examples
is more interesting.  For example, the semantics of
<pre>
if (x) S
</pre>
if x is an object, may be defaulted to be equivalent to
<pre>
if (x != NULL) S
</pre>
or more generally, the different types may have (hardwired, or overrideable)
conversion rules to convert them to booleans for use in tests, such as
<pre>
tempvar := x.as_boolean()
if (tempvar) S
</pre>

<h4> Code Generation for Arrays  </h4>

Consider first the subscript operator for C-like arrays. Then
consider how it ought to work in your compiler.
<p>

So far, we have only said, if we passed an array as a parameter we'd have to
pass its address.  3-address instructions have an "implicit dereferencing
semantics" which say all addresses' values are fetched / stored by default.
So when you say t1 := x + y, t1 gets values at addresses x and y, not the
addresses.  Once we recognize arrays are basically a pointer type, we need
3-address instructions to deal with pointers.  <p>

now, what about arrays?  reading an array value: x = a[i].  Draw the
picture.  Consider the machine uses byte-addressing, not word-addressing.
Unless you are an array of char, you need to multiply the subscript index
by the size of each array element...

<pre>
t0 := addr a
t1 := i * 8
t2 := plus t0 t1
t3 := deref t2
x  := t3
</pre>

What about writing an array value?

<p>

There are similar object-oriented adaptation issues for arrays: a[i]
might not be a simple array reference, it might be a call to
a method, as in
<pre>
x := a.index(i)
</pre>
or it might be implemented like:
<pre>
x := a field i
</pre>

The main issue to keep straight in both the C-like example and the
object-oriented discussion is: know when an instruction constructs an
address and stores an address in a memory location. When you want to
read or write to the address pointed to by the constructed address,
you may need to do an extra level of pointer-following. Three address
instructions have "implicit" pointer-following since all addresses are
followed when reading or writing memory, but if what is in the address
is another address, you have to be careful to keep that straight.

<p>




<h3> Supplemental Comments on Code Generation for Arrays </h3>

In order to generalize from our example last lecture,
the 3-address instructions for
<pre>
expr [ expr ]
</pre>
ideally should generate code that computes an address that can
subsequently be read from or written to. One can certainly write
a three address instruction to compute such an address.
With arrays this is pointer arithmetic.
<p>


With tables, the main wrinkle is: what to do
if the key is not in the table?  The behavior might be different
for reading a value or writing a value:

<table border>
<tr>
<th> syntax <th> behavior
<tr>
<td> t[x] := y <td> if key is not in table, insert it
<tr>
<td> y := t[x] <td> if key is not in table, one of:
<ul>
<li> produce a default value
<li> raise an exception
<li> ??
</ul>
</table>
<p>

<h3> Code Generation for Maps (Dictionaries, Tables) </h3>

Consider the Go map type for a moment.
One can generate code for maps either by extending the three-address
instruction set with new instructions, or by generating function calls.
How might you implement

<dl>
<dt> map construction: make(map[string]int)
<dd> Needs to allocate one hash table (array of buckets) from the heap.
For compiler, keys were always string. For VGo, keys can be string or int;
maybe two different opcodes/functions, or an argument that specifies this.
For other languages keys might be arbitrary type, adding complexity.

<table border>
<tr><th>Via 3-address Instructions <th>Via function call
<tr><td>
<pre>
MAPCREATE  dest
</pre>
<td>
<pre>
CALL	mapcreate,?,?
</pre>
</table>

<dt> insert: x[s] = s2
<dd> Needs to compute an address into which to store s2.

<table border>
<tr><th> Via 3-address Instructions <th> Via Function call
<tr><td>
<pre>
MAPINSERT  map,key,val
</pre>

<td>
<pre>
PARAM	map
PARAM	key
CALL    mapinsert,?,val
</pre>

</table>





<dt> lookup: s = x[s2]
<dd>
<table border>
<tr><th> Via 3-address Instructions <th> Via Function call
<tr><td>
<pre>
MAPLOOKUP   tmp,map,key
ASN	    s, tmp
</pre>
<td>
<pre>
PARAM   map
PARAM   key
CALL    maplookup,,tmp
ASN     s, tmp
</pre>
</table>
</dl>


<!--
The remainder of class was spent working out the details of assembling the
code generation for the entire while loop from our example before: <p>

<img src="intermed.jpg">
-->
<p>


<h3> Debugging Miscellany </h3>

Prior experience suggests if you are having trouble debugging, check:

<dl>
<dt> makefile .h dependencies!
<dd> if you do not list makefile dependencies for important .h files,
     you may get coredumps!
<dt> traversing multiple times by accident?
<dd> at least in my version, I found it easy to accidentally re-traverse
     portions of the tree. this usually had a bad effect.
<dt> bad grammar?
<dd> our sample grammar was adapted from good sources, but don't assume its
     impossible that it could have a flaw or that you might have messed it up.
<dt> bad tree?
<dd> its entirely possible to build a tree and forget one of your children
<!--
<dd> cocogram.y was adapted from an old BASIC grammar and from the available
     books on color computer BASIC.  But, it is certain that it still
     has bugs (missing pieces).  Our goal is not to do the whole of Color
     BASIC, but if there is a bug in the reasonable subset we've defined,
     fix it.
-->
</dl>

<h3> A few observations from Dr. D</h3>

I went shopping for more intermediate code examples, and while I didn't find
anything as complete as I wanted, I did find updated notes from the same
Jedi Master who trained me, check it:
<p>
<A href="IntermediateCodeGeneration.pdf">Dr. Debray's Intermediate Code Generation notes</A>.


<p>

You can consider these a recommended supplemental reading material, and we
can scan through them to look and see if they add any wrinkles to our prior
discussion.


<h3> A Bit of Skeletal Assistance with Three Address Code </h3>

<ul>
<li> <A href="tac.h">tac.h</A>
<li> <A href="tac.c">tac.c</A>
<li> <A href="codegen.c">codegen.c</A>
</ul>

<p>
<font size=1> <A name=45>lecture #45</A> began here</font>
<p>

<h3> Mailbag </h3>

<dl>
<dt> Do we need to specify the RET instruction at the end of a function
 or does the END instruction imply that the function returns?
<dd> I think of END in three-address code as a non-instruction
     (pseudo instruction) that marks the end of a procedure. So
     you should have a RET in front of it.  But really, you are
     allowed to define END's semantics to also do a RET; you could
     call it REND.

<dt> If we have nothing to return, can we just say RET with no parameter or
must the parameter x always be there, i.e. RET x?

<dd> I would accept a RET with no operand. You are allowed to define new
opcodes in intermediate code. Native assemblers often have several variants
of a given instruction -- same mnemonic, different opcodes for a related
family of instructions.

<dt> Can you give me an example of when to use the GLOBAL and LOCAL
declaration instructions?

<dd> These are pseudo-instructions, not instructions.
Globals are listed as required; at the minimum, if your program has any
global variables you must have at least one GLOBAL declaration to give the
size of (the sum of) the global variables. You can do one big GLOBAL and
reference variables as offsets, or you can declare many GLOBAL regions,
effectively defining one named region for each variable and therefore
rendering the offsets moot.

<p>
A LOCAL pseudo-instruction is listed as optional and advisory; think of
it as debugging symbol information, or as an assist to the reader of your
generated assembler source.

<dt> What sort of type checking is needed for a constructor?
     (in C++/Java it would be <code>new</code>)?
<dd> VGo is a special subset of Go. There is always a default constructor
     with all zeroes, and a non-default constructor with all fields' values
     specified in order, which should be typechecked like a function call.

<!--     If you were implementing <code>new</code>, its
     operand can be almost any type (what would be illegal there?). -->
     More generally in other languages,
     a constructor has to have # and types of parameters checked.
     Its return type is a reference to its operand type, and that type
     is type-checked against its enclosing expression, usually an assignment.
</dl>




<h3> Example of Generating <code>.first</code> and <code>.follow</code> Attributes </h3>

What nodes need these?
<ul>
<li> probably only the statement level nodes.
<li> they give way to <code>.true</code> and <code>.false</code>
     within (conditional) expressions
<li> maybe only certain statements, like loops, and
     statements that have a preceding statement that
     can jump to them instead of just falling through
<li> ok to just blindly brute force these, as many as you want
<li> but it would be good to not write them if they aren't used
</ul>
<p>

Call <code>gen_firsts(root)</code> followed by <code>gen_follows(root)</code> before generating code.
<p>

<table border>
<tr><th><code>.first</code><th><code>.follow</code>
<tr><td>
What?
<ul>
<li> synthesized attribute
<li> a label (#) to precede all executable instructions for a given chunk of
     code
</ul>
Why?
<ul>
<li> loops may go back to their <code>.first</code>.
<li> preceding statements' <code>.follow</code> may be inherited from your <code>.first</code>
</ul>


Sample code:
<pre>
void gen_firsts(nodeptr n)
{
   if (n == NULL) return;
   for(i=0; i<n->nkids; i++)
      gen_firsts(n->kids[i]);

   switch (n->prodrule) {
   case LABELED_STATEMENT:
      n->first = /* ... just use the explicit label */
      break;
   case EXPRESSION_STATEMENT:
   case COMPOUND_STATEMENT:
   case SELECTION_STATEMENT:
   case ITERATION_STATEMENT:
   case JUMP_STATEMENT:
   case DECLARATION_STATEMENT:
   case TRY_BLOCK:
      n->first = genlabel();
      break;
   default:
   }
}
</pre>

<td>
Why?
<ul>
<li> if we skip a then-part or do a then-part and have to skip an else-part
<li> if we have to break out of a loop
</ul>


What?
<ul>
<li> inherited attribute
<li> a label to go to whatever comes after the executable instructions for
     a given chunk of code.
<li> Could try to dodge, by blindly generating labels at the end of each
     statement ("label sandwich" approach). 
</ul>

<pre>
void gen_follows(nodeptr n)
{
   if (n == NULL) return;

   switch (n-&lt;prodrule) {
   case STATEMENT_SEQ + 2: /* statement_seq : statement_seq statement */
        n->child[0]->follow = n->child[1]->first;
	n->child[1]->follow = n->follow;
   	break;
   case COMPOUND_STATEMENT + 1: /* compstmt : '{' statement_seq_opt '}' */
        if (n->child[1] != NULL)
           n->child[1]->follow = n->follow;
   	break;
   case FUNCTION_DEFINITION + 1: /* funcdef : declarator ctor_init_opt body */
        n->child[2]->follow = genlabel();
        /* .icode must have this label and a return at the end! */
   	break;
   /* ... other cases? ... */
   default:
   }

   for(i=0; i&lt;n-&gt;nkids; i++)
      gen_follows(n-&gt;kids[i]);
}
</pre>
</table>


<h3> Labels for <code>break</code> and <code>continue</code> Statements </h3>

<ul>
<li> As shown above, label generation of <code>.first</code> and <code>.follow</code> isn't difficult
<li> <em>propagating</em> that information <em>way down</em>
     into the subtrees where it is needed, across many nodes where it
     is not needed, and not messing up on nested loops, can be a challenge.
<li> Option #1: add inherited attributes .loopfirst and
     .loopfollow to the treenodes. Use them to pass a loop's
     <code>.first</code> and <code>.follow</code>
     down into the "break" and "continue" statements that
     need them: 
<li> Option #2: write a specialized tree traversal whose first parameter is the
     tree (node) we are traversing, and whose second and third parameters
     are pointers to the label (struct address) of the nearest enclosing
     loop.  It would be called as <code>do_break(root, NULL, NULL);</code>
<li> Option #3: implement parent pointers within all the nodes of your
     tree, and walk up the parents until you find a loop node.
</ul>
<p>

Sample code for Option #2 is given below. Implied by the BREAK case is
the notion that the .addr field for this node type will hold the label
that is the target of its GOTO. How would you generalize it to
handle other loop types, and the <code>continue</code> statement?
There may be LOTS of different production rules for which
you do something interesting, so you may add a lot of cases to this
switch statement.

<pre>
void do_break(nodeptr n, address *loopfirst, address *loopfollow)
{
   switch (n->prodrule) {
   case BREAK:
      if (loopfollow != NULL)
	 n->place = *loopfollow;
      else semanticerror("break with no enclosing loop", n);
      break;
   case WHILE_LOOP:
      loopfirst = &(n-&gt;first);
      loopfollow = &(n-&gt;follow);
      break;
      ...
      }

   for(i=0; i&lt;n-&gt;nkids; i++)
      do_break(nodeptr n, loopfirst, loopfollow);
}
</pre>


<A name="tacordie">
<h3> TAC or die trying </h3>
</A>

We need a simple example, in which you see

<ul>
<li> Systematic traversal to populate explicit symbol table
<li> Systematic traversal to assign .addr (populate implicit symbols)
<li> Systematic traversal to assign <code>.first</code>/<code>.follow</code>/.true/.false
<li> Finally, build linked list of TAC instructions (.icode)
</ul>

It is easy to spend too much class time on
front-end stuff before getting to a too-short and still under-explored
TAC code generation phase. Our Goal:
<ul>
<li> manage a slightly larger ("interesting") example
<li> with syntax and semantic analysis already done
<li> for which we can go more blow by blow through the intermediate code
generation.
</ul>

The perfect example would include a few statements, expressions,
control flow constructs, and function calls.  Here is an such an
example. Notes for this exercise:

<Ul>
<li> We will look at a C example.  Compare this with the
     corresponding VGo example.  Qualitatively, what is the difference?
<li> We will just generate the body for function main().
     See if you can generate TAC code for the other functions,
     and ask questions.
<li>  we are again trying hard to use a syntax tree, not a
      parse tree, i.e. generally, no internal nodes with only one child.
<li>  We omit from the tree, tokens that are simply punctuation
      and reserved words needed for syntax.
<li>  Also as stated previously, in real life you
      might not want to remove <em>every</em> unary tree node, some of them
      have associated semantics or code to be generated, or may help
      provide needed context in your tree traversal.
</ul>


<table>
<tr><th>C version <th> pseudo-VGo version
<tr><td>
<pre>
void printf(char *, int);
int fib(int i);
int readline(char a[]);
int atoi(char a[]);
int main() {
   char s[64];
   int i;
   while (readline(s)!=0 && s[0]!='\004') {
      i = atoi(s);
      if (i <= 0) break;
      printf("%d\n", fib(i));
      }
}
</pre>
<td>
<!-- g0 version
<pre>
int fib(int i){
   if (n <= 1) { return 1 }
   else { return fib(n-1) + fib(n-2) }
}
int ctoi(string s){
   if (s == "0") {return 0}
   else if (s == "1") {return 1}
   else if (s == "2") {return 2}
   else if (s == "3") {return 3}
   else if (s == "4") {return 4}
   else if (s == "5") {return 5}
   else if (s == "6") {return 6}
   else if (s == "7") {return 7}
   else if (s == "8") {return 8}
   else if (s == "9") {return 9}
}
int atoi(string s){
   int i
   i = 0
   while (#s > 0) {
      string c = s[1]
      i = i * 10 + ctoi(c)
      s = s[2:0]
      }
   return i
}
string itoa(int i){
   string s
   int div, rem
   if (i == 0) { return "0" }
   else if (i == 1) { return "1" }
   else if (i == 2) { return "2" }
   else if (i == 3) { return "3" }
   else if (i == 4) { return "4" }
   else if (i == 5) { return "5" }
   else if (i == 6) { return "6" }
   else if (i == 7) { return "7" }
   else if (i == 8) { return "8" }
   else if (i == 9) { return "9" }
   else if (i < 0) { return "-" itoa(-i) }
   else {
     div = i / 10
     rem = i % 10
     return itoa(div) itoa(rem)
   }
}
int main() {
   string s
   int i
   while ((s = read()) != EOF) {
      i = atoi(s)
      if (i <= 0) { break }
      write(itoa(fib(i)))
      }
}
</pre>
-->
<pre>
func fib(int i) int {
   if n <= 1 { return 1 }
   else { return fib(n-1) + fib(n-2) }
}
func ctoi(string s) int {
   if s == "0" {return 0}
   else if s == "1" {return 1}
   else if s == "2" {return 2}
   else if s == "3" {return 3}
   else if s == "4" {return 4}
   else if s == "5" {return 5}
   else if s == "6" {return 6}
   else if s == "7" {return 7}
   else if s == "8" {return 8}
   else if s == "9" {return 9}
}
func atoi(string s) int {
  var i int
  for ... /* while (#s > 0) */ {
     //?? string c = s[1]
     //?? i = i * 10 + ctoi(c)
     //?? s = s[2:0]
      }
   return i
}
func itoa(i int) string {
   var s string
   var div, rem int
   if i == 0 { return "0" }
   else if i == 1 { return "1" }
   else if i == 2 { return "2" }
   else if i == 3 { return "3" }
   else if i == 4 { return "4" }
   else if i == 5 { return "5" }
   else if i == 6 { return "6" }
   else if i == 7 { return "7" }
   else if i == 8 { return "8" }
   else if i == 9 { return "9" }
   else if i < 0 { return "-" + itoa(-i) }
   else {
     div = i / 10
     rem = i % 10
     return itoa(div) + itoa(rem)
   }
}
func main() {
  var s string
  var i int
  for ... {
      i = atoi(s)
      if i <= 0 { break }
      fmt.Println(itoa(fib(i)))
      }
}
</pre>

</table>

<p>

<pre>
string ftoa(double d)
{
   if (d == 0.0) {
      return "0.0"
   }
   else if (d < 0.0) {
      return "-real"
      }
   else {
     return "real"
   }
}
</pre>


<!--
<pre>
package {
    public class fibber {
	public function fib(n : int): int {
	   if (n <= 1) return 1
	   else return fib(n-1) + fib(n-2)
	}
	public function fibber() {
            var s: String
	    var i: int
            while (s = read()) {
	       i = int(s)
	       if (i <= 0) break
	       trace(fib(i))
	       }
	}
    }
}
</pre>
-->


<p>


<p>



<img src="tac-example.png">
<p>

Using <A href="cgram.y">cgram.y</A> nonterminal names, let's focus on
code generation for the main procedure.



<h3> TAC-or-die: the First-level </h3>

<em>Potentially, this is a separate pass after labels have been generated.</em>
<p>

<table
<tr><td>
<img src="tac-example.png" width=500 height=768>
<td>

The first tree node that TAC code hits in its bottom up traversal is
IDENT<sub>readline</sub> (no .icode), followed by IDENT<sub>s</sub> (no .icode).
Above the IDENT<sub>s</sub>, argument_expression_list is one of those
non-terminals-with-only-one-child that matters and needs to be in the tree:
each time it churns out an actual parameter,
TAC code generates a PARAM instruction to copy the value of the parameter
into the parameter region. PARAM indicates an 8-byte (word) parameter;
you might also want to define PARAM4, PARAM2, PARAM1 (etc.) instructions.
Q: why is the ADDR instruction here?
<p>
<pre>
	ADDR   loc:72,loc:0
	PARAM  loc:72
</pre>
<p>

The postfix_expr is a function call, whose TAC codegen rule should say:
allocate a temporary variable t<sub>0</sub> (or as we called it: LOC:80)
for the return value, and generate a CALL instruction

<pre>
	CALL readline,1,loc:80
</pre>

The next leaf (ICON<sub>0</sub>) has no .icode, which brings code generation
up to the <code>!=</code> operator. Here the code depends on
the .true (L5) and .false (L2) labels.  The TAC code generated is

<pre>
	BNE loc:80,const:0,lab:5
	GOTO lab:2
</pre>

After that, the postfix traversal works over to IDENT<sub>s</sub> (no .icode),
ICON<sub>0</sub> (no .icode), and up to the postfix expression for the subscript
operator for <code>s[0]</code>.  It needs to generate .icode that will place
into a temporary variable (its .addr, loc:88) what s[0] is.<p>

The basic expression for a[i] is baseaddr + index * sizeof(element).
sizeof(element) is 1 in this case, so we can
just add baseaddr + index.  And index is 0 in this case, so an optimizer
would make it all go away.  But we aren't optimizing by default, we are
trying to solve the general case.  Calling temp = newtemp() we get a new
location (loc:96) to store index * sizeof(element)
<pre>
	MUL	loc:96,const:0,const:1
</pre>
We want to then add that to the base address, but
<pre>
	ADD	loc:104,loc:0,loc:96
</pre>
would add the (word) <em>contents</em> of s[0-7].  Instead, we need
<pre>
	ADDR	loc:104,loc:0
	ADD	loc:104,loc:104,loc:96
</pre>

After all this, loc:104 contains...the address we want to use.

<pre>
	DEREF1	loc:112,loc:104
</pre>
fetches (into word at loc:112) the <em>value</em> of s[0].
<p>
A label L5 needs to be prefixed into the front of this:
<pre>
	LABEL	lab:5
</pre>

</table>

<p>
Note: an alternative to ADDR would be to define opcodes for reading and
writing arrays.  For example
<pre>
	SUBSC1   <em>dest</em>,<em>base</em>,<em>index</em>
</pre>
might be defined to read from base[index] and store the result in dest.
Similar opcodes for ASNSUB1, SUBSC8, and ASNSUB8 could be added that
assign to base[index], and to perform these operations for 8-byte elements.
Even if you do this, you may need the more general ADDR instruction for
arrays of arbitrary sized elements.

<p>
CCON<sub>^D</sub> has no .icode, but the <code>!=</code> operator has
to generate code to jump to its .true (L4) or .false (L2) as in the previous
case.  Question: do we need to have a separate TAC instruction for
char compares, or sign-extend these operands, or what?  I vote: separate
opcode for byte operations.  BNEC is a "branch if not-equal characters"
instruction.

<pre>
	BNEC loc:112,const:4,lab:4
	GOTO lab:2
</pre>

The code for the entire local_and_expr is concatenated from its children:
<pre>
	ADDR   loc:72,loc:0
	PARAM  loc:72
	CALL   readline,1,loc:80
	BNE    loc:80,const:0,lab:5
	GOTO   lab:2
	LABEL  lab:5
	MUL    loc:96,const:0,const:1
	ADDR   loc:104,loc:0
	ADD    loc:104,loc:104,loc:96
	DEREF  loc:112,loc:104
	BNEC   loc:112,const:4,lab:4
	GOTO   lab:2
</pre>


Tree traversal then moves over into the body of the while loop: its statements.
<p>

IDENT<sub>i</sub> has no .icode.  The code for <code>atoi(s)</code> looks
almost identical to that for readline(s). The assignment to i tacks on
one more instruction:
<pre>
	ADDR   loc:120,loc:0
	PARAM  loc:120
	CALL   atoi,1,loc:128
	ASN    loc:64,loc:128
</pre>

For the second statement in the while loop, the IF statement, there is
the usual conditional-followed-by-unconditional branch, the interesting
part is where they go.  The E.true should do the then-part (the break
statement) for which we generate a <code>.first</code> of lab:6.  The E.false should
go for whatever instruction follows the if-statement, for which lab:3
has been designated.

<pre>
	BLE    loc:64,const:0,lab:6
	GOTO   lab:3
</pre>

The then-part is a break statement. All then-parts will need to have a
label for their <code>.first</code> instruction, which in this case is a trivial GOTO,
but where does it go?

<pre>
	LABEL  lab:6
	GOTO   ??
</pre>

The <code>break</code> is a major non-local goto that even
the parent node (the if-statement) cannot know the target for, without
obtaining it from about 7 tree-nodes higher!  The iteration_statement's
<code>.follow</code> (lab:2) is the target for <code>break</code> (its
<code>.first</code> would be the target for <code>continue</code>).

<h3> Dr. J has Doubts About 64-bit Ints </h3>

<ul>
<li> Last lecture I pointed out that I had edited the example we are
     working right now, to account for ints being 64-bit instead of 32-bit.
<li> It is reasonable to ask whether this is a Bad Idea.
<li> Pros: if (almost) everything is 64-bits, does that keep things simpler?
<li> Cons: if our ints are not the same size as g++ ints, how will that
     affect us?
</ul>

<h3> Back to the TAC-or-die example </h3>

So by one of options #1-3, we find the nearest enclosing iteration_statement's
<code>.follow</code> field says LAB:2. Note that since we have here a label target that
is itself a GOTO, an optimizer would chase back to the branch instructions
that go to label 6, and have them go to label 2, allowing us to remove this
instruction.  By the way, if there were an else statement, the
code generation for the then-part would include another GOTO (to skip over
the else-part) that we'd hopefully remove in optimization.

<pre>
	LABEL  lab:6
	GOTO   lab:2
</pre>

Having completed the then part, it is time to assemble the entire
if-statement:

<pre>
	BLE    loc:64,const:0,lab:6
	GOTO   lab:3
	LABEL  lab:6
	GOTO   lab:2
	LABEL  lab:3
</pre>

The next statement is a printf statement. We need to push the parameters
onto the stack and execute a call instruction.  The code will be: code
to evaluate the parameters (which are non-empty this time), code to push
parameters (in the correct order, from their .addr values),
then the call.  <em>Question: does it matter whether the evaluations
all occur before the PARAM instructions, or could they (should they) be
interleaved?</em>  Answer: in C++ evaluations must all occur before the
PARAM instructions, all PARAM instructions for a call come after the
code for evaluating those arguments, IN REVERSE ORDER, and right
before the CALL instruction.
<p>

The code for parameter 1 is empty; its string address will be
pushed onto the stack when we get to that part.
Here is the code for parameter 2,
storing the return value in a new temporary variable.

<pre>
	PARAM  loc:64
	CALL   fib,1,loc:136
</pre>

The code for the outer call is then

<pre>
	PARAM  loc:64
	CALL   fib,1,loc:136
	PARAM  loc:136
	PARAM  sconst:0
	CALL   printf,2,loc:144
</pre>

Given this, whole while-loop's code can finally be assembled.  The while
prepends a label and appends a GOTO back to the while loop's <code>.first</code> field.
The whole function's body is just this while loop, with a procedure
header and a return statement at the end:

<pre>
proc main,0,128
	LABEL  lab:1
	ADDR   loc:72,loc:0
	PARAM  loc:72
	CALL   readline,1,loc:80
	BNE    loc:80,const:0,lab:5
	GOTO   lab:2
	LABEL  lab:5
	MUL    loc:96,const:0,const:1
	ADDR   loc:104,loc:0
	ADD    loc:104,loc:104,loc:96
	DEREF  loc:112,loc:104
	BNEC   loc:112,const:4,lab:4
	GOTO   lab:2
	ADDR   loc:120,loc:0
	PARAM  loc:120
	CALL   atoi,1,loc:128
	ASN    loc:64,loc:128
	BLE    loc:64,const:0,lab:6
	GOTO   lab:3
	LABEL  lab:6
	GOTO   lab:2
	LABEL  lab:3
	PARAM  loc:64
	CALL   fib,1,loc:136
	PARAM  loc:136
	PARAM  sconst:0
	CALL   printf,2,loc:144
	GOTO   lab:1
	LABEL  lab:2
	RETURN
</pre>




<h3>Intermediate Code Generation for Structs, Classes and OO </h3>

<ul>
<li> CodeGen for structs/classes depends a lot on the language semantics.
<li> Lecture notes with ideas relevant to Java, ActionScript, or Unicon
may not do things identically to what a C++ subset needs.
<li> For a new language, we are needing to invent some stuff.
<li> Maybe some new 3 address opcodes/instructions, for example.
<li> Next section was for a C++ subset. For each bit, ask how is our
     target language different?
<li> More general OO considerations deferred to later
</ul>
<p>

Consider the following simplest possible OO class example program:

<pre>
class pet {
     int happy
      pet() { happy = 50 }
      void play() {
        write("Woof!\n")
	happy += 5
	}
}
int main()
{
    pet pet1
    pet1.play()
    return 0
}
</pre>

What are the code generation issues?
<br><br><br><br><br><br><br><br><br><br><br><br>

Did we get:
<ul>
<li> allocation
<li> initialization via constructor
<li> method calling
<li> member variable referencing
</ul>

For what its worth, one VGo test case is basically a hand-translation of
this into VGo using a struct.

<h3> Object Allocation </h3>

<dl>
<dt> memory allocation of an object is similar to other types.
<dd> it can be in the global, local (stack-relative) or heap area
<dt> the # of bytes (size) of the object must be computed from the class.
<dd> each symbol table should track the size of its members
<dt> for a global or local object, add its byte-count size requirement
     to its containing symbol table / region.
<dd> effectively, no separate code generation for allocation
<dt> translate a "new" expression into a malloc() call...
<dd> plus for all types of object creation, a constructor
     function call has to happen.
</dl>

<h3> Initialization via Constructor </h3>

<ul>
<li> A major difference between objects and, say, integers, is that
     objects have constructors.
<li> Constructor, like all other member functions, takes a 0th parameter
     that is a pointer to the object instance.  Could be implemented as
     a register variable, similar to %ebp procedure frame pointer.
<li> For a local, the object variable declaration translates into a
     constructor function call that happens at that point in the code body.
     Just catenate .icode into the linked list.
<li> For a "new" object, the constructor function call happens right after
     the (successful) call to allocate the object.
<li> For a global, how do we generate code for its constructor call?
     When does it execute? ... Good news, everyone!  120++ almost
     does not support globals at all, and only has integer globals.
</ul>

<h3> Method Invocation </h3>

Now let's discuss how to generate code for <p>

<code>o.f(arg1,...,argN)</code>

<ul>
<li> In C++ it's just a method invocation.

<li>
When o's class C is known at compile time and methods are non-virtual,
You can generate <code>C__f(&o, arg1, ..., argN)</code>.

<li> Note the flip side of this: when you generate code for the member
function body, you do the same name mangling, and add the same extra
one-word "this" parameter to the symbol table.

</ul>

<h3> Member variable references </h3>

<dl>
<dt> inside a member function, i.e. access member variable x.
<dd> Handle like with arrays, by allocating a new temporary variable
     in which to calculate the address of this->x.  Take the address
     in the "this" variable and add in x's offset as given in the
     symbol table for this's class.
<dt> outside an object, o.x.
<dd> Handle as above, using o's address instead of this's.
     You would also check o's class to make sure x is public.
</dl>


<h3> Code Generation for Dynamic OO Languages </h3>

<ul>
<li>
In a "really" OO language, for o.f(...) you'd do semantic analysis to know
whether f is a method of o's class, or a member variable that happens
to hold a function pointer
<li> What if f is a method that C inherits from some superclass S?

<li> What if o's class not known at compiled time and/or methods
are virtual. You have to calculate at runtime which method f to use for o.
What are your options???

</ul>

<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
Your brilliant suggestions should have included: insert function pointers
for all methods into the instance.<p>

Now let's consider a simple real-world-ish
example.  Class TextField, a small, simple GUI widget. A typical
GUI application might have many textfields on each of many dialogs; many
instances of this class will be needed. <p>

The source code for TextField
is only 767 lines long, with 17 member variables and 47 member functions.
But it is a subclass of class Component, which is a subclass of three other
classes...by the time inheritance is resolved, we have 44 member variables,
and 149 member functions.  If we include function pointers for all methods
in the instance, 77% of instance variable slots will be these function
pointers, and these 77% of the slots will be identical/copied for all
instances of that class.
<p>

The logical thing to do is to share a single copy of the function pointers,
either in a "class object" that is an instance of a meta-class, or more
minimally, in a struct or array of function pointers that might be
called (by some) a <em>methods vector</em>.



<h3> Methods Vectors </h3>

Suppose you have class A with methods f(), g(), and h(), and class B
with methods e(), f(), and g().  Suppose further that you have code
that calls method f(), that is designed to work either either A or B.
This might happen due to polymorphism, interfaces, subclassing, virtual
methods, etc.  The kicker will be that in order to generate code for
o.f(), a runtime lookup will be performed to obtain
the function/method pointer associated with symbol f.

Instead a separate structure (the "methods vector") is allocated and
shared by all the instances of a given class.  In this case, o.f()
becomes o.__methods__.f(o)


<p>
<p>
<font size=1> <A name=46>lecture #46</A> began here</font>
<p>

<h3> Mailbag </h3>

<dl>
<dt> What if my program has three functions, each with a local variable to
     declare?
<dd> Each function's "local region" is allocated uniquely each time they
     are called. Each of your functions' local regions starts at offset 0
     so all three local variables might say LOC:0 for local region offset
     zero.  And yet, they never refer to the same memory, because they are
     always offsets relative to some base pointer register on the stack.

<dt> When do I allocate my labels?  When do I use them?
<dd> You allocate them in one or more tree traversals prior to starting
     the main traversal that generates the linked lists of 3-address code.
     Most labels are allocated very close to where they are used.
     You use labels by generating pseudo-instructions in the linked list AND
     by filling in the target addresses used by goto instructions with LAB:#N
     for label number N.

<dt> What do I have to do to get a "D"?

<dd> You are graded relative to your peers.  In previous semesters the
answer to this has been something like: pass the midterm and final, and
convince me that you really did semantic analysis.  If you did poorly on the
midterm, you might want to try and do better on the final, and you might
want to get some three address code working.  Do you really want to settle
for a "D"?  Almost everyone who was "D" material dropped the class already.

<dt> I am confused about how to access class members via the "this"
pointer.  I am unsure how to do the offsets from the "this" pointer in
three address code without creating a new symbol table for class instances.
<dd> An object instance is like its own little memory region.
The <code>this</code> pointer is a parameter; offsets relative to
what it points at are done via pointer arithmetic. Each class
should indeed have a symbol table for its member variables' offsets.

<dt> Do you have an example that uses each of the pseudo instructions
     (global, proc, local, label, and end), so we
     know how these should be formatted?
<dd> No.  The pseudo instructions should have opcodes and three address
fields; their presence in the linked list of three address codes is the
same as an instruction. Their format when you print them out is not very
important since this is just intermediate code. But:
instructions are on a single line that begins with a tab character, and
pseudo instructions are on a single line that does not begin with a tab
character.

<dt> We have const that can hold an int/(int)char/boolean, a string region
for holding a string offset, but what should we do about double const
values?

<dd> Real number constants have to be allocated space similar to other types.
They could either be allocated out of a separate "real number constant
region", or the constants of different types could all be allocated out of
the same region, with different offsets and sizes as needed. Note that
not all integer constants fit in instructions, so potentially
some of them may have to be allocated as static data also.

</dl>

<h3> Where we are at </h3>

Schedule-wise, it says it is time to move lectures on into the area of
final code generation.  We have a new wrinkle there this year, and need
to allow some time for it.  But, intermediate code generators are not
due yet, and questions about that are still totally fair game.

<p>
<h3>One More Intermediate Code Example, with Feeling </h3>

I glossed over the "TAC or die trying" example in the last lecture;
it felt redundant for me since we did an earlier example that
was similar. However, one or more of you have requested another
intermediate code generation example.
<p>

Yeah, we'll do one alright; this week.  But it will take a bit more
preparation, so: not today.  This weekend I spent a fair bit digging into
another code generation topic, namely LLVM, and we will also be talking
about that.
<p>



<a name="finalcode">
<h3> Final Code Generation </h3>
</a>

<ul>
<li> Goal: execute the program we have been translating, somehow.
<li> Note: in real life we would execute a major optimization phase
on the intermediate code, before generating final code.
</ul>

Alternatives for Final Code:
<dl>
<dt> interpret the source code
<dd> we could build an interpreter instead of a compiler, in which the
     source code was kept in string or token form, and re-parsed, possibly
     repeatedly, during execution. Some early BASIC's and operating system
     shell scripting languages do this, but it is Really Slow.
<dt> interpret the parse tree
<dd> we could write an interpreter that executes the program
     by walking around on the tree doing traversals of various subtrees.
     This is still slow, but successfully used by many "scripting languages".
<dt> interpret the 3-address code
<dd> we could interpret the link-list or a more compact binary representation
     of the intermediate code
<dt> translate into VM instructions
<dd> popular virtual machines such as JVM or .Net allow execution from an
     instruction set that is often higher level than hardware, may be
     independent of the underlying hardware, and may be oriented toward
     supporting the specific language features of the source language.
     For example, there are various BASIC virtual machines out there.
<dt> translate into "native" instructions
<dd> "native" generally means hardware instructions.
</dl>

For practical purposes, we will consider only two of these options
<ol>
<li> translate into VM assembler for the LLVM IR, or
<li> translate into native x86_64
</ol>


<h3> Introduction to <A href="https://llvm.org/docs/LangRef.html">LLVM</A></h3>

LLVM, low-level virtual machine, is a compiler back-end developed by Apple.
Compared with Java VM it is arguably lower level, and it provides a human
readable assembler format that the Java folks have avoided. For a
compiler writer, it provides a way to translate to a machine independent
3-address instruction set and still obtain a highly optimized native
executable on various platforms.  LLVM intermediate representation looks
like this:

<pre>
@.str = private constant [12 x i8] c"Hello llvm!\00", align 1 ;
 
define i32 @main() ssp {
entry:
  %retval = alloca i32
  %0 = alloca i32
  %"alloca point" = bitcast i32 0 to i32
  %1 = call i32 @puts(i8* getelementptr inbounds ([12 x i8]* @.str, i64 0, i64 0))
  store i32 0, i32* %0, align 4
  %2 = load i32* %0, align 4
  store i32 %2, i32* %retval, align 4
  br label %return
return:
  %retval1 = load i32* %retval
  ret i32 %retval1
}
 
declare i32 @puts(i8*)
</pre>

Human-readable LLVM IR is translated from a <code>.ll</code> extension into
a binary version with the extension <code>.bc</code>. .bc files can be
translated into native assembler code by llc, and then assembled and linked.
For example, if the above file were in a file named hello.ll, the following
sequence would produce an executable:

<pre>
    llvm-as hello.ll
    llc hello.bc
    as hello.s -o hello.o
    gcc hello.o -o hello
</pre>

To study LLVM further we should take a look at how to translate our various
three-address intermediate instructions into it, and take a look at its
instruction set.  We will explore these topics as time allows.


<h3> Native Code Generation </h3>

In mainstream compilers, final code generation into native code
<ol>
<li> takes a linear sequence of 3-address intermediate
code instructions, and
<li> translates each 3-address instruction into one or
more native instructions.
</ol>
<p>

The big issues in code generation are:
<dl>
<dt> (a) instruction selection, and
<dt> (b) register allocation and assignment.
</dl>



<h3> # of Registers Clarification </h3>

<ul>
<li> numbers quoted last lecture were for "completely undesignated"
     general purpose registers
<li> 32-bit x86 really has eight (8) general purpose registers although
     some are typically used for specific purposes suggested by their name:
     (eax, ecx, edx, ebx, esp, ebp, esi, edi)
<li> 64-bit AMD64 (a.k.a. x86-64) has sixteen (16) registers:
rax, rcx, rdx, rbx, rsp, rbp, rsi, rdi, r8, r9, r10, r11, r12, r13, r14, r15
<li> DEC VAX had 32 registers
<li> ARM (hello, smartphones) has 8, or maybe 13
<li> other RISC systems often have 32 or more;
     Sun SPARC has 192 registers accessed
     via a sliding <em>register window</em>
</ul>


<h3> Code Generation for High Level Structure Types </h3>

This discussion applies to maps/dictionaries/tables as we as high-level
sequential (list) types that are dynamic, in contrast with arrays.

<ul>
<li> What we have said so far is that you could define new opcodes
     for such operators (raising the language level of your
     intermediate code), or implement them as function calls.
<li> Either way, we will (by final code generation) need an
     implementation of this functionality, that your code can
     link in and use.  You could write your own, or ask me to
     provide this as a set of runtime functions in C.
</ul>

<p>
Lists:
<p>

<table border>
<tr><th>operation<th> as opcode        <th> as function
<tr><td> L1 L2   <td> LCONCAT t,L1,L2  <td> t = lconcat(L1,L2)
<tr><td> L1 += L2<td> LAPPEND L1,L2    <td> lappend(L1,L2)
<tr><td> L1 += x <td> LPUT    L1,x     <td> lput(L1,x)
<tr><td> L[i]    <td> LINDEX  t,L,i    <td> t = lindex(L,i)
<tr><td> L[i:j]  <td> LSLICE t,L,i,j<br>
                      no good, 4 addrs <td> t = lslice(L,i,j)
<tr><td> #L      <td> LSIZE   t,L      <td> t = lsize(L)
<tr><td> t = list() <td> LIST t,n,m    <td> t = list(n,m)
</table>

<p>
Tables:
<p>

<table border>
<tr><th>operation<th>as opcode<th>as function
<tr><td> T[a]    <td> TINDEX  t,T,a  <td> t = tindex(T,a)
<tr><td> T[]=a   <td> TDEFAULT T,a   <td> tdefault(T,a)
<tr><td> T -= a  <td> TDELETE T,a    <td> tdelete(T,a)
<tr><td> #T      <td> TSIZE   t,T    <td> t = tsize(T)
<tr><td> t = table() <td> TABLE t,m    <td> t = table(m)
</table>




<h3> Collecting Information Necessary for Final Code Generation </h3>

<dl>
<dt> Option #A: a top-down approach to learning your native target code.
<dd>
     Study a reference work supplied by the chip manufacturer, such
     as the <A href="https://support.amd.com/TechDocs/24592.pdf">
     AMD64 Architecture Programmer's Manual</A>
      (<A href="http://developer.amd.com/wordpress/media/2012/10/24593_APM_v21.pdf">Vol. 2</A>,
      <A href="https://support.amd.com/TechDocs/24594.pdf">Vol. 3</A>).
<dt> Option #B: a bottom-up (or reverse engineering)
     approach to learning your native target code.
<dd>
     study an existing compiler's native code.  For example, run
     "g++ -S" for various toy programs
     to learn native instructions corresponding to each expression,
     particularly ones equivalent to the various 3-address instructions.
</dl>

<p>
<font size=1> <A name=47>lecture #47</A> began here</font>
<p>

<h3>Mailbag </h3>

<dl>
<dt> Do the linked lists of code really just get concatenated in order
     until the entire program is one big linked list?
     Does main() have to be at the beginning in generated code?
<dd>
     Not really, and not really.  It is recommended that you build one
     big linked list for the generated code, but I am a pragmatist; do
     what makes sense to you to generate all the code.  In real native
     OS'es, the code at the beginning of the executable is not main, it
     is some weird startup boostrapper that sets up environment and
     command line arguments and then calls main(). So no, main() does not
     have to be at the top, unless maybe you are building an image
     for an embedded system that doesn't have an OS or something like that.

<dt> How do I represent function names in addresses in 3 address code?
<dd> One option is to totally dodge, and generate code for one function
      at a time, at a place where you know the function name. If you
     choose instead to build one big linked list,
     function "names" get boiled down to code region addresses. So far
     we have one kind of address in the code region: labels.
     You could literally generate label #'s for these things, but function
     names are more human-friendly.  Unless you turn function names into
     labels, you should create a new region (call it PROCNAME).  You could make the "offset" field in
     your 3 addresses a union
<pre>
     struct addr {
      int region; // if PROCNAME, use u.s instead of u.i
      union {
         int offset;
	 char *s;
         } u;
      }
</pre>
     You could, instead, make an array of string funcnames in your compiler
     and have your region PROCNAME provide offsets that are subscripts into
     this array of funcnames.

<dt> I am having a hard time understanding how everything will be put
together in the end, will it be one linked list once all the instructions
are concatenated? How should we handle assigning locations to functions like
Println? Once we see import "fmt" should we go to that symbol table and
assign locations to those functions then?

<dd>Library functions like Println require that we store enough information
to call them, but not that we store information to generate code for them.
fmt should have an associated symbol table entry for Println which should
know that Println takes a string argument.  Code for a call to fmt.Println
should mangle that name out to something like fmt__Println.

<dt> can we just define a function without parameters as call, so
<code>main</code> is equivalent to <code>main()</code> if not followed
by parentheses?
<dd> Do not confuse type (reference to) FUNCTION with
the function's return type, which is the result of a call (postfix parentheses
operator).
</dl>

<h3> A New Fun Intermediate CodeGen Example </h3>

This example is not burdened with redundant practice at generating code
for arithmetic and assignments and such.

<pre>
package main
import "fmt"
func min(a,b,c int) int {
  if a<=b && a<=c {
     return a
  } else if b<=a && b<=c {
     return b
  }
  return c
}

func main() {
  fmt.Println(min(3,6,2))
}
</pre>

<h3> Back to Final Codegen </h3>

<h4>Instruction Selection</h4>

A modern CPU usually has many different sequences of instructions
that it could use to accomplish a given task.  Instruction selection
must choose a particular sequence.
<ul>
<li> how many registers are tied to particular instructions?
<li> is a special case instruction available for a particular
     computation?
<li> what addressing mode(s) are supported for a given instruction?
</ul>

Given a choice among equivalent/alternative sequences, the decision on which
sequence of instructions to use is usually based on estimates or
measurements of which sequence executes the <em>fastest</em>.

<ul>
<li> "fastest" is often approximated by the
number of memory references incurred during execution, including the
memory references for the instructions themselves.
<li>  picking the
<em>shortest</em> sequence of instructions is often a good approximation of the
optimal result, since fewer instructions usually translates into fewer
memory references.
</ul>

<p>

A good set of examples of instruction selection are to be
found in the <A href="http://www.stanford.edu/class/cs343/resources/superoptimizer.pdf">superoptimizer</A> paper. From that paper:

<ul>
<li> a longer instruction sequence may be faster if it avoids gotos
<li> sometimes the fastest sequence exploits specific constants in the
     operands and is really, really surprising.
</ul>

<p>
<p>
<font size=1> <A name=48>lecture #48</A> began here</font>
<p>
<h3> Mailbag </h3>

<dl>
<dt> Can we have more time to do HW#5 and #6

<dd> I will take them when I can get them.  Due dates changed to Nov 27
and Dec 13 respectively.

<dt>
I'm having trouble figuring out what TAC I need to generate for a function
definition.  For example, given the function 
<pre>int foo(int x){
   ...somecode
}</pre>

I'm having trouble understanding what code needs to be generated at this
level.  I understand that there needs to be (at least) 1 label, at the very
start (to be able to call the function).

<dd><font color=red>In final code, the procedure entry point
will indeed include a label. In three address code, a function header
should result in a PROC pseudo-instruction for which you create a link
list element, just like everything else.
</font>

<dt>

I'm having trouble understanding what code I would create for the int
return, or to define the space available for parameters.

<dd>
<font color=red>
The "return type" at the top of a function generates no code, but it may
affect what you generate when you hit a "return" statement in the function
body.

The proc pseudoinstruction includes a declaration of how many
(words of parameters) it requires/assumes has been passed in to a function,
from which space required may be calculated. It most native code the caller
really allocates this space via PARAM instructions; the called function
just decides the amount of
local/temp variable space on the stack that the procedure requires.
So the pseudoinstructions in intermediate code that you use is
something like:
<pre>
proc foo,1,<em>nbytes_localspace</em>
</pre></font>

<dt>

If I understand the return properly, I don't actually generate code at this
(the procedure header return type) node for the return.  It gets generated
at the 'return' line in the body.

<dd>

<font color=red>Yes. There and at the end of any function
that falls off the end.  In final code the return statement will put a
return value in %eax and then jump
down to the end of the function to use its proper function-return assembler
instruction(s).
</font>

<dt>

I guess the .addr of <code>int x</code> is what is really getting me.
Do I really
need to worry about it too much in TAC, because it is just 'local 0' (or
whatever number gets generated)?

<dd>

<font color=red>I recommend you consider it (in TAC) to be region
PARAM offset 0.  That could be handled almost identically to locals in final
code, unless you use the fact that parameters are passed in registers...
</font>

<dt>

Then I really end up worrying about it during final code since local 0 might
actually be something like %rbp -1 or wherever the location on the stack
parameters end up being located.

<dd>

<font color=red>By saying it is PARAM offset 0, the TAC code for
parameters is distinct enough from locals that they can be found to be at
a different location relative to the %rbp (positive instead of negative)
or passed in registers.</font>

</dl>



<h3> Register Allocation and Assignment </h3>

<ul>
<li> reading values in registers is much much faster than accessing main memory.
<li>
<em>Register allocation</em> denotes the selection of which variables
will go into registers.
<li>
<em>Register assignment</em> is the determination of exactly
which register to place a given variable.
<li> goal: minimize the total number of memory accesses required
by the program.
</ul>
<p>

<h4> The (register allocation) job changes as CPUs change </h4>

<ul>
<li>In the age of dinosaurs, Load-Store architectures featured
only one (accumulator) register.
Register allocation and assignment was moot.
<li>In the age of minis and micros, it was usually "easy", e.g.
traditional x86 had 4 registers instead of 1.
<li>Recent History features CPU's with 32 or more general purpose
registers.  On such systems,
high quality compiler register allocation and assignment makes a huge
difference in program execution speed.
<li> :-( btw, optimal register
allocation and assignment is NP-complete! Compilers must settle for
doing a "good" job.

<li>usually the # of variables at many given time exceeds the number
of registers available (the common case)
<li> variables may be used (slowly)
     directly from memory IF the instruction set supports
     memory-based operations.
<li>
When an instruction set does not support memory-based operations, all
variables must be loaded into a register in order to perform arithmetic
or logic using them.
</ul>
<p>

Even if an instruction set does support memory-based operations, most
compilers should load a value into a register while it is
being used, and then spill it back out to main memory when the register
is needed for another purpose.  The task of minimizing memory accesses
becomes the task of minimizing register loads and spills.

<p>
<font size=1> <A name=49>lecture #49</A> began here</font>
<p>


<h3> Native Code Generation Examples </h3>

<h4> Reusing a Register </h4>

Consider the statement:
<pre>
   a = a+b+c+d+e+f+g+a+c+e;
</pre>
A naive three address code generator would generate a
lot of temporary variables here, one per addition operator, when
in actuality one big number is being added.
How many registers does the expression need?  Some variables
are referenced once, some twice.  GCC (32-bit) generates:
<p>

<pre>
	movl	b, %eax
	addl	a, %eax
	addl	c, %eax
	addl	d, %eax
	addl	e, %eax
	addl	f, %eax
	addl	g, %eax
	addl	a, %eax
	addl	c, %eax
	addl	e, %eax
	movl	%eax, a
</pre>

<p>

Now consider
<pre>
   a = (a+b)*(c+d)*(e+f)*(g+a)*(c+e);
</pre>
How many registers are needed here?
<pre>
	movl	b, %eax
	movl	a, %edx
	addl	%eax, %edx
	movl	d, %eax
	addl	c, %eax
	imull	%eax, %edx
	movl	f, %eax
	addl	e, %eax
	imull	%eax, %edx
	movl	a, %eax
	addl	g, %eax
	imull	%eax, %edx
	movl	e, %eax
	addl	c, %eax
	imull	%edx, %eax
	movl	%eax, a
</pre>

And now this:
<pre>
   a = ((a+b)*(c+d))+((e+f)*(g+a))+(c*e);
</pre>
which compiles to
<pre>
	movl	b, %eax
	movl	a, %edx
	addl	%eax, %edx
	movl	d, %eax
	addl	c, %eax
	movl	%edx, %ecx
	imull	%eax, %ecx
	movl	f, %eax
	movl	e, %edx
	addl	%eax, %edx
	movl	a, %eax
	addl	g, %eax
	imull	%edx, %eax
	leal	(%eax,%ecx), %edx
	movl	c, %eax
	imull	e, %eax
	leal	(%eax,%edx), %eax
	movl	%eax, a
</pre>


<h3> Brief Comparison of 32-bit and 64-bit x86 code </h3>

What can be gleaned from this side-by-side of 32-bit and 64-bit assembler
for a=a+b+c+d+e+f+g+a+c+e.
Note that the actual variable names are in the assembler because the variables
in question are globals.
<p>

<table border>
<tr>
<th> x86 32-bit
<th> x86_64
<tr>
<td>
<pre>
	movl	b, %eax
	addl	a, %eax
	addl	c, %eax
	addl	d, %eax
	addl	e, %eax
	addl	f, %eax
	addl	g, %eax
	addl	a, %eax
	addl	c, %eax
	addl	e, %eax
	movl	%eax, a
</pre>
<td>
<pre>
	movq	a(%rip), %rdx
	movq	b(%rip), %rax
	addq	%rax, %rdx
	movq	c(%rip), %rax
	addq	%rax, %rdx
	movq	d(%rip), %rax
	addq	%rax, %rdx
	movq	e(%rip), %rax
	addq	%rax, %rdx
	movq	f(%rip), %rax
	addq	%rax, %rdx
	movq	g(%rip), %rax
	addq	%rax, %rdx
	movq	a(%rip), %rax
	addq	%rax, %rdx
	movq	c(%rip), %rax
	addq	%rax, %rdx
	movq	e(%rip), %rax
	leaq	(%rdx,%rax), %rax
	movq	%rax, a(%rip)
</pre>
</table>

<p>

Q: Should we be disappointed that the 64-bit code looks a lot longer?
<P>
A: Maybe instead we should be <em>fascinated</em>.
<ul>
<li> Looks can be deceiving; x86_64 tends to run a lot faster than x86
<li> Instruction prefetch on x86_64 is extensive; instructions that use
     register operands are short and many may be prefetched together.
<li> Superscalar architectures can execute multiple instructions in parallel
<li> The instructions selected here may be specifically maximizing the
     superscalar behavior
</ul>


<p>

The globals are declared something like the following.
<ul>
<LI><CODE>.comm</code> stands for data in a "common" (a.k.a. global data) section.
<li><code>.globl</code> and <code>.type</code> are used for functions, and are really part of
the function header before the function code starts.
</ul>

If you allocated your globals as a region, you might have one .comm of 56
bytes named globals (or whatever) and give the addresses of your globals as
numbers such as <code>globals+32</code>.  Names are nicer but having to
treat globals and locals very differently is not.

<p>
<pre>
	.comm	a,8,8
	.comm	b,8,8
	.comm	c,8,8
	.comm	d,8,8
	.comm	e,8,8
	.comm	f,8,8
	.comm	g,8,8
	.text
.globl main
	.type	main, @function
</pre>


<h3> Brief Comparison of x86-64 globals vs. locals </h3>

How does this difference inform, and affect, what we might want in
our three-address code?
<p>

<table border>
<tr>
<th> x86_64 local vars
<th> x86_64 globals (as per last example)
<tr>
<td>
<pre>
	movq	-48(%rbp), %rax
	movq	-56(%rbp), %rdx
	leaq	(%rdx,%rax), %rax
	addq	-40(%rbp), %rax
	addq	-32(%rbp), %rax
	addq	-24(%rbp), %rax
	addq	-16(%rbp), %rax
	addq	-8(%rbp), %rax
	addq	-56(%rbp), %rax
	addq	-40(%rbp), %rax
	addq	-24(%rbp), %rax
	movq	%rax, -56(%rbp)
</pre>
<td>
<pre>
	movq	a(%rip), %rdx
	movq	b(%rip), %rax
	addq	%rax, %rdx
	movq	c(%rip), %rax
	addq	%rax, %rdx
	movq	d(%rip), %rax
	addq	%rax, %rdx
	movq	e(%rip), %rax
	addq	%rax, %rdx
	movq	f(%rip), %rax
	addq	%rax, %rdx
	movq	g(%rip), %rax
	addq	%rax, %rdx
	movq	a(%rip), %rax
	addq	%rax, %rdx
	movq	c(%rip), %rax
	addq	%rax, %rdx
	movq	e(%rip), %rax
	leaq	(%rdx,%rax), %rax
	movq	%rax, a(%rip)
</pre>
</table>


<h3>Parameters</h3>

In final code, do parameters look like locals?
<p>

Consider the following example. Note that "long" is used to more closely
resemble the g0 "everything is a 64-bit value" mind-set.

<pre>
#include &lt;stdio.h&gt;

long f(long,long,long);

int main()
{
   long rv = f(1, 2, 3);
   printf("rv is %d\n", rv);
}

long f(long a, long b, long c)
{
   long d, e, f, g;
   d = 4; e = 5; f = 6; g = 7;
   a = ((a+b)*(c+d))+(((e+f)*(g+a))/(c*e));
   return a;
}
</pre>

for which the generated code was

<pre>
	.file	"expr.c"
	.section	.rodata
.LC0:
	.string	"rv is %d\n"
	.text
.globl main
	.type	main, @function
main:
.LFB0:
	.cfi_startproc
	pushq	%rbp
	.cfi_def_cfa_offset 16
	.cfi_offset 6, -16
	movq	%rsp, %rbp
	.cfi_def_cfa_register 6
	subq	$16, %rsp
	movl	$3, %edx
	movl	$2, %esi
	movl	$1, %edi
	call	f
	movq	%rax, -8(%rbp)
	movl	$.LC0, %eax
	movq	-8(%rbp), %rdx
	movq	%rdx, %rsi
	movq	%rax, %rdi
	movl	$0, %eax
	call	printf
	leave
	.cfi_def_cfa 7, 8
	ret
	.cfi_endproc
.LFE0:
	.size	main, .-main
.globl f
	.type	f, @function
f:
.LFB1:
	.cfi_startproc
	pushq	%rbp
	.cfi_def_cfa_offset 16
	.cfi_offset 6, -16
	movq	%rsp, %rbp
	.cfi_def_cfa_register 6
	pushq	%rbx
	movq	%rdi, -48(%rbp)
	movq	%rsi, -56(%rbp)
	movq	%rdx, -64(%rbp)
	movq	$4, -40(%rbp)
	movq	$5, -32(%rbp)
	movq	$6, -24(%rbp)
	movq	$7, -16(%rbp)
	movq	-56(%rbp), %rax
	movq	-48(%rbp), %rdx
	leaq	(%rdx,%rax), %rcx
	movq	-40(%rbp), %rax
	movq	-64(%rbp), %rdx
	leaq	(%rdx,%rax), %rax
	imulq	%rax, %rcx
	movq	-24(%rbp), %rax
	movq	-32(%rbp), %rdx
	leaq	(%rdx,%rax), %rbx
	.cfi_offset 3, -24
	movq	-48(%rbp), %rax
	movq	-16(%rbp), %rdx
	leaq	(%rdx,%rax), %rax
	imulq	%rbx, %rax
	movq	-64(%rbp), %rdx
	movq	%rdx, %rbx
	imulq	-32(%rbp), %rbx
	movq	%rbx, -72(%rbp)
	movq	%rax, %rdx
	sarq	$63, %rdx
	idivq	-72(%rbp)
	leaq	(%rcx,%rax), %rax
	movq	%rax, -48(%rbp)
	movq	-48(%rbp), %rax
	popq	%rbx
	leave
	.cfi_def_cfa 7, 8
	ret
	.cfi_endproc
.LFE1:
	.size	f, .-f
	.ident	"GCC: (GNU) 4.4.7 20120313 (Red Hat 4.4.7-3)"
	.section	.note.GNU-stack,"",@progbits
</pre>

We learned that (the first 6+) parameters are passed in registers, but
you can allocate local variable space for them, and copy them into
their local space, after which they can be treated exactly like other
locals.

<p>
<font size=1> <A name=50>lecture #50</A> began here</font>
<p>

<h3> Mailbag </h3>

<blockquote>
I saw your in your three address code examples of calling a function that
pass array variables that before PARAM, you always put the array
address into a temporary variable.

like:
<pre>
char s[64];
readline(s)

	ADDR   loc:68,loc:0
	PARAM8 loc:68
	CALL   readline,1,loc:68
</pre>

and  printf("%d\n", 10+2);

<pre>
     addr	    loc:0,string:0
     parm	    loc:0
     add	    loc:8,im:10,im:2
     parm	    loc:8
     call	    printf,16,loc:16
</pre>

So, before passing the variables to the function, do you have to copy
the variables to the temporary variables? And then PARAM the temporay
variables. Or it is only true for passing array address?

<p>

I know the PARAM will copy the passing arguments into the called function's
activation record's parameter region. So there is no need copy the parameter
variables into temporary variables then PARAM the temporary variables.

</blockquote>

Answer: 

The three-address instructions use addresses, but they normally operate by
implicitly fetching and storing values pointed to by those addresses.

<p>

The ADDR instruction does not copy the variable into a temporary variable,
it copies the address given, without fetching its contents, into its
destination.  This is needed in order to pass an reference parameter.
In Pascal, by default we would have to allocate (on the stack) an entire
physical copy of the whole array in order to pass it as a parameter. This is
potentially very expensive, which is why C-based languages don't do it.
<p>

(Q: if you wanted a physical copy of an array to be passed, do you know
some ways to get one?)



<h3> Aside on .cfi* assembler directives </h3>

<ul>
<li> Explanation of
     <A href="http://www.logix.cz/michal/devel/gas-cfi/">CFI directives</A>
     (CFI stands for Call Frame Information)
<li> Summary: the .cfi* statements are used for
exception handling and you can get rid of them using the gcc flag
-fno-asynchronous-unwind-tables
</ul>

<p>
<font size=1> <A name=51>lecture #51</A> began here</font>
<p>


<h3> Creating an object via <code>new</code></h3>

Consider the following C++ example of final code for an object
constructor. Executing the reserved word <code>new</code> from 
function <code>main()</code> calls two functions to
create an object in the heap (via <code>new</code>):

<dl>
<dt> _Znwm
<dd>  similar to a <code>malloc()</code>; it takes an integer parameter
(constant 16, the # of bytes to allocate) and returns a pointer
<dt> _ZN1CC1Ev
<dd> a call to a C++ constructor function, with an implicit/added first
parameter for <code>this</code>, the object instance that the member
function is working on.
</dl>

<h3> "new" in final code FYI </h3>

<pre>
class C {
  private: long x, y;
  public:  C() { x=3; y=4; }
};

int main()
{
   C *a = new C;
}
</pre>

generates

<pre>
	.file	"new.cpp"
	.section	.text._ZN1CC2Ev,"axG",@progbits,_ZN1CC5Ev,comdat
	.align 2
	.weak	_ZN1CC2Ev
	.type	_ZN1CC2Ev, @function
_ZN1CC2Ev:
.LFB1:
	.cfi_startproc
	.cfi_personality 0x3,__gxx_personality_v0
	pushq	%rbp
	.cfi_def_cfa_offset 16
	.cfi_offset 6, -16
	movq	%rsp, %rbp
	.cfi_def_cfa_register 6
	movq	%rdi, -8(%rbp)
	movq	-8(%rbp), %rax
	movq	$3, (%rax)
	movq	-8(%rbp), %rax
	movq	$4, 8(%rax)
	leave
	.cfi_def_cfa 7, 8
	ret
	.cfi_endproc
.LFE1:
	.size	_ZN1CC2Ev, .-_ZN1CC2Ev
	.weak	_ZN1CC1Ev
	.set	_ZN1CC1Ev,_ZN1CC2Ev
	.text
.globl main
	.type	main, @function
main:
.LFB3:
	.cfi_startproc
	.cfi_personality 0x3,__gxx_personality_v0
	pushq	%rbp
	.cfi_def_cfa_offset 16
	.cfi_offset 6, -16
	movq	%rsp, %rbp
	.cfi_def_cfa_register 6
	pushq	%rbx
	subq	$24, %rsp
	movl	$16, %edi
	.cfi_offset 3, -24
	call	_Znwm
	movq	%rax, %rbx
	movq	%rbx, %rax
	movq	%rax, %rdi
	call	_ZN1CC1Ev
.L5:
	movq	%rbx, -24(%rbp)
	movl	$0, %eax
	addq	$24, %rsp
	popq	%rbx
	leave
	.cfi_def_cfa 7, 8
	ret
	.cfi_endproc
.LFE3:
	.size	main, .-main
	.ident	"GCC: (GNU) 4.4.7 20120313 (Red Hat 4.4.7-3)"
	.section	.note.GNU-stack,"",@progbits
</pre>

As you may observe: the final code for a <code>new</code> calls a memory
allocator (nwm) whose return value (%rax) gets copied in as a parameter
(%rdi) to the constructor (N1CC1Ev), with an interesting side trip to %rbx.

<h3> On C/C++ Calling Convention and Order of Passed Parameters </h3>

In compilers, the calling conventions are the set of rules by which parameters
and return values are communicated between caller and callee. The calling
conventions also cover things like whether the caller or the callee has to
save and restore specific registers as part of the process of call/return.

<UL>
<li> a good <A href="https://en.wikipedia.org/wiki/X86_calling_conventions">general discussion</A> is available on Wikipedia
<li> Each C compiler makes its own rules. We could do what we want unless we
need to be compatible with another compiler to call their library functions,
in which case we have to follow their calling conventions
<li> In C/C++, parameters are passed in reverse order
<li> (as we have seen,) in gcc/g++, several parameters are passed in
     registers, but generally get allocated local region space and saved there
     by callee
<li> in gcc/g++ the callee explicitly restores stack and old call frame,
     the RET instruction doesn't do that magically, it just manages to
     restore the program counter register back to the caller.
<li> In (newer versions of) G++, the parameter section is 16-byte aligned
</UL>

<h3> How <code>this</code> looks and is used inside member functions </h3>

<ul>
<li> it is the first parameter, so it is passed in %rdi
<li> g++ seems to reserve local memory space and copy/save the registers
     into that local memory space for ALL parameters passed in registers, so
     it does that for <code>this</code>
<li> it may make it more likely that you run out of registers to pass all your
     parameters in, and are passing later regular paramters on the stack.
<li> references (through <code>this</code>) to member variables are done using
     the "usual" indirect addressing mode, which takes an optional small
     constant as a byte offset when reading/writing using a pointer.  If the
     <code>this</code> pointer is in %rax and our byte offset for a member
     variable is 8, then <code>8(%rax)</code> is the assembler syntax to
     read or write to that variable.
</ul>


<h3> About name mangling in C++ vs. your compiler </h3>

<ul>
<li> C++ has to name mangle because it does function overloading.
<li> your compiler doesn't have to use the C++ _Znwm, it can call
     <code>malloc()</code> for all I care
<li> your compiler almost doesn't have to name mangle at all, what
     is the exception?
</ul>

<p>
<font size=1> <A name=52>lecture #52</A> began here</font>
<p>

<h3> End of Semester Planning </h3>

<ul>
<li> Final Exam Review: Thursday December 12
<li> Homework #6 due: Friday December 13, 11:59pm
<li> Final Exam: Tuesday December 17, 3-5pm
<li> Compiler Demos: by appointment, Dec 16-20
</ul>


<h3> Mailbag </h3>

<dl>
<dt> I am doing LLVM for HW#6 and my LLVM is incompatible with the one on
     the grading machine! What do I do?
<dd> You can demo your HW#6 results during finals week on your machine.
     Or you can do your HW6 on the grading machine. Or you can do x86_64.
     I will take and grade anything you give me on HW#6.

<!--
<dt>
If we have a variable that is inside of a function that is inside of a
class, would that variable address be part of the LOCAL memory region or
CLASS memory region?

<dd>
Local variables declared inside a function inside a class, are just LOCAL
region variables.  CLASS region is only for variables that are not local to
any function, the memory that is allocated per-instance (a.k.a. per-object),
not per-function-call. CLASS region variables are accessed as offsets from
a "this" pointer instead of from a base pointer register.
-->

<dt>Has this class been a one long <A href="https://en.wikipedia.org/wiki/Kobayashi_Maru">Kobayashi Maru</A> Test?
<dd> Thanks for the pop culture reference!  CSE 423 is similar to the
Kobayashi Maru in that it may seem unwinnable. It is different than
the Kobayashi Maru in that the goal is not merely to test your character,
but more importantly, to make you gain experience points and go up levels
in programming skill, such that you are ready to work professionally.
</dl>




<h3>More about LEAL</h4>

In a previous example, complicated arithmetic drove GCC to start
"leal'ing".
<ul>
<li>leal (load effective address) is a complex instruction usually used for
pointer arithmetic, i.e. its output is usually a pointer.
<li> due to x86 CISC addressing modes, leal can actually add two registers,
multiplying one of those registers by 1, 2, 4, or 8, and then adding
a constant offset in as well.  It is a "more than 3 address instruction".
<li> the instruction selection module of gcc knows it can be used for
addition.
<li>Unlike "add" instruction, it does not set the condition flag,
<li>This property might allow it to execute in parallel with some
other arithmetic operation that <em>does</em> use the condition flag.
So sure enough: it (potentially) improves superscalar execution, and
gcc/g++ are smart enough to use it instead of ADD sometimes.
</ul>
<p>

Lastly (for now) consider:
<pre>
   a = ((a+b)*(c+d))+(((e+f)*(g+a))/(c*e));
</pre>
The division instruction adds new wrinkles.  It operates on an implicit
register accumulator which is twice as many bits as the number you divide
by, meaning 64 bits (two registers) to divide by a 32-bit number.  Note
in this code that 32-bit gcc would rather spill than use %ebx.  %ebx is
reserved by the compiler for some (hopefully good) reason.
%edi and %esi are similarly ignored/not used.
<table border>
<tr>
<th> 32-bit <th> 64-bit
<tr>
<td>
<pre>
	movl	b, %eax
	movl	a, %edx
	addl	%eax, %edx
	movl	d, %eax
	addl	c, %eax
	movl	%edx, %ecx
	imull	%eax, %ecx
	movl	f, %eax
	movl	e, %edx
	addl	%eax, %edx
	movl	a, %eax
	addl	g, %eax
	imull	%eax, %edx
	movl	c, %eax
	imull	e, %eax
	movl	%eax, -4(%ebp)
	movl	%edx, %eax
	cltd
	idivl	-4(%ebp)
	movl	%eax, -4(%ebp)
	movl	-4(%ebp), %edx
	leal	(%edx,%ecx), %eax
	movl	%eax, a
</pre>
<td>
<pre>
	pushq	%rbx
	subq	$88, %rsp
	movq	$1, -72(%rbp)
	movq	$2, -64(%rbp)
	movq	$3, -56(%rbp)
	movq	$4, -48(%rbp)
	movq	$5, -40(%rbp)
	movq	$6, -32(%rbp)
	movq	$7, -24(%rbp)
	movq	-64(%rbp), %rax
	movq	-72(%rbp), %rdx
	leaq	(%rdx,%rax), %rcx
	movq	-48(%rbp), %rax
	movq	-56(%rbp), %rdx
	leaq	(%rdx,%rax), %rax
	imulq	%rax, %rcx
	movq	-32(%rbp), %rax
	movq	-40(%rbp), %rdx
	leaq	(%rdx,%rax), %rbx
	.cfi_offset 3, -24
	movq	-72(%rbp), %rax
	movq	-24(%rbp), %rdx
	leaq	(%rdx,%rax), %rax
	imulq	%rbx, %rax
	movq	-56(%rbp), %rdx
	movq	%rdx, %rbx
	imulq	-40(%rbp), %rbx
	movq	%rbx, -88(%rbp)
	movq	%rax, %rdx
	sarq	$63, %rdx
	idivq	-88(%rbp)
	leaq	(%rcx,%rax), %rax
	movq	%rax, -72(%rbp)
	movl	$.LC0, %eax
	movq	-72(%rbp), %rdx
	movq	%rdx, %rsi
	movq	%rax, %rdi
	movl	$0, %eax
	call	printf
	addq	$88, %rsp
	popq	%rbx
</pre>
</table>

In the 32-bit version, you finally see some register spilling.
In the 64-bit version, there is
<ul>
<li> saving a register so you can use it (%rbx)
<li> allocating a whole local region of 88 bytes
<li> storing immediate values into main memory
<li> addition by leaq'ing registers
</ul>


<h3> <code>LEAVE</code> instruction </h3>

In our example of using <code>new</code> we saw a LEAVE instruction before
the function returned.  LEAVE restores the frame pointer
to the caller's value, something like

<pre>
movq rsp, rbp ; set top of stack back to where caller had it
popq rbp      ; set base pointer back to saved value at (%rsp)
</pre>

Interestingly, there is a corresponding ENTER instruction, but g++ does not
tend to use it because it is slower than corresponding lower-level operations
like <code>subq $nbytes, %rsp</code>.

<h3> Chapter 10 of this <A href="https://www3.nd.edu/~dthain/compilerbook/">free compiler book</A> from Doug Thain</h3>

For what its worth, professor Thain provides a good introduction to
x86_64 assembler, more than our Louden text.

<p>
<font size=1> <A name=53>lecture #53</A> began here</font>
<p>

<h3> Brief Comment on HW Resubmissions </h3>

At various points in this course you have a choice between completing/fixing
a previous homework, or working on the next homework.  But sometimes you
have to complete/fix an old homework for the next one to be implementable.
<!--
In addition to your HW#4/#5, I will accept up to 2 old/late homework
resubmissions from you from now up until the end of dead week.  I will award
full credit for such late submissions. -->
I have been accepting resubmissions this semester, to make corrections,
restoring points up to a "C" grade for a given assignment.
Please test your work prior to each resubmission; I won't be able to
just keep regrading it until it passes.


<h3> More on DIV instruction </h3>

When I looked for more, I found this
<A href="http://www.cs.uaf.edu/2009/fall/cs301/support/x86_64/index.html">
Cheat Sheet</A>, which pointed at the big books
(<A href="instructionsAM.pdf">A-M</A><A href="instructionsNZ.pdf">N-Z</A>).

<uL>
<li> The cheat sheet says div divides reg. ax by [src], ratio in ax, remainder in
dx.
<li> It also says dx must be 0 to start or you get a SIGFPE.
<li>  The big book
says your basic full-size divide instruction divides a big value stored in
a pair of registers (32 bit: EDX:EAX or 64 bit: RDX:RAX), by which point I
am thinking I have to give the general introduction to X86_64 before this
should be remotely understandable.
</ul>

<h3> Helper Function for Managing Registers </h3>

Define a <code>getreg()</code> function that returns a location L
to hold the value of x for the assignment <br>  <code>x := y op z</code>

<ol>
<li> if y is in a register R that holds the value of no other names,
AND y is not live after the execution of this instruction, THEN
return register R as your location L
<li> ELSE return an empty register for L if there is one
<li> ELSE if x has a next use in the block or op is an operator
     that requires a register (e.g. indexing), find an occupied
     register R. Store R into the proper memory location(s), update
     the address descriptor for that location, and return R
<li> if x is not used in the block, or no suitable occupied register
can be found in (3), return the memory location of x as L.
</ol>



<h3> Putting It All Together: A Simple Code Generator </h3>

<ul>
<li> Register allocation will be done only within a basic block.
     All variables that are live at the end of the block are stored
     in memory if not already there.
<li> Data structures needed:
<dl>
<dt> Register Descriptor
<dd> Keeps track of what is in each register. Consulted when a new register
is needed. All registers assumed empty at entry to a block.
<dt> Address Descriptors
<dd> Keep track of the location(s) where the current value of a name can be
found at runtime. Locations can be registers, memory addresses, or stack
displacements. (can be kept in the symbol table).
</dl>
</ul>
<p>

Example
<p>
<pre>
// make an array (12?) of these:
struct regdescrip {
   char name[12]; // name to use in codegen, e.g. "%rbx"
   int status;    // 0=empty, 1=loaded, 2=dirty, 4=live, ...
   struct address addr;
   };
// upgrade symbol table entry to use these instead of struct address
struct addr_descrip {
   int status;    // 0=empty, 1=in memory, 2=in register, 3=both
   struct reg_descrip *r; // point at an elem in reg array. could use index.
   struct address a;
   };
</pre>

<h3> Code Generation Algorithm </h3>

For each three-address statement of the form <br>
<code>x := y op z</code>:

<ol>
<li> Use <code>getreg()</code> to determine location L where the
     result of the computation <code>y op z</code> should be stored.
<li> Use the address descriptor for y to determine y', a current location for
y. If y is currently in a register, use the register as y'. If y is not already
in L, generate the instruction <code>MOV y',L</code> to put a copy of y in L.
<li> Generate the instruction <code>OP z',L</code> where z' is a current location for z.
Again, prefer a register location if z is currently in a register.
<p> Update the descriptor of x to indicate that it is in L. If L is a register,
update its descriptor to indicate that it contains x. Remove x from all other
register descriptors.
<li> If y and/or z have no next uses and are in registers, update the register
descriptors to reflect that they no longer contain y and/or z respectively.
</ol>


<h3> Register Allocation </h3>

Need to decide:
<ul>
<li> which values should be kept in registers (register allocation)
<li> which register each value should be in (register assignment)
</ul>

<h4> Approaches to Register Allocation </h4>

<ol>
<li> Partition the register set into groups that are use for different kinds
of values. E.g. assign base addrs to one group, pointers to the stack to
another, etc. <p>
Advantage: simple<br>
Disadvantage: register use may be inefficient
<li> Keep frequently used values in registers, across block boundaries. E.g.
assign some fixed number of registers to hold the most active values in each
inner loop.<p>
Advantage: simple to implement<br>
Disadvantage: sensitive to # of registers assigned for loop variables.
</ol>

<p>
<font size=1> <A name=54>lecture #54</A> began here</font>
<p>

<h3> Challenge Question we Ended with Last Time </h3>

So, how can you know what are the frequently used variables in a function?

<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>

<ul>
<li> Count the number of occurrences in source code?  (easy static analysis,
     but bad results)
<li> Do math proofs of the frequency relationships between variables
     (hard static analysis)
<li> Run the program on representative inputs, and count all uses
     of variables in that function. (dynamic analysis)
<li> Make a crude approximation or estimate (easy static analysis)
</ul>

<h3> x86_64 Floating Point </h3>

<h4> Float Operations </h4>

There is <A href="http://web.cecs.pdx.edu/~apt/cs322/x86-64.pdf">
a useful set of notes</A> from Andrew Tolmach of Portland State University.
Arithmetic operations on floats
have different opcodes, and results have to be stored in
floating point registers, not integer registers.

<pre>
	movsd	-56(%rbp), %xmm0
	movapd	%xmm0, %xmm1
	addsd	-48(%rbp), %xmm1
</pre>

<h4> Float Constants </h4>

Doubles are the same 64-bit size as longs.  They can be loaded into memory
or registers using the normal instructions like movq.  A spectacular x86_64
opcode named movabsq takes an entire floating point constant as an immediate
(bit pattern given as a decimal integer!) and stores it in a register.
(Q: What C code (or library function) would take your double and
produce the equivalent decimal integer string?)

<pre>
	movabsq	$4620355447710076109, %rax
	movq	%rax, -8(%rbp)
</pre>



<h3> Simple Machine Model </h3>

This model is probably relevant for selecting between equivalent sequences
of instructions but is presented here as food for thought regarding which
variables deserve to stay in registers.

<dl>
<dt> Instruction Costs
<dd> for an instruction I, cost(I) = 1 + sum(cost(operands(I))) <p>
operand costs:
<ul>
<li> if operand is a register, cost = 0
<li> if operand is memory, cost = 1
</ul>
<br>
<dt> Usage Counts
<dd> In this model, each reference to a variable x accrues a savings of
1 if x is in a register.

<ul>
<li> For each use of x in a block that is <b>not preceded by an assignment</b>
in that block, savings = 1 if x is in a register.
<li> If x is live on exit from a block in which it is assigned a value,
and is allocated a register, then we can avoid a store instruction (cost = 2)
at the end of the block. <p>

Total savings for x ~ sum(use(x,B) + 2 * live(x,B) for all blocks B)
<p>

This is very approximate, e.g. loop frequencies are ignored.
</ul>
</dl>
<p>

<h4>Cost savings flow graph example</h4>

For the following flow graph, how much savings would be earned by leaving
variables (a-f) in a register across basic blocks?
<p>
<img src="liveness.png">

<table>
<tr><th> Savings <th> B1 <th> B2 <th> B3 <th> B4 <th> Total
<tr><td>    a	 <td> 2	 <td> 1	 <td> 1	 <td> 0	 <td> 4
<tr><td>    b	 <td> 2	 <td> 0	 <td> 2	 <td> 2	 <td> 6
<tr><td>    c	 <td> 1	 <td> 0	 <td> 1	 <td> 1	 <td> 3
<tr><td>    d	 <td> 3	 <td> 1	 <td> 1	 <td> 1	 <td> 6
<tr><td>    e	 <td> 2	 <td> 0	 <td> 2	 <td> 0	 <td> 4
<tr><td>    f	 <td> 1	 <td> 2	 <td> 1	 <td> 0	 <td> 4
</table>





<h3> x86_64 Discussion </h3>

<ul>
<li> <A href="http://www.cs.cmu.edu/~fp/courses/15213-s07/misc/asm64-handout.pdf">machine level programming</A> as taught at CMU
<li> 
<A href="code.html"> Dr. J's TAC-to-x86_64 templates </A> (not finished yet)
<li>
<A href="http://www.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html">Intel Developer Manuals</A>
</ul>


<h3> For what its worth on Windows 64 </h3>

Warning: the Mingw64 compiler (and possibly other Windows 64-bit c
compilers) do not use the same memory sizes as Linux x86_64!  Beware.
If you were compatible with gcc on Linux you might not be on Windows
and vice versa.


<h3> Three Kinds of Dependence </h3>

In all three of these examples, a dependence relationship implies that
in the program semantics, the second instruction depends on the first
one in some way.
<p>

<ul>
<li>  How are they different?
<li>How do these affect, e.g., decisions about which registers are in use?
<li>What about concurrency/superscalar CPU's ?
</ul>
<p>

<table border>
<td>
<pre>
a = b + c;
...
d = a + e;
</pre>
<td>
<pre>
a = b + c;
...
b = d + e;
</pre>
<td>
<pre>
a = b + c;
...
a = d + e;
</pre>
</table>



<!--
<h3> Register Allocation and Graph Coloring </h3>

<ul>
<li> A <em>vertex coloring</em> is an assignment of labels or colors
     to each vertex of a graph such that no edge connects two identically
     colored vertices. 
<li>
A <em>k-coloring</em> of a graph G is a vertex coloring that is an assignment of one of k possible colors to each vertex of G (i.e., a vertex coloring) such that no two adjacent vertices receive the same color. 
<li>
The classic "high-powered" way to do register allocation is by
k-coloring a special kind of dependence/liveness graph of variables.
To do that, one must do a bunch of analysis to
tell which variables are live at the same time.
</ul>

<h3> Register Allocation by Graph Coloring </h3>

When a register is needed but all registers are in use, a register 
has to be freed by storing its contents in memory ("spilling"). <p>

Graph coloring is a systematic way of register allocation and managing
spills. <p>

Graph coloring uses two passes:

<dl>
<dt> Pass 1</ht>
<dd> Target machine instructions are selected as though there are an
infinite number of symbolic registers.
<dt> Pass 2
<dd> Physical registers assigned to symbolic ones in a manner that minimises
the cost of spills. This is done by constructing a <em> register-interference
graph</em> for each procedure, then k-coloring this graph (k = # of registers).
</dl>

<p>


<h3> Register Interference Graphs </h3>

<ul>
<li> nodes: "symbolic registers"
<li> there is an edge connecting two nodes if one is live when the other is
defined
<li> if there are k assignable registers, then we have to try and k-color
the interference graph.
<li> k-colorability is NP-complete in general, but the following heuristic
is efficient in practice:
<ul>
<li> if a node n has less than k neighbors, remove n and its edges from the
graph to get a new graph G': a k-coloring of G' can easily be extended to a
k-coloring of the original graph.
<li> By repeating this process, we either get the empty graph (in which case
we can work backwards to produce a k-coloring of the original graph), or we
get a graph where each node has &gt;= k neighbors: in this case we need to
spill a node, modify the interference graph, and proceed as before.<p>

General rule for spills: avoid introducing code into inner loops.
</ul>
</ul>

<h3> Register Allocation Coloring Example </h3>

Courtesy of those fine folks at
<A href="http://pages.cs.wisc.edu/~cs701-1/NOTES/5.REGISTER-ALLOCATION.html#coloring">University of Wisconsin</A>.
<p>

Their way of thinking about register interference is to define
<em>live ranges</em> === set of all nodes (in a control flow graph)
between definitions and uses.
Actually, feels more like it works back from uses to their definitions,
and merges all overlaps on any given variable.
<p>

OK, so what live ranges occur in the following graph? <p>

<img src="ralloc.gif"><p>

Each live range is one node in a register interference graph, and edges
(denoting interference) connect nodes whose underlying CFG nodesets overlap.
-->

<h3> Review of x86_64 Calling Conventions </h3>

64-bit x86 was first done by AMD and licensed afterwards by Intel, so it
is sometimes referred to as AMD64.  Warning: Linux and Windows do things
a lot different!

<ul>
<li> <A href="http://en.wikipedia.org/wiki/Calling_convention">Calling conventions</A> in general
</ul>


<h3> Final Code Generation Example </h3>

<ul>
<li> <A href="finalcg.icn">finalcg.icn</A>, a program that generates
     <A href="tac.s">native code</A>
<li> Assemble output with command line such as <code>as -o demo1.o demo1.s</code>
<li> needs streamlining, removal of exception directive code per
earlier discussion.
<!--
<li> compare previous with
     <A href="final-tac.icn">TAC-C</A>, whose output looks like
     <A href="final-tac-out.c">this</A>
-->
</ul>

<p>

<h3> Lessons From the Final Code Generation Example </h3>

<ul>
<li> TAC-to-native-code not that hard; 110 lines netted about half
     the TAC instruction set in procedure final(); many other opcodes very
     similar.
<li> Most complexity centers around calls / returns
<li> Although you pass parameters in registers, IF YOU CALL ANYTHING, and
     IF YOU USE YOUR PARAMETERS AFTERWARDS, you will
     have to allocate space on the stack for your incoming parameters,
     and save their values to memory before reusing that register.
<li> How hard would it be, for each function body, to determine whether it
     calls anything, or is a "leaf" function that does not?  How common are
     such leaf functions?
<li> Interesting special case: does a function ever turn around and call
     another function with the same parameters?  How often?  Under what
     circumstances might a compiler exploit this?
</ul>

<h3> Reverse Engineering, gcc -S, and Optimization </h3>

I decided to fill in a missing piece of the
<a href="code.html">x86_64 final code generation template page</a>
that I am providing you, and chose a real easy one: <code>if !x goto L</code>.
I figured it would be a two-instruction analogue of <code>if x goto L</code>.
So I constructed a simple program to try and produce the desired code.

<pre>
#include <stdio.h>
int fac(long y)
{
   long x;
   if (!y) goto L;
   printf("hello");
 L:
   return 1;
}
</pre>

<p>
I was frustrated to find seemingly idiotic code as gcc's default: it was
generating an extra jump and an extra label. Eventually, I tried it with -O
just to see what we would get.

<p>

The corresponding gcc -S output is as follows:

<p>

<table border>
<tr><th>gcc -S<th>gcc -O -S
<tr><td>
<pre>
	.file	"foo.c"
	.section	.rodata
.LC0:
	.string	"hello"
	.text
	.globl	fac
	.type	fac, @function
fac:
.LFB0:
	.cfi_startproc
	pushq	%rbp
	.cfi_def_cfa_offset 16
	.cfi_offset 6, -16
	movq	%rsp, %rbp
	.cfi_def_cfa_register 6
	subq	$16, %rsp
	movq	%rdi, -8(%rbp)
	cmpq	$0, -8(%rbp)
	jne	.L2
	jmp	.L3
.L2:
	movl	$.LC0, %edi
	movl	$0, %eax     # num of float args, for vararg funcs
	call	printf
.L3:
	movl	$1, %eax
	leave
	.cfi_def_cfa 7, 8
	ret
	.cfi_endproc
.LFE0:
	.size	fac, .-fac
	.ident	"GCC: (GNU) 4.8.5 20150623 (Red Hat 4.8.5-28)"
	.section	.note.GNU-stack,"",@progbits
</pre>
<td>
<pre>
	.file	"foo.c"
	.section	.rodata.str1.1,"aMS",@progbits,1
.LC0:
	.string	"hello"
	.text
	.globl	fac
	.type	fac, @function
fac:
.LFB11:
	.cfi_startproc
	testq	%rdi, %rdi
	je	.L4
	subq	$8, %rsp
	.cfi_def_cfa_offset 16
	movl	$.LC0, %edi
	movl	$0, %eax     # num of float args, for vararg funcs
	call	printf
.L2:
	movl	$1, %eax
	addq	$8, %rsp
	.cfi_def_cfa_offset 8
	ret
.L4:
	movl	$1, %eax
	ret
	.cfi_endproc
.LFE11:
	.size	fac, .-fac
	.ident	"GCC: (GNU) 4.8.5 20150623 (Red Hat 4.8.5-28)"
	.section	.note.GNU-stack,"",@progbits
</pre>
</table>


<h3> Flow Graphs </h3>

In preparation for lectures discussing code optimization, a more detailed
discussion of flow graphs is needed.

<ul>
<li>  A flow graph is a graph in which vertexes are basic blocks
<li> There is a distinguished <em>initial</em> node, the basic block
whose leader is the first instruction.
<li> There is a directed edge from block B<sub>1</sub> to B<sub>2</sub> if:
<ol>
<li> There is a conditional or unconditional jump from the last statement
     of B<sub>1</sub> to the first statement of B<sub>2</sub>
<li> B<sub>2</sub> immediately follows B<sub>1</sub> in the order of the
     program, and B<sub>1</sub> does not end in an unconditional jump.
</ol>
</ul>

<h3> Flow Graph Example </h3>

<pre>
if (x + y &lt;= 10 &amp;&amp; x - y &gt;= 0) x = x + 1;
</pre>

Construct the flow graph from the basic blocks

<p>

<table border>
<tr><td><pre>

t<sub>1</sub> := x + y
if t<sub>1</sub> &gt; 10 goto L1

</pre>
<tr><td><pre>

t<sub>2</sub> := x - y
if t<sub>2</sub> &lt; 0 goto L1

</pre>
<tr><td><pre>

t<sub>3</sub> := x + 1
x := t<sub>3</sub>

</pre>
<tr><td><pre>

L1:

</pre>
</table>

<h3> Next-Use Information </h3>

<dl>
<dt> use of a name
<dd> consider two statements
<pre>
I1: x := ... /* assigns to x */
...
I2: ... := ... x ... /* has x as an operand */
</pre>
such that control <em>can</em> flow from I1 to I2 along some path that has no
intervening assignments to x.  Then, I2 <em>uses</em> the value of x
computed at I1. I2 may use several assignments to x via different paths.

<dt> live variables
<dd> a variable x is <em>live</em> at a point in a flow graph if the
value of x at that point is <em>used</em> at a later point.

</dl>

<h3> Computing Next-Use Information (within a block only)</h3>

<ul>
<li> assume we know which names are live on exit from the block
 (needs dataflow analysis; else assume all nontemporary variables
  are live on exit)
<li> scan backwards from the end of the basic block. For each statement
<pre>
 i:  x := y <em>op</em> z
</pre>
do:
<ol>
<li> attach to stmt. i the current information (from symbol table) about
next use and liveness of x, y, and z
<li> in the symbol table, set x to "not live", "no next use"
<li> in the symbol table, set y and z to "live", set next use of y,z to i
<li> treatment of <code>x := y</code> or <code>x := op y</code> is similar
</ol>
Note: order of (2) and (3) matters, x may be on RHS as well
</ul>

<p>
<font size=1> <A name=55>lecture #55</A> began here</font>
<p>

<h3>Mailbag</h3>

<dl>

<dt>Could we cover assembly stack allocation/management?
<dd>
Sure. I've pointed you at a lot of resources; here is another, on
<A href="https://eli.thegreenplace.net/2011/09/06/stack-frame-layout-on-x86-64/">Eli Bendersky's site</A>.

<p>
<ul>
<li> In the general case, calling arbitrary other code,
ALL registers that hold live values across a call will have to be saved,
and restored after the call.  This sounds incredibly expensive, and is
only getting more expensive as CPUs add more and more registers. In
x86_64, the registers are partitioned into those the caller is
responsible for protecting, and those the callee is responsible for.
<li> Good compilers, then, are all about taking shortcuts and doing
the minimum needed for each specific case. A compiler can save costs
on the caller side and on the callee side.
<li> Stack registers.  As a reminder, there is an rsp
that is the true top of the stack, and a rbp that is the base pointer
register for the current function call.  The stack grows down.
</ul>

<p>


<dt>When and what do we have to push and pop from the stack
when we call a function?
<dd>
We (that mens you) should probably look at a bunch of examples, probably by
reverse engineering them with gcc -S, to get a feel for this.  A summary on
which we can expand/correct is:

<ul>
<li> caller pushes parameters.   By default the
first six parameters go into designated registers instead of main memory.
BTW, if you had anything in those registers, you have to save those values
(i.e. push them) before sticking parameters in registers for a new call.
<li> caller saves r10/r11 if it us using them.
<li> caller executes CALL instruction.
<li> CALL instruction pushes return address (IPC) and does a GOTO.
<li> Callee pushes (saves) rbp
<li> Callee sets rbp to the top of the stack
<li> Callee saves other "callee-save" registers if it uses them (rbx,r12-r15)
<li> Callee pushes/creates local region, by subtracting N bytes from rsp.
<li> Callee by default copies parameters from registers into local space.
<li> Callee executes function body.
<li> Callee stores return value in rax, if there is one
<li> Callee frees local region by adding N bytes to rsp
<li> Callee restores rbx, r12-r15 if it uses them
<li> Callee restores rsp and rbp for caller via LEAVE, or its equivalent.
<li> Callee executes RET, which pops saved IPC and does a GOTO to it.
</ul>

<dt>Can we use the stack exclusively for all of our parameters and local
variables?

<dd>
Your compiler can ignore register parameters entirely when you generate code
that calls to and returns from your own functions.  IFF your code needs to call
C library code (such as printf, reads, etc.) you would have to use the
standard calling conventions (including registers) to call those functions
successfully.


</dl>



<h3> Storage for Temporaries </h3>

<ul>
<li> size of activation records grows with the number of temporaries, so
compiler should try to allocate temporaries carefully
<li> in general, two temporaries can use the same memory location if they
are not live simultaneously
<li> allocate temporaries by examining each in turn and assigning it the
first location in the field for temporaries that does not contain a live
temporary. If a temporary cannot be assigned to a previously created
location, use a new location.
</ul>


<h3> Storage for Temporaries Example </h3>

Consider the following (a dot-product code) example. This is a single basic
block, subdivided using the liveness of some non-overlapping temporary
variables.  <p>

<table border>
<tr><td>
t1 live<td>
<pre>
	prod := 0
	i := 1
L3:	t1 := 4 * i
	t2 := a[t1]
</pre>
<tr><td>t3 live<td>
<pre>
	t3 := 4 * i
	t4 := b[t3]
</pre>
<tr><td>t5 live<td>
<pre>
	t5 := t2 + t4
	t6 := prod + t5
</pre>
<tr><td>t7 live<td>
<pre>
	prod := t6
	t7 := i + 1
	i := t7
</pre>
<tr><td><td>
<pre>
	if i &lt;= 20 goto L3
</pre>
</table>

<p>
t1, t3, t5, t7 can share the same location.
What about t2, t4, and t6?
<p>

Notes:
<ul>
<li> the "reusing temporary variables" problem is pretty much the
     same as the register allocation problem
<li> optimal allocation is NP-complete in general
</ul>





<!--
<h3> Peek at <a href="libctab.h">libctab.h</A> and <A href="libctab.c">libctab.c</A></h3>

<ul>
<li> Did you know that when you invoke the C compiler, you get a
library (-lc) linked in by default even when you did not ask for it?
<li> Similarly, ct can invoke the linker including libctab.o automatically
<li> By the way, in real life a libtab would need to have weirder variable
     names, such as all beginning with __ct__
<li> Using C++ for libctab would make certain aspects better
     (package to protect namespace, destructors to free local tables...)
     but beyond the scope of this class.
</ul>
-->



<h3> <A name="dag">DAG</A> representation of basic blocks </h3>

This concept is useful in code optimization.  Although we are not doing a
homework on optimization, you should understand it to be essential in real
life and have heard and seen a bit of the terminology.


<ul>
<li> Each <em>node</em> of a flow graph (i.e. basic block)
can be represented by a directed acyclic graph (DAG).
<li> Why do it?  May enable optimizations...
</ul>
<p>

A DAG for a basic block is one with the following labels on nodes:

<ol>
<li> leaves are labelled by unique identifiers, either variable names or
constants.
<li> interior nodes are labelled by operator symbols
<li> nodes are optionally given a sequence of identifiers as labels
(these identifiers are deemed to have the value computed at that node).
</ol>

<p>

<h4>Example</h4>

For the three-address code

<pre>
L:	t1 := 4 * i
	t2 := a[t1]
	t3 := 4 * i
	t4 := b[t3]
	t5 := t2 * t4
	t6 := prod + t5
	t7 := i + 1
	i := t7
	if i &lt;= 20 goto L
</pre>

What should the corresponding DAG look like?

<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>


<ul>
<li> Chapter 6 of the text presents DAGs constructed from syntax
     trees immediately before, rather than after, three address code.
<li> We presented it later than that, because it enables common optimizations.
</ul>

<h3> Constructing a DAG </h3>

<u>Input</u>: A basic block.
<p>

<u>Output</u>: A DAG for the block, containing:
<ul>
<li> a label for each node, and
<li> for each node, a (possibly empty) list of attached identifiers
</ul>
<p>

<u>Method</u>: Consider an instruction x := y op z.
<ol>
<li> If node(y), the node in the DAG that represents the value of y at that
point, is undefined, then create a leaf labelled y. Let node(y) be this node.
Similar for z.

<li> determine if there is a node labelled <u>op</u> with left child node(y)
and right child node(z).  if not, create such a node. let this node be <u>n</u>

<li> <ul>
     <li> a) delete x from the list of attached identifiers for node(x) [if defined]
     <li> b) append x to the list of attached identifiers for node n (from 2).
     <li> c) set node(x) to n
     </ul>
</ol>

<h3> Applications of DAGs </h3>

<ol>
<li> automatically detects common subexpressions
<li> can determine which identifiers have their value used in the block --
these are identifiers for which a leaf is created in step (1) at some  point.
<li> Can determine which statements compute values that could be used outside
the block -- these are statements s whose node n constructed in step (2)
still has node(x)=n at the end of the DAG construction, where x is the
identifier defined by S.
<li> Can reconstruct a simplified list of 3-addr instructions, taking advantage
of common subexpressions, and not performing copyin assignments of the form
x := y unless really necessary.
</ol>

<h3> Evaluating the nodes of a DAG </h3>

<ul>
<li> The evaluation order of the interior nodes of a DAG must be consistent
with a topological sort of the DAG, so that operands are evaluated before an
operator is applied.
<li> In the presence of pointer or array assignments, or procedure calls, not
every topological sort may be permissible.
<th> Example: given a basic block
<pre>
x := a[i]
a[j] := y
z := a[i]
</pre>
</ul>

The "optimized" basic block after DAG construction and common subexpression
elimination equates x and z, but this behaves incorrectly when i = j.



<h3> Code Optimization </h3>

There are major classes of optimization that can significantly speedup
a compiler's generated code.  Usually you speed up code by doing the
work with fewer instructions and by avoiding unnecessary memory reads
and writes. You can also speed up code by rewriting it with fewer gotos.


<h4> Constant Folding </h4>

Constant folding is performing arithmetic at compile-time when the values
are known.  This includes simple expressions such as 2+3, but with more
analysis
some variables' values may be known constants for some of their uses.
<pre>
     x = 7;
     ...
     y = x+5;
</pre>

<h4> Common Subexpression Elimination </h4>

Code that redundantly computes the same value occurs fairly frequently,
both explicitly because programmers wrote the code that way, and implicitly
in the implementation of certain language features.
<p>

Explicit:
<pre>
    (a+b)*i + (a+b)/j;
</pre>

The (a+b) is a common subexpression that you should not have to compute twice.
<p>

Implicit:
<pre>
    x = a[i]; a[i] = a[j]; a[j] = x;
</pre>

Every array subscript requires an addition operation to compute the memory
address; but do we have to compute the location for a[i] and a[j] twice in
this code?


<h4> Loop Unrolling </h4>

Gotos are expensive (do you know why?).  If you know a loop will
     execute at least (or exactly) 3 times, it may be faster to copy the
     loop body those three times than to do a goto.  Removing gotos
     simplifies code, allowing other optimizations.

<p>

<table border>
<tr><th>original<th>unrolled<th>after subsequent constant folding
<tr>
<td>
<pre>
for(i=0; i<3; i++) {
   x += i * i;
   y += x * x;
   }
</pre>
<td>
<pre>
   x += 0 * 0;
   y += x * x;
   x += 1 * 1;
   y += x * x;
   x += 2 * 2;
   y += x * x;
</pre>
<td>
<pre>
   y += x * x;
   x += 1;
   y += x * x;
   x += 4;
   y += x * x;
</pre>
</table>

<p>
<font size=1> <A name=56>lecture #56</A> began here</font>
<p>

<h3> Optimization Techniques, cont'd</h3>

<h4> Algebraic Properties </h4>

Implicit in the previous example of loop unrolling was the notion that
certain computations can be simplified by basic math properties.

<p>

<table border>
<tr>
<th> name
<th> sample
<th> optimized as
<tr>
<td> identities
<td>
<pre>
x = x * 1;
x = x + 0;
</pre>
<td>
<tr>
<td> simplification
<td>
<pre>
y = (5 * x) + (7 * x);
</pre>
<td>
<pre>
y = 12 * x;
</pre>
<tr>
<td> commutativity
<td>
<pre>
y = (5 * x) + (x * 7);
</pre>
<td>
<pre>
y = (5 * x) + (7 * x);
</pre>
<tr>
<td> strength reduction
<td>
<pre>
x = y * 16;
</pre>
<td>
<pre>
x = y << 4;
</pre>
</table>

This open-ended category might also include exploits of associativity,
distributive properties, etc.

<h4> Hoisting Loop Invariants </h4>

This one requires knowledge, perhaps too much knowledge. I know the following
optimization is safe, but does the compiler know? What would you have
to know/prove in order for this example to be "safe" for a compiler to do?
<p>

<table border>
<td>
<pre>
for (i=0; i&lt;strlen(s); i++)
   s[i] = tolower(s[i]);
</pre>
<td>
<pre>
t_0 = strlen(s);
for (i=0; i&lt;t_0; i++)
   s[i] = tolower(s[i]);
</pre>
</table>


<h4> Peephole Optimization </h4>

Peephole optimizations look at the native code through a small, moving
window for specific patterns that can be simplified.  These are some of the
easiest optimizations because they potentially don't require any analysis
of other parts of the program in order to tell when they may be applied.
Although some of these are stupid and you wouldn't think they'd come up,
the simple code generation algorithm we presented earlier is quite stupid
and does all sorts of obvious bad things that we can avoid.
<p>

<table border>
<tr>
<th> name
<th> sample
<th> optimized as
<tr>
<td> redundant load or store
<td>
<pre>
MOVE R0,a
MOVE a,R0
</pre>
<td>
<pre>
MOVE R0,a
</pre>
<tr>
<td> dead code
<td>
<pre>
#define debug 0
...
if (debug) printf("ugh");
</pre>
<tr>
<td> control flow simplification
<td>
<pre>
if a &lt; b goto L1
...
L1: goto L2
</pre>
<td>
<pre>
if a &lt; b goto L2
...
L1: goto L2
</pre>
</table>



<h3> Peephole Optimization Examples </h3>

It would be nice if we had time to develop a working demo program for
peephole optimization, but let's start with the obvious.

<p>

<table border>
<tr><th>as generated<th>replace with<th>comment
<tr>
<td>
<pre>
	movq	%rdi, -56(%rbp)
	cmpq	$1, -56(%rbp)
</pre>
<td>
<pre>
	movq	%rdi, -56(%rbp)
	cmpq	$1, %rdi
</pre>
<td> reuse n that's already in a register
<tr>
<td>
<pre>
	cmpq	$1, %rdi
	setle	%al
	movzbl	%al,%eax
	movq	%rax, -8(%rbp)
	cmpq	$0, -8(%rbp)
	jne	.L0
</pre>
<td>
<pre>
	cmpq	$1, %rdi
	jle	.L0
</pre>
<td> 
boolean variables are for wimps.<br>
setle sets a byte register (%al) to contain a boolean <br>
movzbl zero-extends a byte to a long (movsbl sign-extends)
<tr>
<td>
<pre>
	cmpq	$1, %rdi
	jle	.L0
	jmp	.L1
.L0:
</pre>
<td>
<pre>
	cmpq	$1, %rdi
	jg	.L1
.L0:
</pre>
<td> 
Use fall throughs when possible; avoid jumps.

<tr>
<td>
<pre>
	movq	%rax, -16(%rbp)
	movq	-16(%rbp), %rdi
</pre>
<td>
<pre>
	movq	%rax, %rdi
</pre>
<td> 
TAC code optimization might catch this sooner
<tr>
<td>
<pre>
	movq	-56(%rbp), %rax
	subq	$1, %rax
	movq	%rax, %rdi
</pre>
<td>
<pre>
	movq	-56(%rbp), %rdi
	subq	$1, %rdi
</pre>
<td> 
What was so special about %rax again?
<tr>
<td>
<pre>
	movq	%rax, -40(%rbp)
	movq	-24(%rbp), %rax
	addq	-40(%rbp), %rax
</pre>
<td>
<pre>
	addq	-24(%rbp), %rax
</pre>
<td> 
Addition is commutative.
</table>




<h4> Interprocedural Optimization </h4>

Considering memory references across procedure call boundaries;
     for example, one might pass a parameter in a register if both
     the caller and callee generated code knows about it.
<h4> argument culling </h4>
 when the value of a specific parameter is a constant, a custom version
     of a called procedure can be generated, in which the parameter is
     eliminated, and the constant is used directly (may allow additional
     constant folding).

<table border>
<td>
<pre>
f(x,r,s,1);

int f(int x, float y, char *z, int n)
{
  switch (n) {
  case 1:
     do_A; break;
  case 2:
     do_B; break;
     ...
     }
}
</pre>
<td>
<pre>
f_1(x,r,s);

int f_1(int x, float y, char *z)
{
   do_A;
}
int f_2(int x, float y, char *z)
{
   do_B;
}
...
</pre>

</table>


<h3> Code Generation for Input/Output </h3>

This section is on how to generate code for basic
C input/output constructs.

<dl>
<dt> getchar()
<dd> Basic appearance of a call to getchar() in final code:
<pre>
	call	getchar
	movl	%eax, <em>destination</em>
</pre>
     Of course, VGo does not have a getchar() function, it reads a line at
     a time.
     A built-in function for reading a line at a time might be built on
     top of this in vgo or in C, but it might be better to call a different
     input function.
<dt> <code>gets()</code> is part of the C standard that permanently encodes
a buffer overrun attack in the language for all time.  However, we could use
<code>fgets(char*,int,FILE*)</code> to implement VGo's input function.
<pre>
char *vgoread()
{
   int i;
   char *buf = malloc(4096);
   if (buf == NULL) return NULL; // should do more
   i = fgets(buf, 4095, stdin);
   // should do more
   return buf;
}
</pre>
What-all is wrong with this picture?
<dd>
<dt> printf(s...)
<dd> First parameter is passed in %rdi. An "interesting"
section in the AMD64 reference manuals explains that 32-bit operands are
automatically sign-extended in 64-bit registers, but 8- and 16-bit operands
are <em>not</em> automatically signed extended in 32-bit registers.
If string s has label .LC0
<pre>
	movl	$.LC0, %eax	; load 32-bit addr
				; magically sign-extended to 64-bits
	movq	%rax, %rdi	; place 64-bit edition in param #1 reg.
	call	printf		; call printf
</pre>

<dt> printf(s, i)
<dd> Printf'ing an int ought to be the simplest printf.
The second parameter is passed in %rsi.  If you placed a 32-bit
int in %esi you would still be OK.
<pre>
	movq	<em>source</em>, %rsi	; what we would do
	movl	<em>source</em>, %esi	; "real" C int: 32, 64, same diff
</pre>

<dt> printf(s, c)
<dd> Printf'ing a character involves passing that char as a parameter.
Generally when passing
a "char" parameter one would pass it in a (long word, aligned) slot, and
it is prudent to (basically) promote it to "int" in this slot.
<pre>
	movsbl	<em>source</em>, %esi
</pre>

<dt> printf(s, s)
<dd> Printf'ing a string involves passing that string as a parameter.
For <A href="x64/printf-s.c">local variable string constant data</A>,
gcc does
some <A href="x64/printf-s.s">pretty weird stuff</A>.
I'd kind of rather allocate the string constant out of the string
constant region and then copy it into the local region, but perhaps
calculating the contents of a string constant as a sequence of
32-bit long immediate values is an interesting exercise.

</dl>

<!--
<h3> C++ Output </h3>

Now, how about C++?  After some thought, we concluded that each output
(send) operator could be implemented by generating code for one call to
printf, with an appropriate format string for the type of the right operand.
This output is a side effect.
The expression result of the output operator is its left operand.


Potential optimizations of the preceding method for C++ output operations
include:
<ul>
<li> bundling a string of output operators into a single call to printf, or
     almost the opposite,
<li> using more direct output functions than printf, which is not famous for
     speed.  C++ may have dumped C stdio specifically because they believed
     printf's "mini-intepreter" of format strings was suboptimal.
     For example, fputc(c,stdout) is faster than printf("%c",c).
     Q: what is the fastest way to write out an integer?  What about a double?
</ul>

<h3> C++ Input Operator </h3>

Consider for a moment how to input an integer.  This is pretty fundamental;
even toy programs usually let a user enter a number.  The C program for it
might use scanf("%d", &amp;i), but in C++ one says cin &gt;&gt; i.

<table border>
<tr>
<th> "Real" <th> C-like, for 120++
<tr>
<td>
<pre>
	leaq	-8(%rbp), %rax
	movq	%rax, %rsi
	movl	$_ZSt3cin, %edi
	call	_ZNSirsERi
</pre>
<td>
<pre>
	leaq	-8(%rbp), %rax
	movq	%rax, %rsi
	movl	$.LC0, %edi
	movl	$0, %eax
	call	scanf
</pre>
</table>
-->

<!--
<h3> Implementing 120++ subset cin, cout, &lt;&lt; and &gt;&gt; </h3>

This topic is by student request. Our starting point is the goal of
providing minimal functionality necessary to produce output, so you
can tell whether generated code did anything.  In fact, let's start
with "hello world".  Consider the following sample hello.cpp program:

<pre>
#include &lt;iostream&gt;
using namespace std;

int main()
{
cout << "Hello, world\n";
}
</pre>

One of your basic design decisions is whether to use the real cin/cout,
or to write your own (toy subset) versions.

<h4> libstdc++ </h4>

If you follow g++ calling
conventions you can potentially link to and use their library, which
might save you some work.  But, g++ calling conventions are no picnic.
For the preceding "hello, world" program, the most juicy bits of the
generated assembler are:

<pre>
	.section	.rodata
.LC0:
	.string	"Hello, world\n"
	.text
.globl main
	.type	main, @function
main:
	...
	movl	$.LC0, %esi
	movl	$_ZSt4cout, %edi
	call	_ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc
</pre>

Personally, I can stomach the reference to <code>$_ZSt4cout</code>
but I am not superkeen about generating calls to functions with names
like the one in the <code>call</code> instruction here.

<h4> Homemade 120++ cout emulation </h4>

How about writing your own <code>lib120++.so</code>
and linking it in when you generate code?  Suppose that

<pre>cout &lt;&lt; s;</pre> resulted in the generated code equivalent to:

<pre>cout.out_str(s);</pre>

where <code>cout</code> in 120++ is an instance of a toy
<code>ofstream</code> class that looks like (_120ofstream.h):

<pre>
#include &lt;stdio.h&gt;
class _120_ofstream {
private:
   FILE *f;
public:
   _120_ofstream(int i);
   void out_str(char *s);
   void out_long(long l);
   void out_double(double d);
};
</pre>

The constructor parameter specifies cout (1) or cerr(2).
You would write your own implementation of this "library class",
compile with g++ and link it in and call it from your generated code.

<p>

If your compiler doesn't implement classes at all,
you might instead translate

<pre>cout &lt;&lt; s;</pre> to

<pre>_120out_str(cout, s);</pre>

where <code>cout</code> is a global variable (int, value == 1)
and the function is

<pre>
void _120out_str(int f, char *s)
{
   FILE *fp;
   if (f == 1) fp = stdout;
   else if (f == 2) fp = stderr;
   else { fprintf(stderr, "unknown output stream %d\n", f); exit(1); }
   fprintf(fp, "%s", s);
}
</pre>

You might need more output functions for other types.
g0 considers short and int to be the same as long, and float
to be the same as double.  Does it ever output char?
-->

<H3> Another Word on Interprocedural Optimization </h3>

The optimization unit of this course mentions only the
biggest categories of compiler optimization and gives very brief
examples.  That "argument culling" example of interprocedural
optimization deserves at least a little more context:

<ul>
<li> Interprocedural optimization (IPO) includes any optimizations that
     apply across function call boundaries, not just culling
<li> Because function call boundaries are what is being optimized, this
     will often focus on analysis of information known about parameters
     and return type
<li> Includes function inlining, if the compiler decides when to do that,
     rather than leave the decision up to the programmer.
<li> Can only do interprocedural optimization on procedures the compiler
     knows about; limited value unless compiling whole program together,
     or embedding in linker
<li> Modern production compilers have extra command-line options for IPO
</ul>


<h3> Comments on Debugging Assembler </h3>

The compiler writer that generates bad assembler code may need to debug
the assembler code in order to understand why it is wrong.
<ul>
<li> See <A href="http://dbp-consulting.com/tutorials/debugging/basicAsmDebuggingGDB.html">this tutorial from DBP Consulting</A> for some good ideas
<li> You almost only need to learn gdb's si and ni commands.
<li> You also need to know "as --gstabs+"
<li> You also need to know "info registers", or "i r" (e.g. "i r eax")
<li> In plain assembler debugging s and n work in lieu of si and ni
</ul>

<h3> Dominators and Loops </h3>

Raison d'etre: many/various Loop Optimizations require that loops be
specially identified within a general flow graph context.  If code is
properly structured (e.g. no "goto" statements) these loop optimizations are
safe to do, but in the general case for C you would have to check...

<dl>
<dt> dominator
<dd> node d in a flow graph <em>dominates</em> node n (written as "d dom n")
if every path from the initial node of the flow graph to n goes through d
<dt> dominator tree
<dd> tree formed from nodes in the flow graph whose root is the initial node,
and node n is an ancestor of node m only if n dominates m. Each node in a
flow graph has a unique "immediate dominator" (nearest dominator), hence a
dominator tree can be formed.
</dl>

<img src="domtree.png" width=500>

<h3> Loops in Flow Graphs </h3>

<ul>
<li> Must have a single entry point (the header) that dominates all nodes
<li> Must be a way to iterate; at least one path back to the header
<li> To find loops: look for edges a-&gt;b where b dominates a (back edges)
<li> Given a back edge n-&gt;d, the <em>natural loop</em> of this edge is
d plus the set of nodes that can reach n without going through d.
<li> every back edge has a natural loop...
</ul>



<h3> Algorithm to construct the natural loop of a back edge </h3>

Input: a flow graph <code>G</code> and a back edge <code>n -&gt; d</code> <br>
Output: the set (named <em>loop</em>) consisting of all nodes in the
natural loop of <code>n -&gt; d</code>.
<p>
Method: depth-first search on the reverse flow graph <code>G'</code>.
Start with loop containing only node <code>n</code> and <code>d</code>.
Consider each node <code>m | m != d</code> that is in
<em>loop</em>, and insert <code>m</code>'s predecessors in
<code>G</code> into <em>loop</em>. Each
node is placed once on a stack, so its predecessors will be examined.
Since <code>d</code> is put in <em>loop</em> initially, its predecessors
are not examined.

<pre>
procedure insert(m)
   if not member(loop, m) then {
      loop := loop ++ { m }
      push m onto stack
   }
end

main:
   stack := []
   loop := { d }
   insert(n)
   while stack not empty do {
      pop m off stack
      for each predecessor p of m do insert(p)
      }
</pre>

<h3> Inner Loops </h3>

<ul>
<li> If only natural loops are considered then unless two loops have the same
header, they are either disjoint or one is nested within the other.  The ones
that are nested inside other loops may be of more interest e.g. for
optimization.
<br>
<img src="innerloops0001.png" width=400>

<li> If two loops share the same header, neither is inner to the other,
instead they are treated as one loop.
<br>
<img src="innerloops0002.png" width=200>
</ul>









<h3> Code Generation for Virtual Machines </h3>

A virtual machine architecture such as the JVM changes the "final" code
generation somewhat.  We have seen several changes, some of which
simplify final code generation and some of which complicate things.

<dl>
<dt> no registers, simplified addressing
<dd> a virtual machine may omit a register model and avoid complex
     addressing modes for different types of variables
<dt> uni-size or descriptor-based values
<dd> if all variables are "the same size", some of the details of
     memory management are simplified.  In Java most values occupy
     a standard "slot" size, although some values occupy two slots.
     In Icon and Unicon, all values are stored using a same-size descriptor.
<dt> runtime type system
<dd> requiring type information at runtime may complicate the
     code generation task since type information must be present
     in generated code.  For example in Java method invocation and
     field access instructions must encode class information.
</dl>

Just for fun, let's compare the generated code for java with that X86
native code we looked at earlier when we were talking about how to make
variables spill out of registers:
<pre>
	iload_1
	iload_2
	iadd
	iload_3
	iload 4
	iadd
	imul
	iload 5
	iload 6
	iadd
	iload 7
	iload_1
	iadd
	imul
	iload_3
	iload 5
	imul
	idiv
	iadd
	istore_1
</pre>

What do you see?
<br><br><br><br><br><br>
<ul>
<li> Stack-machine model. Most instructions implicitly use the stack.
<li> Difference between "iload_3" and "iload 4": Java VM has special
     opcodes that run faster for first 3 locals/temporaries.
</ul>

thanks here to T. Mowry.

<h3> Preheaders </h3>

Loop optimizations often require code to be executed once before the loop.
Example: loop hoisting.

Solution: introduce a new (possibly empty) basic block for every loop.
It had to have a header anyhow; give it a preheader.

<h3> What was all that Loops/Dominators Stuff For?</h3>

<ul>
<li>You can't do the loop optimizations on malformed loops!
<li> To be safe, one must identify proper optimization-eligible "loops"
from their shape in the flow graph, not
from syntax keywords like "while" or "for".
<li> The whole flow graph for a function, then, will contain zero or more
    (usually one or more) inner, natural loops that can be worked on by
    storing in an auxiliary data structure the set of nodes (from the flow
    graph) that belong under a given header.
</ul>
<p>

Given that you find such a natural loop, you can do:

<h4> Loop Hoisting </h4>

<ul>
<li> identify loop invariant. Invariant wrt loop iff operands are defined
     outside loop or constant OR definition inside loop was itself invariant.
<li> move invariant to preheader
</ul>

Hoisting Conditions
thank you to Peter Lee

Hoisting conditions
For a loop-invariant definition
d: t = x op y
we can hoist instruction d into the loop’s pre-header if:
1. d’s block dominates all loop exits at which t is
live-out, and
2. there is only one definition of t in the loop, and
3. t is not live-out of the pre-header

<h4> Finding Loop Invariants </h4>

OK, what can you do with this:
<p>
<img src="hoisting.png">
<p>
Did you get:
<p>
<img src="hoisted.png">
<p>

Exercise: run it a few billion times; see whether hoisting a couple
operations out of the loop makes a measurable difference.  It might
not, after all... gotos are expensive.

Exercise: what is wrong with this example?

Another example (from Wikipedia loop-invariant code motion):

<pre>
for (int i = 0; i &lt; n; i++) {
    x = y + z;
    a[i] = 6 * i + x * x;
}
</pre>

One can hoise not just x = y + z; because it establishes x as invariant,
subexpression x*x (into a temp variable) can also be hoisted.


<h3> More on Runtime Systems </h3>

Every compiler (including yours) needs a runtime system.  A runtime system
is the set of library functions and possibly global variables maintained by
the language on behalf of a running program.  You use one all the time; in C
it functions like printf(), plus perhaps internal compiler-generated calls
to do things the processor doesn't do in hardware.<p>

So you need a runtime system; potentially, this might be as big or bigger a
job than writing the compiler.  Languages vary from assembler (no runtime
system) and C (small runtime system, mostly C with some assembler) on up to
Java (large runtime system, mostly Java with some C) and in even higher level
languages the compiler may evaporate and the runtime system become gigantic.
The Unicon language has a relatively trivial compiler and gigantic virtual
machine and runtime system.  Other scripting languages might have no compiler
at all, doing everything (even lexing and parsing) in the runtime system.
<p>

<!--
For your project: whatever type of output code you generate, you need a plan
for what to do about a runtime system.  And, in principle, I am not opposed
to helping with this part.  But the compiler and runtime system have to fit
together; if I write part of the BASIC runtime system for you, or we write
it together, we have to agree on things such as: what the types of
parameters and return values must look like.<p>

So, what belongs in a Color BASIC runtime system?  Anything not covered
by a three address instruction.  Looking at cocogram.y:
<ul>
<li> INPUT/PRINT
<li> READ/DATA
<li> CLEAR
<li> CLOAD/CSAVE/SKIPF
<li> CLS
<li> SET/RESET
<li> SOUND
<li> CHR$, LEFT$, MID$, RIGHT$, INKEY$
<li> ASC, INT, JOYSTK, LEN, PEEK, RND, VAL
<li> DIM
<li> string +, string compares
</ul>
<p>

What would a runtime system function look like?  It would take in and
pass out BASIC values, represented as C structs.  You would then link
this code in to your generated C or assembler code (if you generated
Java code, you would have to deal with the Java Native Interface or
else write these functions in Java).
<pre>
void PRINT(struct descrip *d)
{
   switch (d->type) {
   case INTEGER: printf("%d",d->value.ival); break;
   case REAL: printf("%f",d->value.rval); break;
   case STRING: printf("%*s",d->size,d->value.string); break;
   case ARRAY: printf("cannot print arrays"); break; /* can't get here */
   default: printf("PRINT: internal error, type %d\n", d->type);
   }
}
</pre>

Now, let's look at the "whole" runtime system:

<ul>
<li> <A href="libb.c">libb.c</A>
</ul>

<h3> More on Memory Management in the BASIC Runtime System </h3>

Arrays are interesting.  They can be used without being declared or DIM'ed.
They can only be DIM'ed once.  If you use them before they are DIM'ed, they
are implicitly DIM'ed to size 11 and can't be re-DIM'ed.
<p>
What do variables A, A(), A$, and A$() look like in memory?  How does our
runtime system make it so?
<p>
Let's take a look at DIM, in libc.c.  This DIM is for arrays of numbers.
How would you handle arrays of strings?
<p>
Can you implement STRCAT for your BASIC runtime system?
<p>
What other BASIC statements, operators, or functions allocate memory?
<p>
How would we avoid memory "leaks"?

<h3> STRCAT </h3>

So, what does your STRCAT look like?  <A href="libb.c#strcat">Here's one.</A>

<h3> GOSUBs </h3>

Our 3-address instruction set has call and return instructions, but basic
is less structured than regular procedural languages; you can GOSUB to any
line number you want.  You can't use a variable to GOSUB to line number X,
but in principle every line number could be the target of a procedure call.
<p>
If you use the "call" (3-address) instruction to do GOSUB, your native code
will have to make a clear distinction between BASIC call's and calls to
runtime system (built-in) functions.  Perhaps it is best to implement BASIC
GOSUB by pushing a "param" (the next instruction following the GOSUB) and
a "goto".  The BASIC RETURN is then a "pop" followed by a "goto".  What,
we don't have a "pop" 3-address instruction?  We do now...  the name of
"param" should probably be "push" anyhow.
<p>

Come to think of it, we've been talking about doing a call to a built-in
function such as PRINT, but that PRINT function we wrote is C code; it
doesn't do a 3-address "ret" instruction, hmmm.  How are we going to
generate the native code for the 3-address "call" instruction?
It may include an assembler call instruction, but it may also involve
instructions to handle the interface between BASIC and C.
-->
<!--
<h3> Flex SDK Comments </h3>

Adobe's Flex SDK web pages point you only at Windows binary downloads,
but if you dig further, it appears to be some big Java open source project.
<ul>
<li><A href="http://opensource.adobe.com/wiki/display/flexsdk/Setup+on+Linux">build instructions</A>
<li> You have to have a good Java and Ant (wormulon didn't, Larry seems
     to have put it on for me
<li> Warning: the SVN checkout can take HOURS on a cable modem.  Literally
     filled my laptop hard drive over several hours without completing.
     It occurs to me this might be their way of making their "open source"
     project as not-open as possible.
     Suggest you append "/trunk" to the name they say to checkout.
     Long checkout seems to be worsened by an idiotic policy of putting open
     sandbox end-user junk in the SVN repository! But also, it is big.
<li> Tried with /trunk on eternium, ran 46 minutes and then died with an
     error prior to completion
<li> Instructions say to "source setup.sh", but this did not go so well for
     me on wormulon (must be running bash, not csh). When I switched over to
     bash, complained about many missing or renamed files and died.
<li>Conclusions:
    (a) easier to just get this on a Windows machine if you have one.
    (b) example of an "open source" project that isn't really open.
</ul>
-->

<h3> Quick Look at the Implementation of Unicon </h3>

<ul>
<li> Language much higher level than C, C++, or Java, closer to Python
<li> Descended from Icon, whose Big Research Contribution was:
     integrating goal-directed evaluation into imperative programming
<li> Unicon came into existence because a tiny office in The Government
     wanted to use Icon, but needed it to be relevent to their real world
     problems: big data, analysis of large unstructured text stored in
     SQL databases.
<li> Unicon's Little Research Contributions are:
<ul>
<li> scaling Icon to large real-world problems
<li> adding OOP, concurrency, pattern type, rich high-level I/O subsystems
<li> native execution monitoring
</ul>
<li> At least Three implementations:
<ul>
<li> Virtual machine, no registers, yes built-in backtracking
<li> Optimizing compiler, generates C, backtracking turns into continuation passing
<li> Transformer, generates Java, backtracking turns into iterators
</ul>
<li> In all cases, the runtime system is far larger than the compiler!
<li> Compared with a traditional language:
<ul>
<li> no type checking in the compiler!
<li> runtime type checks (opt. compiler: type inferencing)
</ul>
</ul>

The remainder of this quick look will focus on OO features, as implementing
object-oriented language features is of broad interest.


<h3> On Double Constants in Assembler </h3>

For what its worth, I was Wrong. I claimed to one or more of you that
immediate mode instructions didn't include full 64-bit immediate constants,
but see the end of lecture #48! Earlier this semester we already noted
that x86_64 does in fact have immediate mode for 64-bits...for at least
one instruction/opcode (movabsq).  Proof by contradiction.  I note that the
double 3.1415 was represented in <A href="x64/dbl.s">output assembler</A>
by $4614256447914709615.
Just for fun, I checked my earlier cast-to-long strategy:
<pre>
#include <iostream>
using namespace std;
int main()
{
   double d;
   d = 3.1415;
   long l = *(long *)(&d);
   cout << "$" << l << endl;
}
</pre>
outputs:
<pre>
$4614256447914709615
</pre>
We win.


<h3> Tips on Invoking the Assembler and Linker from your Compiler </h3>

HW#6 calls for your compiler to produce an executable
that I can run.  But we have mainly discussed a compiler that writes out code
suitable for input to an assembler. A student requested that I give you some
tips on getting the rest of the way.

<ul>
<li> You could write a 120++ shell script that ran your compiler (named
     something else) and them ran the assembler and linker.
<li> Probably better to call assembler and linker from within your main().
<li> Probably this means invoking an external program/process from your
     program.
<li> Most standard way to do this is via system(s).  Could use popen() or
     fork()/exec()/wait() but system() is probably best.
<li> Return integer is a "status" consisting of an exit code PLUS STUFF.
     You have to use WEXITSTATUS(i) to get the process return code of 
     command s.
<li> The assembler is named as, and as mentioned you may want to use
as --gstabs+, as in
<pre>
as --gstabs+ -o foo.o foo.s
</pre>
<li> The linker is named ld, and you typically would invoke it with not
     just your own code, but also startup code to call your main(), and
     a runtime library. If your library were named lib120++.a that might
     look like:
<pre>
ld -o foo /usr/lib64/crt1.o foo.o -l120++
</pre>
<li> If you were invoking the linker ld on a "real" g++ standard library the
ld command invocation is more complex. For example in December 2017 on
wormulon (Centos) it looked like:
<pre>
ld -dynamic-linker /lib64/ld-linux-x86-64.so.2 /usr/lib64/crt1.o /usr/lib64/crti.o /usr/lib/gcc/x86_64-redhat-linux/4.4.7/crtbegin.o dbl.o /usr/lib64/libstdc++.so.6 -lc /usr/lib/gcc/x86_64-redhat-linux/4.4.7/crtend.o /usr/lib64/crtn.o
</pre>
Since this is version-specific, the "portable" way would be to use g++ as
your linker, if you are going to link in its standard C++ libraries:
<pre>
g++ dbl.o
</pre>

<li> Runtime libraries like lib120++.a are built from .o files by running
the archiver program ar, as in
<pre>
ar cr lib120++.a mylib1.o mylib2.o ...
</pre>
<li> You can expect to have to read the man pages for as, ld, ar, and system
in order to figure out options.
<li> There is a potential problem with where your
compiler should find lib120++.a, how shall we solve that?
</ul>


<h3> Imports and Inheritance in Unicon </h3>

Unicon is different from mainstream languages, and this section is not intended
to tell you what you are supposed to do, it is intended to provide a basis for
comparison.

<h4> Syntax Tree Overview </h4>

Unicon uses "iyacc", a variant of Berkeley yacc, which is a cousin of Bison.
The <A href="unigram.y">unigram.y</A> grammar has around 234 shift reduce
conflicts.  The semantic action at the import statement is illustrative of
tree construction as well as what little semantic analysis Unicon does.

<pre>
import: IMPORT implist {
   $$ := node("import", $1,$2," ")
   import_class($2)
   } ;
</pre>

For what its worth, the tree type in Unicon is very challenging and
sophisticated:
<pre>
record treenode(label, children)
procedure node(label, kids[])
   return treenode(label, kids)
end
</pre>

Actually, Unicon syntax trees are incredibly simple, except that
they are actually heterogeneous trees with a mixture
of treenode, string, token, and various class objects.

<h4> Idol.icn </h4>

Despite the generic tree, various class objects
from <A href="idol.icn">idol.icn</A> store all the
interesting stuff in the syntax tree.  It is almost
really one class per non-terminal type, and those
non-terminals that have symbol tables have a field
in the class that contains the symbol (hash) table object.
<p>

class Package (one of the only parts of idol.icn I didn't write)
tells a real interesting story.  There is both an in-memory
representation of what we know about the world, and a persistent
on-disk representation (in order to support separate compilation).

<pre>
#
# a package is a virtual syntax construct; it does not appear in source
# code, but is stored in the database.  The "fields" in a package are
# the list of global symbols defined within that package.  The filelist
# is the list of source files that are linked in when that package is
# imported.
#
class Package : declaration(files, dir, classes)
   #
   # Add to the two global tables of imported symbols from this package's
   # set of symbols.  If sym is non-null, we are importing an individual
   # symbol (import "pack.symbol").
   #
   method add_imported(sym)
      local s, f

      if /dir then return
      
      f := open(dir || "/uniclass", "dr") |
	 stop("Couldn't re-open uniclass db in " || dir)
      every s := (if \sym then sym else fields.foreach()) do {
         if member(imported, s) then
             put(imported[s], self.name)
          else {
             imported[s] := [self.name]
          }

         if fetch(f, self.name || "__" || s) then {
            if member(imported_classes, s) then
               put(imported_classes[s], self.name)
            else {
               imported_classes[s] := [self.name]
            }
         }
      }
      close(f)
   end
   method Read(line)
      self$declaration.Read(line)
      self.files := idTaque(":")
      self.files$parse(line[find(":",line)+1:find("(",line)] | "")
   end
   method size()
      return fields$size()
   end
   method insertfname(filename)
      /files := idTaque(":")
      if files.insert(filename) then {
         write(filename, " is added to package ", name)
         writespec()
         }
      else write(filename, " is already in Package ", name)
   end
   method insertsym(sym, filename)
      if fields.insert(sym) then {
         write(sym, " added to package ", name)
         writespec()
         }
      else write(sym, " is already in Package ", name)
   end
   method containssym(sym)
       return \fields.lookup(sym)
   end
   method String()
      s := self$declaration.String()
      fs := files.String()
      if *fs > 0 then fs := " : " || fs
      s := s[1: (*tag + *name + 2)] || fs || s[*tag+*name+2:0]
      return s
   end
   method writespec()
   if \name & (f := open(env,"d")) then {
      insert(f, name, String())
      close(f)
      return
      }
   stop("can't write package spec for ", image(name))
   end
initially(name)
   if name[1] == name[-1] == "\"" then {
      name := name[2:-1]
      self.name := ""
      name ? {
	 if upto('/\\') then {
	    while self.name ||:= tab(upto('/\\')) do self.name ||:= move(1)
	    }
	 self.name ||:= tab(find(".")|0)
	 }
      }
   else {
      self.name := name
      }
   if dbe := fetchspec(self.name) then {
      Read(dbe.entry)
      self.dir := dbe.dir
      }
   /tag := "package"
   /fields := classFields()
end
</pre>

<h4> fetching a specification </h4>

Given a class name, how do we find it?  It must live in a GDBM database
(uniclass) somewhere along the IPATH. A bunch of tedious string parsing
concluding with a GDBM fetch.

<pre>
#
# find a class specification, along the IPATH if necessary
#
procedure fetchspec(name)
   static white, nonwhite
   local basedir := "."
$ifdef _MS_WINDOWS_NT
   white := ' \t;'
   nonwhite := &cset -- ' \t;'
$else
   white := ' \t'
   nonwhite := &cset -- ' \t'
$endif
   name ? {
      while basedir ||:= tab(upto('\\/')) do {
	 basedir ||:= move(1)
	 }
      name := tab(0)
      # throw away initial "." and trailing "/"
      if basedir[-1] == ("\\"|"/") then basedir := basedir[2:-1]
      }
   if f := open(basedir || "/" || env,"dr") then {
      if s := fetch(f, name) then {
	 close(f)
	 return db_entry(basedir, s)
	 }
      close(f)
      }

   if basedir ~== "." then fail # if it gave a path, don't search IPATH

   ipath := ipaths()

   if \ipath then {
      ipath ? {
         dir := ""
	 tab(many(white))
	 while dir ||:= tab(many(nonwhite)) do {
	    if *dir>0 & dir[1]=="\"" & dir[-1] ~== "\"" then {
		dir ||:= tab(many(white)) | { fail }
	       }
	    else {
		if dir[1]==dir[-1]=="\"" then dir := dir[2:-1]
		if f := open(dir || "/" || env, "dr") then {
		    if s := fetch(f, name) then {
			close(f); return db_entry(dir, s) }
		    close(f)
		}
		tab(many(white))
		dir := ""
	    }
	}
     }
  }
end
</pre>

<h3> Closure-Based Inheritance </h3>

Unicon not only allows multiple inheritance, it is the only language that I
know of that can handle cycles in the inheritance graph.  It does this by
having each child be completely self-centered. When they inherit, they rifle
through their parents looking for spare change. This is a depth-first method
that completely/perfectly inherits from the first superclass (including all
its parents) and only then considers later step-parents.
<p>

Inside class Class, supers is an object that maintains an ordered list of a
class' superclasses (i.e. parents).  Variable classes is effectively a
global object that knows all the classes in the current package and let's
you look them up by name.  Variable added tracks classes already visited,
and prevents repeating any classes already on the list.

<pre>
  method transitive_closure()
    count := supers.size()
    while count > 0 do {
	added := taque()
	every sc := supers.foreach() do {
	  if /(super := classes.lookup(sc)) then
	    halt("class/transitive_closure: couldn't find superclass ",sc)
	  every supersuper := super.foreachsuper() do {
	    if / self.supers.lookup(supersuper) &
		 /added.lookup(supersuper) then {
	      added.insert(supersuper)
	    }
	  }
	}
	count := added.size()
	every self.supers.insert(added$foreach())
    }
  end
</pre>

Given that all the superclasses have been ordered, the actual inheritance
in class Class is done by a method resolve():

<pre>
  method resolve()
    #
    # these are lists of [class , ident] records
    #
    self.imethods := []
    self.ifields := []
    ipublics := []
    addedfields := table()
    addedmethods := table()
    every sc := supers.foreach() do {
	if /(superclass := classes.lookup(sc)) then
	    halt("class/resolve: couldn't find superclass ",sc)
	every superclassfield := superclass.foreachfield() do {
	    if /self.fields.lookup(superclassfield) &
	       /addedfields[superclassfield] then {
		addedfields[superclassfield] := superclassfield
		put ( self.ifields , classident(sc,superclassfield) )
		if superclass.ispublic(superclassfield) then
		    put( ipublics, classident(sc,superclassfield) )
	    } else if \strict then {
		warn("class/resolve: '",sc,"' field '",superclassfield,
		     "' is redeclared in subclass ",self.name)
	    }
	}
	every superclassmethod := (superclass.foreachmethod()).name() do {
	    if /self.methods.lookup(superclassmethod) &
	       /addedmethods[superclassmethod] then {
		addedmethods[superclassmethod] := superclassmethod
		put ( self.imethods, classident(sc,superclassmethod) )
	    }
	}
	every public := (!ipublics) do {
	    if public.Class == sc then
		put (self.imethods, classident(sc,public.ident))
	}
    }
  end
</pre>


<h3> Unicon Methods Vectors </h3>

Unicon resolves each class' inheritance information at compile time, and
generates a <em>field table</em> for runtime calculations that map field
names to slot#/offsets.  Methods vectors are just structs,
shared by objects by means of a pointer (__m) added to class instances.



<p>
<font size=1> <A name=57>lecture #57</A> began here</font>
<p>



<h3> Final Exam Review </h3>

The final exam is comprehensive, but with a strong emphasis on "back end"
compiler issues: symbol tables, semantic analysis, and code generation.


<ul>
<li>  Review your lexical analysis, regular expressions, and finite automata.
<li>  Review your syntax analysis, CFG's, and parsing.
<li>  If a parser discovers a syntax error, how can it report what line
      number that error occurs on?  If semantic analysis discovers a
      semantic error (or probable semantic error), how can it report what
      line number that error occurs on?
<li>  What are symbol tables?  How are they used?
      What information is stored there?
<li>  How does information get into a symbol table?
<li>  How many symbol tables does a compiler need?
<li>  What is "semantic analysis"?
<li>  What does "semantic analysis" accomplish? What are its side effects?
<li>  What are the primary activities of a compiler's semantic analyzer?
<li>  What are memory regions, and why does a compiler care?
<li>  What memory regions are there, and how do they affect code generation?
<li>  What does code generation do, anyhow?
<li>  What kinds of code generation are there?
<li>  Why do (almost all) compilers use an "intermediate code"?  What does
      intermediate code look like?  How is it different from final code?
</ul>

<H4><A href="sample-final.pdf">Sample Final Exam</A></h4>

This final is from a previous year and has questions specific to that
year's project.  But it gives you an idea of the kinds of questions
that appear on the final.
