<h2> CSE 423 Lab #1: Flex </h2>

Turnin: a .zip on Canvas.

<p>

<h4> 0. Preliminaries </h4>

If you haven't already, read the required Flex reading (sections 3-5
of the GNU Flex Manual). If that's not enough, read the Flex chapters
of the optional text (Flex and Bison), or find and read a copy of the
original Paxon article "Flex - a scanner generator".

<h4>1. Flex Basics </h4>

Use Flex to compile and run the "word counter" flex program from the
Flex manual page, or <code>flex-wc.l</code> (<A href="flex-wc.l.html">HTML</A>,
raw .l: <A href="flex-wc.l">flex-wc.l</A>), a version of the word counter that
comes from github.  In your .zip submission, you can include your final
versions of source code files used here, plus a file
<code>lab1.1_answers.txt</code>

<ol>
<li> When you run <code>flex flex-wc.l</code>, what output file
      does flex write?
<li> When you run <code>gcc</code> on Flex's output .c file,
     what is the executable file named?
<li> Run your program on itself with <code>./a.out &lt;flex-wc.l</code>
<li> Fix your program to take the name of the file as a command line
     argument, instead of using &lt; to redirect standard input.
<li> Convert to separate compilation!  move main() into a separate main.c
     and write a makefile that compiles main.c and lex.yy.c separately and
     then links them.
</ol>

<h4>2. Flex (Most of) your HW#2 Away</h4>

Well, you can save the "allocate tokens and build a linked list of them"
part for later, but if you complete this lab, you should have your regular
expressions identified, and have integer codes for each category. We should
also get a good idea of how to handle some of Rust's more quirky rules.

<p>

Let's walk through Rust's description of Rust lexical analysis Links
to an external site.. Then we proceed as follows.


<ol>
<li> Copy flex-wc.l to a file named rustlex.l
<li> Modify rustlex.l to discard whitespace, but otherwise count chars/words
<li> Modify rustlex.l to discard comments, but otherwise count chars/words
<li> Modify rustlex.l to return a 257 on each word, and modify the main()
     to call yylex() in a while loop. Print chars and words at the end.
<li> Change the while loop to print out a line showing each word after
     yylex() returns it. Print the return code as well as <code>yytext</code>

<li> Add regular expressions to recognize reserved words (see
<A href="ironyref.html">ironyref.html</A>
for a list, maybe from the Canvas edition) and
return different integers for each one. Fail and stop with an error message
if a Rust reserved word not in Irony appears.

<li> Add regular expressions for operators and punctuation (see
<A href="ironyref.html">ironyref.html</A> for lists, maybe from the
Canvas edition) and
return different integers for each one.

<li> Add regular expressions for integer, float and string
     literals. Return a different integer code for each kind of literal.

<li>
Figure out what to do about Rust's less obvious tokens, such as indent and dedent. We can work on this part collaboratively.

<li> Ask questions about anything fishy in Rust that we haven't specified
in the Irony reference.
</ol>



