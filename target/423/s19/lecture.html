<H1> Dr. J's Compiler and Translator Design Lecture Notes </h1>

(C) Copyright 2011-2019 by Clinton Jeffery and/or original authors where
appropriate.  For use in Dr. J's Compiler classes only.  Lots of material
in these notes originated with Saumya Debray's Compiler course notes from
the University of Arizona, for which I owe him a debt of thanks.  Various
portions of his notes were in turn inspired by the ASU red dragon book.

<table>
<tr align=top>
<td>
<ul>
<li> <A href="intro">Introduction</A>
<ul>
<li> <A href="#1">Lecture 1</A> (<A href="445-1.pptx">pptx</A>)
</ul>
<li> <A href="#lexical">Lexical Analysis</A>
<ul>
<li> <A href="#2">Lecture 2</A> (<A href="445-2.pptx">pptx</A>)
<li> <A href="#3">Lecture 3</A> (<A href="445-3.pptx">pptx</A>)
<li> <A href="#4">Lecture 4</A>
<li> <A href="#5">Lecture 5</A> (<A href="445-5.pptx">pptx</A>)
<li> <A href="#6">Lecture 6</A>
<li> <A href="#7">Lecture 7</A> (<A href="445-7.pptx">pptx</A>)
<li> <A href="#8">Lecture 8</A>
<li> <A href="#9">Lecture 9</A>
<li> <A href="#10">Lecture 10</A>
<li> <A href="#11">Lecture 11</A>
</ul>
</ul>
<ul>
<li> <A href="#syntax">Syntax Analysis</A>
<ul>
<li> <A href="#12">Lecture 12</A>
<li> <A href="#13">Lecture 13</A>
<li> <A href="#14">Lecture 14</A>
<li> <A href="#15">Lecture 15</A>
<li> <A href="#16">Lecture 16</A>
<li> <A href="#17">Lecture 17</A>
<li> <A href="#18">Lecture 18</A>
<li> <A href="#19">Lecture 19</A>
<li> <A href="#20">Lecture 20</A>
</ul>
</ul>
</td>
<td align=top>
<ul>
<li> <A href="#semantic">Semantic Analysis</A>
<ul>
<li> <A href="#21">Lecture 21</A>
<li> <A href="#22">Lecture 22</A>
<li> <A href="#23">Lecture 23</A>
<li> <A href="#24">Lecture 24</A>
<li> <A href="#25">Lecture 25</A>
<li> <A href="#26">Lecture 26</A>
<li> <A href="#27">Lecture 27</A>
<li> <A href="#28">Lecture 28</A>
<li> <A href="#29">Lecture 29</A>
<li> <A href="#31">Lecture 31</A>
<li> <A href="#32">Lecture 32</A>
<li> <A href="#33">Lecture 33</A>
</ul>
</ul>

<ul>
<li> Midterm Review
<ul>
<li> <A href="#30">Lecture 30</A>
</ul>
</ul>

<td>

<ul>
<li> <A href="#codegen">Intermediate Code Generation</A>
<ul>
<li> <A href="#34">Lecture 34</A>
<li> <A href="#35">Lecture 35</A>
<li> <A href="#36">Lecture 36</A>
<li> <A href="#37">Lecture 37</A>
<li> <A href="#38">Lecture 38</A>
<li> <A href="#39">Lecture 39</A>
<li> <A href="#40">Lecture 40</A>
<li> <A href="#41">Lecture 41</A>
<li> <A href="#42">Lecture 42</A>
<li> <A href="#43">Lecture 43</A>
<li> <A href="#44">Lecture 44</A>
<li> <A href="#45">Lecture 45</A>
</ul>
</td>
<td align=top>
<li> <A href="#finalcode">Final Code Generation</A>
<ul>
<li> <A href="#46">Lecture 46</A>
<li> <A href="#47">Lecture 47</A>
<li> <A href="#48">Lecture 48</A>
<li> <A href="#49">Lecture 49</A>
<li> <A href="#50">Lecture 50</A>
<li> <A href="#51">Lecture 51</A>
<li> <A href="#52">Lecture 52</A>
<li> <A href="#53">Lecture 53</A>
</ul>
<li> <A href="#optimization">Optimization</A>
<ul>

<li> <A href="#54">Lecture 54</A>
<li> <A href="#55">Lecture 55</A>
<li> <A href="#56">Lecture 56</A>
<li> <A href="#57">Lecture 57</A>

</ul>
</td>
</tr>
</table>

<p>
<font size=1> <A name=1>lecture #1</A> began here</font>
<p>

<h3> Syllabus</h3>

Yes, we went over the <A href="syllabus.html">syllabus</A>.

<A name="intro">
<h3>Why study compilers?</h3>
</a>

Computer scientists study compiler construction for the
following reasons:

<ul>
<li> Experience with large-scale
applications development. Your compiler may be the largest
program you write as a student.  Experience working with really big
data structures and complex interactions between algorithms will
help you out on your next big programming project.

<li> A shining triumph of CS theory.
It demonstrates the value of theory over the impulse to just "hack up"
a solution.

<li> A basic element of programming language research.
Many language researchers write compilers for the languages they design.

<li> Many applications have similar properties to one or more phases of
a compiler, and compiler expertise and tools can help an application
programmer working on other projects besides compilers.

</ul>

CS 445 is labor intensive. This is a good thing: there is no way to
learn the skills necessary for writing big programs without this kind
of labor-intensive experience.

<h3> Some Tools we will use </h3>

Labs and lectures will discuss all of these, but if you do not know them
already, the sooner you go learn them, the better.

<dl>
<dt> C and "make".
<dd> If you are not expert with these yet, you will be a lot closer
     by the time you pass this class.
<dt> lex and yacc
<dd> These are compiler-writers tools, but they are useful for other
     kinds of applications, almost anything with a complex file format
     to read in can benefit from them.
<dt> gdb
<dd> If you do not know a source-level debugger well, start learning.
      You will need one to survive this class.
<dt> e-mail
<dd> Regularly e-mailing your instructor is a crucial part of class
     participation.  If you aren't asking questions, you aren't doing
     your job as a student.
<dt> web
<dd> This is where you get your lecture notes, homeworks, and labs,
     and turnin all your work.
</dl>

<h3> Compilers - What Are They and What Kinds of Compilers are Out There? </h3>

The purpose of a compiler is: to translate a program in some language (the
<i>source language</i>) into a lower-level language (the <I>target
language</i>).  The compiler itself is written in some language, called
the <i>implementation language</i>.  To write a compiler you have to be
very good at programming in the implementation language, and have to
think about and understand the source language and target language.<p>

There are several major kinds of compilers:

<dl>
<dt> Native Code Compiler
<dd> Translates source code into hardware (assembly or machine code)
     instructions.  Example: gcc.

<dt> Virtual Machine Compiler
<dd> Translates source code into an abstract machine code, for execution
     by a virtual machine interpreter.  Example: javac.

<dt> JIT Compiler
<dd> Translates virtual machine code to native code.  Operates within
     a virtual machine. Example: Sun's HotSpot java machine.

<dt> Preprocessor
<dd> Translates source code into simpler or slightly lower level source code,
     for compilation by another compiler.  Examples: cpp, m4.

<dt> Pure interpreter
<dd> Executes source code on the fly, without generating machine code.
     Example: Lisp.
</dl>

OK, so a pure interpreter is not really a compiler.  Here are some more tools,
by way of review, that compiler people might be directly concerned with, even
if they are not themselves compilers.
You should learn any of these terms that you don't already know.

<dl>
<dt> assembler
<dd> a translator from human readable (ASCII text) files of machine
instructions into the actual binary code (object files) of a machine.
<dt> linker
<dd> a program that combines (multiple) object files to make an executable.
     Converts names of variables and functions to numbers (machine addresses).
<dt> loader
<dd> Program to load code.  On some systems, different executables start at
     different base addresses, so the loader must patch the executable with
     the actual base address of the executable.
<dt> preprocessor
<dd> Program that processes the source code before the compiler sees it.
     Usually, it implements macro expansion, but it can do much more.
<dt> editor
<dd> Editors may operate on plain text, or they may be wired into the rest
     of the compiler, highlighting syntax errors as you go, or allowing
     you to insert or delete entire syntax constructs at a time.
<dt> debugger
<dd> Program to help you see what's going on when your program runs.
     Can print the values of variables, show what procedure called what
     procedure to get where you are, run up to a particular line, run
     until a particular variable gets a special value, etc.
<dt> profiler
<dd> Program to help you see where your program is spending its time, so
     you can tell where you need to speed it up.
</dl>



<h3> Phases of a Compiler </h3>

<dl>
<dt>Lexical Analysis:</dt>
<dd>Converts a sequence of characters into words, or <I>tokens</i></dd>
<dt>Syntax Analysis:</dt>
<dd>Converts a sequence of tokens into a <I>parse tree</i></dd>
<dt>Semantic Analysis:</dt>
<dd>Manipulates parse tree to verify symbol and type information</dd>
<dt>Intermediate Code Generation:</dt>
<dd>Converts parse tree into a sequence of intermediate code instructions</dd>
<dt>Optimization:</dt>
<dd>Manipulates intermediate code to produce a more efficient program</dd>
<dt>Final Code Generation:</dt>
<dd>Translates intermediate code into final (machine/assembly) code</dd>
</dl>


<H3> Example of the Compilation Process </h3>

Consider the example statement; its translation to machine code
illustrates some of the issues involved in compiling.
<table border><tr><td><pre>
position = initial + rate * 60
</pre></table>
30 or so characters, from a single line of source code, are first
transformed by lexical analysis into a sequence of 7 tokens.  Those
tokens are then used to build a tree of height 4 during syntax analysis.
Semantic analysis may transform the tree into one of height 5, that
includes a type conversion necessary for real addition on an integer
operand.  Intermediate code generation uses a simple traversal
algorithm to linearize the tree back into
a sequence of machine-independent three-address-code instructions.
<p>
<table border><tr><td><pre>

  t1 = inttoreal(60)&nbsp;&nbsp;
  t2 = id<sub>3</sub> * t1
  t3 = id<sub>2</sub> + t2
  id<sub>1</sub> = t3</pre></table>

<p>
Optimization of the intermediate code allows the four instructions to
be reduced to two machine-independent instructions.  Final code generation
might implement these two instructions using 5 machine instructions, in
which the actual registers and addressing modes of the CPU are utilized.
<p>

<table border><tr><td><pre>

  MOVF	id<sub>3</sub>, R2&nbsp;&nbsp;
  MULF	#60.0, R2
  MOVF	id<sub>2</sub>, R1
  ADDF	R2, R1
  MOVF	R1, id<sub>1</sub>
</pre>
</tr>
</table>

<p>
<A name="lexical">
<font size=1> <A name=2>lecture #2</A> began here</font>
</A>
<p>

<h4> Reading! </h4>

<ol>

<li>
Read the Louden text chapters 1-2.  Except you may SKIP the parts that
describe the TINY project. Within the Scanning chapter, there are large
portions on the finite automata that should be CS 385 review; you may
SKIM that material, unless you don't know it or don't remember it.

<li>
Read Sections 3-5 of the Flex manual,
<A href="http://westes.github.io/flex/manual/">Lexical Analysis With Flex</A>.

<li> Read the class lecture notes
as fast as we manage to cover topics. Please ask questions about
whatever is not totally clear.  You can <em>Ask Questions</em> in class or
via e-mail.
</ol>

<p>

Although the whole course's lecture notes are ALL available to you
up front, I generally revise each lecture's notes, making additions,
corrections and adaptations to this year's homeworks, the night before each
lecture.  The best time to print hard copies of the lecture notes, if you
choose to do that, is one
day at a time, right before the lecture is given.  Or just read online.
<p>

<h3> Some Resources for the class Project and a Policy Statement</h3>

Class Dev+Test Linux Machine: historically we have used a generic
Linux server like "wormulon" to do (and grade) class work. This semester
our UI CS system admin, Victor, has created a virtual machine
specifically for this class (and separate ones for many other classes).
I believe our machine is named "cs-course42.cs.uidaho.edu". Try it out
and report any problems to me.

<p>

Unlike software engineering, the compiler class project is a solo exercise,
meant to increase your skill at programming on a larger scale than in most
classes. On the one hand it is sensible to use software engineering tools
such as revision control systems (like git) on a large project like this. On
the other hand it is not OK to share your work with your classmates,
intentionally or through stupidity. If you use a revision control system,
figure out how to make it private. Various options:
<ul>
<li> on github you can pay $7/mo to do private repositories; some class members
     assert that students can now make these for free
<li> you can use revision control with a local repository. setup is easy,
     but if you do this, figure out how to back up your work.
<li> you can figure out how to do git through ssh onto a UI CS unix
     account
<li> Our CS admin, Victor House, may have a cleaner solution for you,
     check with him.
</ul>
<p>

The following folks are on my wall of shame. Feel free to laugh at their
student code.  Thanks to them, your compiler project has to be substantially
different and possibly more difficult.  If you put up a public repository
(on github or wherever) this semester and I find out about it (say, via
google, or from another student) you will receive a 0 on your semester project.

<ul>
<li> <A href="https://github.com/CrockAgile/C--">#1</A>
<li> <A href="https://github.com/SethForrest/Compilers_HW_1"</A>#2</A>
<li> <A href="https://github.com/gg2/Compilers">#3</A>
<li> <A href="https://github.com/fliinn/GilmoreCPPCompiler">#4</A>
<li> <A href="https://github.com/GhostofGoes/cgoes-cs445">#5</A> and/or
     <A href="https://github.com/GhostofGoes/cgoes-cminus-compiler">#5a</A>
<li> <A href="https://github.com/johngoettsche/CS445">#6</A>
<li> <A href="https://github.com/JCJutson/CS445-Compiler">#8</A>
<li> <A href="https://github.com/park2331/">#9</A>
<li> <A href="https://github.com/rose0531/cs445">#10</A>
<li> <A href="https://github.com/andschwa/partial-cpp-compiler">#11</A>
<li> <A href="https://github.com/tsonnen/CS445_Compilers">#13</A>
<li> <a href="https://github.com/cawaltrip/compilers">#14</A>
<li> <A href="https://github.com/KnightPickles/CS445">#15</A>
</ul>


<p>
<font size=1> <A name=3>lecture #3</A> began here</font>
<p>



<h3> Overview of Lexical Analysis </h3>

A lexical analyzer, also called a <em>scanner</em>, typically has the
following functionality and characteristics.

<ul>

<li> Its primary function is to convert from a (often very long) sequence of
characters into a (much shorter, perhaps 10X shorter) sequence of tokens.
This means less work for subsequent phases of the compiler.

<li> The scanner must Identify and Categorize specific character sequences
into tokens.  It must know whether every two adjacent characters in the file
belong together in the same token, or whether the second character must be
in a different token.

<li> Most lexical analyzers discard comments &amp; whitespace. In most
languages these characters serve to separate tokens from each other, but
once lexical analysis is completed they serve no purpose.  On the other
hand, the exact line # and/or column # may be useful in reporting errors,
so some record of what whitespace has occurred may be retained.  <em>Note:</em>
in some languages, even popular ones, whitespace is significant.

<li> Handle lexical errors (illegal characters, malformed tokens) by
reporting them intelligibly to the user.

<li> Efficiency is crucial; a scanner may perform elaborate input buffering

<li> Token categories can be (precisely, formally) specified using regular
expressions, e.g.
<pre>
	 IDENTIFIER=[a-zA-Z][a-zA-Z0-9]*
</pre>

<li> Lexical Analyzers can be written by hand, or implemented automatically
using finite automata.
</ul>

<h3> What is a "token" ?</h3>

In compilers, a "token" is:

<ol>
<li> a single word of source code input (a.k.a. "lexeme")
<li> an integer code that refers to a single word of input
<li> a set of lexical attributes computed from a single word of input
</ol>

Programmers think about all this in terms of #1. Syntax checking uses
#2. Error reporting, semantic analysis, and code generation require #3.  In
a compiler written in C, for each token you allocate a C struct to store (3)
for each token.

<h4> Auxiliary data structures </h4>

You were presented with the phases of the compiler, from lexical and syntax
analysis, through semantic analysis, and intermediate and final code 
generation.  Each phase has an input and an output to the next phase.
But there are a few data structures
we will build that  survive across multiple phases: the literal table,
the symbol table, and the error handler.

<dl>
<dt> lexeme table
<dd> a table that stores lexeme values, such as strings and variable
     names, that may occur in many places.  Only one copy of each
     unique string and name needs to be allocated in memory.
<dt> symbol table
<dd> a table that stores the names defined (and visible with) each
     particular scope.  Scopes include: global, and procedure (local).
     More advanced languages have more scopes such as class (or record)
     and package.
<dt> error handler
<dd> errors in lexical, syntax, or semantic analysis all need a common
     reporting mechanism, that shows where the error occurred (filename,
     line number, and maybe column number are useful).
</dl>

<h4> Reading Named Files in C using <code>stdio</code> </h4>

In this class you are opening and reading files.  Hopefully this is review
for you; if not, you will need to learn it quickly.  To do any "standard
I/O" file processing, you start by including the header:

<pre>
#include &lt;stdio.h&gt;
</pre>
This defines a data type <code>(FILE *)</code> and gives prototypes for
relevant functions.  The following code opens a file using a string filename,
reads the first character (into an int variable, not a char, so that it can
detect end-of-file; EOF is not a legal char value).
<pre>
   FILE *f = fopen(filename, "r");
   int i = fgetc(f);
   if (i == EOF) /* empty file... */
</pre>


<h3> Command line argument handling and file processing in C </h3>
The following example is from Kernighan & Ritchie's "The C Programming
Language", page 162.
<A name="sample.c">
<pre>
#include &lt;stdio.h&gt;

/* cat: concatenate files, version 1 */
int main(int argc, char *argv[])
{
   FILE *fp;
   void filecopy(FILE *, FILE *);

   if (argc == 1)
      filecopy(stdin, stdout);
   else
      while (--argc > 0)
         if ((fp = fopen(*++argv, "r")) == NULL) {
            printf("cat: can't open %s\n", *argv);
            return 1;
            }
         else {
            filecopy(fp, stdout);
            fclose(fp);
            }
   return 0;
}

void filecopy(FILE *ifp, FILE *ofp)
{
   int c;

   while ((c = getc(ifp)) != EOF)
      putc(c, ofp);
}
</pre>

<em> Warning: while using and adapting the above code is fair game in this
class, the yylex() function is very different than the filecopy() function!
It takes no parameters!  It returns an integer every time it finds a token!
So if you "borrow" from this example, delete filecopy() and write yylex()
from scratch.  Multiple students have fallen into this trap before you.
</em>

<h3> A Brief Introduction to Make </h3>

It is not a good idea to write a large program like a compiler as a single
source file.  For one thing, every time you make a small change, you would
need to recompile the whole program, which will end up being many thousands
of lines.  For another thing, parts of your compiler may be generated by
"compiler construction tools" which will write separate files.  In any case,
this class will require you to use multiple source files, compiled
separately, and linked together to form your executable program. This
would be a pain, except we have "make" which takes care of it for us.

Make uses an input file named "makefile", which stores in ASCII text form
a collection of rules for how to build a program from its pieces.  Each
rule shows how to build a file from its source files, or dependencies.
For example, to compile a file under C:
<pre>
foo.o : foo.c
	gcc -c foo.c
</pre>
The first line says to build foo.o you need foo.c, and the second line,
which <em><b>must</b></em> being with a tab, gave a command-line to
execute whenever foo.o should be rebuilt, i.e. when it is missing or
when foo.c has been changed and need to be recompiled.
<p>
The first rule in the makefile is what "make" builds by default, but
note that make dependencies are recursive: before it checks whether
it needs to rebuild foo.o from foo.c it will check whether foo.c needs
to be rebuilt using some other rule.  Because of this post-order
traversal of the "dependency graph", the first rule in your makefile
is usually the last one that executes when you type "make".  For a
C program, the first rule in your makefile would usually be the
"link" step that assembles objects files into an executable as in:
<pre>
compiler: foo.o bar.o baz.o
	gcc -o compiler foo.o bar.o baz.o
</pre>

There is a lot more to "make" but we will take it one step at a time.
<p>

You can read or skim the
<A href="https://www.gnu.org/software/make/manual/make.pdf">GNU make
manual</A>, particularly section 2, to learn more about make.

<!--
This
<A href="http://developers.sun.com/solaris/articles/make_utility.html">
article on Make</A>
may be useful to you.
-->
You can find useful on-line documentation
on "make" (manual page, Internet reference guides, etc) if you look.


<h3> A couple finer points for <A href="hw1.html">HW#1</A> </h3>

<dl>
<dt> extern vs. #include: when do you use the one, when the other?
<dd> extern's can be done without an #include, to tell one module
    about global variables defined in another module. But if you are
    going to share that extern with a lot of different modules, put
    it in an #include.
    Use #include in order to share types, externs, function prototypes,
    and symbolic #define's across multiple files. That is all. No code.
<dt> public interface to yylex(): no, you can't add your own parameters
<dd> You might be tempted to return a token structure pointer, or
     add some parameters to tell it what filename it is reading from.
     But you can't.  Leave yylex()'s interface alone, the parser will
     call it with its current interface.
</dl>


<h3> Regular Expressions </h3>

The notation we use to precisely capture all the variations that a given
category of token may take are called "regular expressions" (or, less
formally, "patterns".  The word "pattern" is really vague and there are
lots of other notations for patterns besides regular expressions).
Regular expressions are a shorthand notation
for sets of strings.  In order to even talk about "strings" you have
to first define an <em>alphabet</em>, the set of characters which can
appear.

<ol>
<li> Epsilon (&epsilon;) is a regular expression denoting the set
     containing the empty string
<li> Any letter in the alphabet is also a regular expression denoting
     the set containing a one-letter string consisting of that letter.
<li> For regular expressions r and s, <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; r | s<br>
     is a regular expression denoting the union of r and s
<li> For regular expressions r and s, <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; r s<br>
     is a regular expression denoting the set of strings consisting of
     a member of r followed by a member of s
<li> For regular expression r, <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; r*<br>
     is a regular expression denoting the set of strings consisting of
     zero or more occurrences of r.
<li> You can parenthesize a regular expression to specify operator
     precedence (otherwise, alternation is like plus, concatenation
     is like times, and closure is like exponentiation)
</ol>

<p>
<font size=1> <A name=4>lecture #4</A> began here</font>
<p>

<h3> Mailbag </h3>

<dl>
<dt> I've heard of malloc(), but I haven't had any real experience
     working with it.
<dd> malloc(), calloc() and realloc() are a more flexible memory management
     API for C that corresponds roughly to "new" in C++.  It let's you
     allocate memory generically by # of bytes, independent of the type
     system, which is powerful but dangerous.

<dt> My experience with flex and bison was way back in the
     Programming Languages course.
<dd> Same goes for most everybody; this background is what is expected.
     You are to read and learn flex and bison from scratch if you don't
     remember it. Your reading assignment should be pretty well finished
     by now, and you should be ready for me to lecture on flex.  We will
     teach what is needed of them for this course, in this course.

<dt> What should the lexical analyzer look like?  where do I start?
<dd> Homework #1 is about learn to use a declarative language called
     Flex which does almost all the work for you. The only design
     issue is how does it interact with the rest of the compiler, i.e.
     its public interface. This is partly hardwired/designed for you
     by flex, your only customization option is how to make token
     information available to the later phases of the compiler.

<dt> How should our output be visible?
<dd> One human readable output line, per token, as shown in hw1.html
     Build the linked list first, then walk it (visit all nodes) to
     print the output. Figure out how to do this so output is in the
     correct order and not reversed!

<dt> What's the final verdict on null, true, and false
<dd> We will do them (add the reserved words), because supporting JSON
     is one of the main points of g0

<dt> Are there any comments in g0?
<dd> Yes, both /* ... */ and // comments are in g0.

<dt> You mention storing the int and double as binary. That just means
     storing them in int and double variables, correct?
<dd> It means for constants you have to convert from the lexeme string
     that actually appears in the source code to the value (int, double)
     and then store the result in the corresponding lexical attribute
     variable.

</dl>

<h3> Announcement </h3>

We will do basic CS 120-level classes in <code>g0</code>.


<h3> Lex/Flex Extended Regular Expressions </h3>

Although the basic regular expression operators given earlier
are sufficient to describe all regular languages,
in practice everybody uses extensions:

<ul>
<li> For regular expression r, <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; r+<br>
     is a regular expression denoting the set of strings consisting of
     one or more occurrences of r.  Equivalent to rr*
<li> For regular expression r, <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; r?<br>
     is a regular expression denoting the set of strings consisting of
     zero or one occurrence of r.  Equivalent to r|&epsilon;
<li> The notation [abc] is short for a|b|c.  [a-z] is short for a|b|...|z.
     [^abc] is short for: any character other than a, b, or c.
</ul>


<h4> What is a "lexical attribute" ? </h4>

A lexical attribute is a piece of information about a token.  These typically
include:

<table>
<tr><td> category <td> an integer code used to check syntax
<tr><td> lexeme <td> actual string contents of the token
<tr><td> line, column, file <td> where the lexeme occurs in source code
<tr><td> value <td> for literals, the binary data they represent
</table>


<h4> Avoid These Common Bugs in Your Homeworks! </h4>

<ol>
<li> yytext or yyinput were not declared global
<li> main() does not have its required argc, argv parameters!
<li> main() does not call yylex() in a loop or check its return value
<li> getc() EOF handling is missing or wrong!  check EVERY all to getc() for EOF!
<li> opened files not (all) closed! file handle leak!
<li> end-of-comment code doesn't check for */
<li> yylex() is not doing the file reading
<li> yylex() does not skip multiple spaces, mishandles spaces at the front
     of input, or <em>requires</em> certain spaces in order to function OK
<li> extra or bogus output not in assignment spec
<li> = instead of ==
</ol>

<h3> Some Regular Expression Examples </h3>

Regular expressions are the preferred notation for
specifying patterns of characters that define token categories.  The best
way to get a feel for regular expressions is to see examples.  Note that
regular expressions form the basis for pattern matching in many UNIX tools
such as grep, awk, perl, etc. <p>

What is the regular expression for each of the different lexical items that
appear in C programs?  How does this compare with another, possibly simpler
programming language such as BASIC?

<!--This is the first of many things where BASIC is somewhat easier 
to deal with than C.-->

<table border>
<tr> <th> lexical category <th> BASIC <th> C </tr>
<tr> <td> operators <td> the characters themselves <td>      For operators that are regular expression operators we need mark them
     with double quotes or backslashes to indicate you mean the character,
     not the regular expression operator.  Note several operators have a
     common prefix. The lexical analyzer needs to look ahead to tell
     whether an = is an assignment, or is followed by another = for example.
 </tr>
<tr> <td> reserved words <td> the concatenation of characters; case insensitive <td>
     Reserved words are also matched by the regular expression for identifiers,
     so a disambiguating rule is needed.
</tr>

<tr>
<td> identifiers <td> no _; $ at ends of some; 2 significant letters!?; case insensitive <td> [a-zA-Z_][a-zA-Z0-9]*
</tr>

<tr>
<td> numbers <td> ints and reals, starting with [0-9]+ <td> 0x[0-9a-fA-F]+ etc.
</tr>

<tr> <td> comments <td> REM.* <td> C's comments are tricky regexp's

<tr> <td> strings <td> almost ".*"; no escapes <td> escaped quotes

<tr> <td> what else?

</table>


<!--
<h3> Language Candidates </h3>

Hypothesize that "it would be wise" for us to choose a language subset project
that is defined by somebody and NOT to make up one from scratch.  FYI: Python
does not have a widely-available YACC parser; Ruby apparently does.

<dl>
<dt> C-based: C-minus-minus
<dd> Pro: familiar.  Con: boring.  And name overloaded by multiple groups.
     Difference from Heckendorn: I will make you target x86_64 assembler.
<dt> Java-based: <A href="http://BantamJava.com"> BantamJava </A> or <A href="http://www2.cs.uidaho.edu/~jeffery/godiva/">Godiva-0</A>
<dd> Pro: Java knowledge is useful.
<dt> TRS-80 Extended Color BASIC
<dd> Pro: can run cool 80's games on it.  Con: BASIC is so last-century
<dt> Ruby-based
<dd> Pro: cool.  Con: ill-defined.  Would we just copy and study the existing
     implementation?  Blah
<dt> Plzero (Pascal language 0, I think)
<dd> Pro: I am sure I have a copy lying around that is newer than the one at
      <A href="http://www.moorecad.com/standardpascal/plzero.pas">moorecad</A>.
<dt> Unicon-based
<dd> Pro: Jeffery knows it inside and out. Con: who cares about Unicon?
</dl>
-->

<h3> <tt>lex(1)</tt> and <tt>flex(1)</tt> </h3>

These programs generally take a lexical specification given in a .l file
and create a corresponding C language lexical analyzer in a file named
lex.yy.c.  The lexical analyzer is then linked with the rest of your compiler.
<p>

The C code generated by lex has the following public interface.  Note the
use of global variables instead of parameters, and the use of the prefix
yy to distinguish scanner names from your program names.  This prefix is
also used in the YACC parser generator.
<pre>
FILE *yyin;	/* set this variable prior to calling yylex() */
int yylex();	/* call this function once for each token */
char yytext[];	/* yylex() writes the token's lexeme to an array */
                /* note: with flex, I believe extern declarations must read
                   extern char *yytext;
                 */
int yywrap();   /* called by lex when it hits end-of-file; see below */
</pre>
<p>

The .l file format consists of a mixture of lex syntax and C code fragments.
The percent sign (%) is used to signify lex elements.  The whole file is
divided into three sections separated by %%:
<pre>
   header
%%
   body
%%
   helper functions
</pre>
<p>

The header consists of C code fragments enclosed in %{ and %} as well as
macro definitions consisting of a name and a regular expression denoted
by that name.  lex macros are invoked explicitly by enclosing the
macro name in curly braces.  Following are some example lex macros.
<pre>
letter		[a-zA-Z]
digit		[0-9]
ident		{letter}({letter}|{digit})*
</pre>
<p>

<blockquote>
<em>A friendly warning: your UNIX/Linux/MacOS Flex tool is NOT
good at handling input files saved in MS-DOS/Windows format, with
carriage returns before each newline character.  Some browsers,
copy/paste tools, and text editors might add these carriage returns
without you even seeing them, and then you might end up in Flex Hell
with cryptic error messages for no visible reason. Download with
care, edit with precision. If you need to get rid of carriage returns
there are lots of tools for that. You can even build them into your
makefile. The most classic UNIX tool for that task is tr(1), the
character translation utility</em>
</blockquote>

<p>
<font size=1> <A name=5>lecture #5</A> began here</font>
<p>

<dl>
<dt> Blackboard is not up, what is wrong?
<dd> I didn't make Blackboard available until today. It and the submission
     zone entry for HW#1 should be up now. Let me know if it is not.
<dt> One of the examples uses the reserved word float, which is not in our
list. Do I need to support the reserved word float?
<dd> No. You could optionally treat it as a synonym for double.
<dt> Does table operation T-a produce a new table or modify an existing one?
<dd> Good catch, it was intended to modify an existing table. Since
     a -= operator was subsequently added to g0, -= is a better fit than -,
     so I revised the g0 reference to that effect.
<dt> When will our Midterm be?
<dd> The week of October 8-11. I guess we should discuss this and vote on
     it tomorrow.
</dl>

<h3> Flex Body Section </h3>

The body consists of of a sequence of regular expressions for different
token categories and other lexical entities.  Each regular expression can
have a C code fragment enclosed in curly braces that executes when that
regular expression is matched.  For most of the regular expressions this
code fragment (also called a <em>semantic action</em> consists of returning
an integer that identifies the token category to the rest of the compiler,
particularly for use by the parser to check syntax.  Some typical regular
expressions and semantic actions might include:

<pre>
" "		{ /* no-op, discard whitespace */ }
{ident}		{ return IDENTIFIER; }
"*"		{ return ASTERISK; }
"."		{ return PERIOD; }
</pre>

You also need regular expressions for lexical errors such as unterminated
character constants, or illegal characters.
<p>

The helper functions in a lex file typically compute lexical attributes,
such as the actual integer or string values denoted by literals.  One
helper function you have to write is yywrap(), which is called when lex
hits end of file.  If you just want lex to quit, have yywrap() return 1.
If your yywrap() switches yyin to a different file and you want lex to continue
processing, have yywrap() return 0.  The lex or flex library (-ll or -lfl)
have default yywrap() function which return a 1, and flex has the directive
<code>%option noyywrap</code> which allows you to skip writing this function.
You can avoid a similar warning for an unused unput() function by saying
<code>%option nounput</code>.
<p>
<em>
Note that some platforms with working Flex installs (CENTOS?  wormulon?)
might not have a flex library, neither -ll or -lfl. Using %option noyywrap 
or providing your own yywrap() function are your most portable alternatives.
</em>


<h3> Student Feedback from Last Lecture </h3>

<dl>
<dt> Proposed regex solution
<dd> How about this (amalgamated) student proposed solution:
<pre>
"/*"(("*"+[^/*])|[^*]+)*"*"+"/"
</pre>
Correct or not?  If incorrect, give example where it fails.
Can it match <code>/* this **/ regex here*/</code>

<dt> Is the "struct token" supposed to be in our main(), and we use yylex()
along with other variables within lex.yy.c to fill the "struct token" with
the required information?

<dd> Great question. At least a pointer to a struct token should probably be
in main().  yylex() should allocate a struct token, fill it, and make it
visible to main(), probably by assigning its address to some global pointer
variable.  main() should build the linked list in a loop, calling yylex() each
time through the loop. It should then print the output by looping through
the linked list.

<!--
<dt> Discussion of include stacks. Thank you to the student contributor of
this example:
<dd>
<pre>
Here's the code I'm using to push/pop the lexer state.
It uses a couple of user-defined functions and a struct
to store auxiliary information such as the filename,
but the rest are standard C/flex functions.

/*
 * Return 1 if done, 0 if yyin points at more input
 */
int yywrap() {
    // Is the state stack empty?
    if(include_stack == NULL) {
        return 1;
    } else {
        fclose(yyin);

        // Grab the previous input file from the state stack.
        yypop_buffer_state();
        SourceFileState state = pop_file_state(&include_stack);
        filename = state.filename;
        line_num = state.line_num;
        return 0;
    }
}

/*
 * Handles a "user" include directive (using double quotes)
 */
static void handle_user_include() {
    char *fname = strchr(yytext, '\"')+1;
    fname[strlen(fname)-1] = '\0';
    fname = strdup(fname);

    FILE* input_file = fopen(fname, "r");
    if(!input_file) {
        fprintf(stderr, "Unable to open include file %s: ", fname);
        perror("");
        exit(1);
    }

    // Push flex's internal buffer state.
    yypush_buffer_state(yy_create_buffer(input_file, YY_BUF_SIZE));
    // Push "auxiliary" file data.
    push_file_state(&include_stack, filename, line_num);
    filename = fname;
    line_num = 1;
}
</pre>

<A href="http://westes.github.io/flex/manual/Multiple-Input-Buffers.html#Multiple-Input-Buffers">Section 11 of the Flex manual</A> discusses functions such as
yypush_buffer_state().
-->
</dl>

<h3> Lexical Error Handling </h3>

<ul>
<li> Include file name and line number
<li> Avoid cascading error messages -- only print the first one you see
     on a given line.
<li> (Optional) Write regular expressions for common errors, in order
     to give a better message than "lexical error" or "unrecognized character".
</ul>

<p>
<font size=1> <A name=6>lecture #6</A> began here</font>
<p>


<h3> Mailbag </h3>

<dl>
<dt> Is the d unary operator something like d(20) and its binary is something like 4d(6)?
<dd> Yes, but it is not intended that you should need parentheses.
Implicit in your point is that if d20 is a legal variable name, it can hardly
be an instance of the d operator can it?  What possible fixes can you think of?

<dt> Can you go over using the %array vs. the standard %pointer option
     and if there are any potential benefits of using %array?
     I was curious to see if you could use YYLMAX in junction
     with %array to limit the size of identifiers, but there is
     a probably a better way.
<dd> Wow, extra points on this one for obscurity.  After yylex() returns,
     the actual input characters matched are available as a string named
     yytext, and the number of input symbols matched are in yyleng.  But is
     yytext a char * or an array of char?  Usually it doesn't matter in C,
     but <em>I personally have worked on a compiler where declaring an extern
     for yytext in my other modules, and using the wrong one, caused a crash.</em>
     Flex has both pointer and array implementations available via %array
     and %pointer declarations, so your compiler can use either.  YYLMAX
     is not a Flex thing, sorry, but how <em>can</em> we limit
     the length of identifiers?  Incidentally: I am astonished, to read
     claims that the Flex scanner buffer doesn't automatically increase
     in size as needed, and might be limited by default to 8K or so regexes.
     If you write open-ended regular expressions, but might be advisable
     in this day of big memory to say something like
<pre>
	i=stat(filename,&st);
	yyin=fopen(filename,"r");
	yy_current_buffer = yy_create_buffer(yyin, st.st_size);
</pre>
     to set flex so that it cannot experience buffer overrun. By the way,
     Be sure to
     check ALL your C library calls for error returns in this class!
<dt> Do you want us to have a .h file for enumerating all the different
     kind of tokens for HW 1? I was looking into flex and bison and it
     looks like bison creates a tab.h file that does this automatically.
<dd> Yes. In HW1 you create a .h file for these defines; plan to throw it
     away in favor of the one Bison creates for you in HW#2.
<dt> Are you going to provide us the list of tokens required, or the .h file?
<dd> No, I am providing a language reference, from which you are to make the
     list. But by asking the right questions, you are making me add details
     to the g0 language reference.

<dt> Will you always call "make" on our submissions?
<dd> Yes. I expect you to use make and provide a makefile in each
     homework. Turn in the whole source, not just "changed" or
     "new" files for some assignments. My script will
     unpack your .zip file by saying "unzip" in some new test directory
     and then run "make" and then run your executable named g0. If
     anything goes wrong (say, you unzipping into a subdirectory the script
     does not know the name of) you will lose a few points.
<br><br>
     On the other hand, I do not want the tool-generated files
     (lex.yy.c, cgram.tab.c) or .o or executables.  The makefile should
     contain correct dependencies to rerun flex (and later, bison) and
     generate these files whenever source (.l, .y , etc.) files are changed.
<dt> The O'Reilly book recommended using Flex states instead of that big
     regular expression for C comments.  Is that reasonable?
<dd> Yes, you may implement the most elegant correct answer you can
     devise, not just what you see in class.
<dt> Are we free to explore non-optimal solutions?
<dd> I do not want to read lots of extra pages of junk code, but you are free
     to explore alternatives and submit the most elegant solution you come
     up with, regardless of its optimality. Note that there are some parts
     of the implementation that I might mandate. For example, the symbol table
     is best done as a hash table. You could use some other fancy data
     structure that you love, but if you give me a linked list I will be
     disappointed. Then again, a working linked list implementation would get
     more points than a failed complicated implementation.
<dt> Is it OK to allocate a token structure inside main() after yylex()
     returns the token?

<dd> No. In the next phase of your compiler, you will not call
<code>yylex()</code>, the Bison-generated parser will call
<code>yylex()</code>.  There is a way for
the parser to grab your token if you've stored it in a global variable,
but there is not a way for the parser to build the token structure itself.
However you <em>are</em> expected to allocate the linked list nodes in main(), and
in the next homework that linked list will be discarded. Don't get attached.

<dt> My tokens' "text" field in my linked list are all messed up when I go
     back through the list at the end. What do I do?
<dd> Remember to make a physical copy of <code>yytext</code> each token,
     because it overwrites itself each time it matches a regular expression
     in <code>yylex()</code>.  Typically a physical copy of a C string is
     made using <code>strdup()</code>, which is a <code>malloc()</code>
     followed by <code>strcpy()</code>.

<dt> C++ concatenates adjacent string literals, e.g. "Hello" " world"
Does our lexer need to do that?
<dd>
This feature is not present in Java or g0. You do not have to do it.
But if you did, can you think of a way to get the job done without too
much pain?
It could be done in the lexer, in the parser, or sneakily in-between.
Be careful to consider 3+ adjacent string literals
("Hello" " world, " "how are you" and so on)
<dt> How do I handle escapes in svals? Do I need to worry about more than
\n \t \\ and \r?
<dd>
You replace the two-or-more characters with a single, encoded character.
'\\' followed by 'n' become a control-J character.  g0 needs
\n \t \\ and \" -- these are the ones that appear in the text.
You can do additional ones like \r but they are not required and
will not be tested.

</dl>


<h3> Lexing Reals </h3>

C float and double constants have to have at least one digit, either
before or after the required decimal.  This is a pain:
<pre>
([0-9]+.[0-9]* | [0-9]*.[0-9]+) ...
</pre>

You might almost be happier if you wrote

<pre>
([0-9]*.[0-9]*)    { return (strcmp(yytext,".")) ? REAL : PERIOD; }
</pre>

You-all know C's ternary e1 ? e2 : e3 operator, don't ya? Its an if-then-else
expression, very slick.  Note that if you have to support
scientific/exponential real numbers (JSON does), you'll need a bigger regex.

<h3> Lex extended regular expressions </h3>

Lex further extends the regular expressions with several helpful operators.
Lex's regular expressions include:

<dl>
<dt> c
<dd> normal characters mean themselves
<dt> \c
<dd> backslash escapes remove the meaning from most operator characters.
     Inside character sets and quotes, backslash performs C-style escapes.
<dt> "s"
<dd> Double quotes mean to match the C string given as itself.
     This is particularly useful for multi-byte operators and may be
     more readable than using backslash multiple times.
<dt> [s]
<dd> This character set operator matches any one character among those in s.
<dt> [^s]
<dd> A negated-set matches any one character not among those in s.
<dt> .
<dd> The dot operator matches any one character except newline: [^\n]
<dt> r*
<dd> match r 0 or more times.
<dt> r+
<dd> match r 1 or more times.
<dt> r?
<dd> match r 0 or 1 time.
<dt> r{m,n}
<dd> match r between m and n times.
<dt> r<sub>1</sub>r<sub>2</sub>
<dd> concatenation. match r<sub>1</sub> followed by r<sub>2</sub>
<dt> r<sub>1</sub>|r<sub>2</sub>
<dd> alternation. match r<sub>1</sub> or r<sub>2</sub>
<dt> (r)
<dd> parentheses specify precedence but do not match anything
<dt> r<sub>1</sub>/r<sub>2</sub>
<dd> lookahead.  match r<sub>1</sub> when r<sub>2</sub> follows, without
     consuming r<sub>2</sub>
<dt> ^r
<dd> match r only when it occurs at the beginning of a line
<dt> r$
<dd> match r only when it occurs at the end of a line
</dl>





<!--
<h3> Introductory Comments on BASIC </h3>

We are doing (a large subset of) TRS-80 Color Computer Extended BASIC.
Compared with last semester, you will get more help from me on getting
started with each assignment, and be asked to do a little more.

<li>  The main language reference manuals are on our class web page
<A href="http://www2.cs.uidaho.edu/~jeffery/courses/445/">
http://www2.cs.uidaho.edu/~jeffery/courses/445/</A>

<li> I am writing my own commentary on it 
<A href="http://www2.cs.uidaho.edu/~jeffery/courses/445/basic.html">
http://www2.cs.uidaho.edu/~jeffery/courses/445/basic.html</A>
where most of your formal specifications will appear.

<li> I have made a start at some pseudocode
<A href="http://www2.cs.uidaho.edu/~jeffery/courses/445/basic.icn">
http://www2.cs.uidaho.edu/~jeffery/courses/445/basic.icn</A>
for the "interpreter loop" that will wrap around your compiler.
-->


<h3> Lexical Attributes and Token Objects </h3>

Besides the token's category, the rest of the compiler may need several
pieces of information about a token in order to perform semantic analysis,
code generation, and error handling.  These are stored in an object instance
of class Token, or in C, a struct.  The fields are generally something like:

<pre>
struct token {
   int category;
   char *text;
   int linenumber;
   int column;
   char *filename;
   union literal value;
}
</pre>

The union literal will hold computed values of integers, real numbers, and
strings.  <em>In your homework assignment, I am requiring you to compute
column #'s; not all compilers require them, but they are easy.  Also: in
our compiler project we are not worrying about optimizing our use of memory,
so am not requiring you to use a union</em>.
<p>
<font size=1> <A name=7>lecture #7</A> began here</font>
<p>
<h3>Mailbag</h3>

<dl>
<dt> If we allow
<pre>a = 1
b = 2
c = 0
</pre>
to be the same as a=1; b=2; c=0, do we also allow
<pre>
a=1 b=2 c=0
</pre>
?
<dd>
In g0 there are not multiple statements on a line, so there is no
<pre>a=1; b=2; c=0
</pre>
and there is no
<pre>
a=1 b=2 c=0
</pre>

<dt> lists and tables are mentioned as literals, which makes me think a single
'table' token is called for, however
<pre> table t&lt;Integer, String&gt; </pre>
seems like it should expand to the following six tokens: <br>
"table" "t" "<" "Integer" "String" ">"

<dd> Table declarations are done using many tokens; this example has seven.
The comma is a token.  The discussion of tables having literals is not about
table declarations, it is about table values; table variables can be
assigned directly from JSON objects, which are themselves composed
from many tokens. Table literals are JSON objects.

<dt> "godlex.htm" suggests lots of tokens not present elsewhere in the spec.
Do we have to do all of them?

<dd> My thinking evolved here. First I was thinking, yes recognize
all of Godiva, or even all of Java, and print an error message for unsupported
features.  But really, that's a pain and brings us little value. So no,
you can use things you see in godlex.htm to make your life easier, but
you do not have to recognize larger Godiva or Java features, just the ones
discussed explicitly in the g0 language reference.

<dt> You mentioned that the next homework assignment, we won't be calling
<code>yylex()</code> from <code>main()</code> (which is why you previously
mentioned you cannot allocate the token structure in <code>main()</code>).
I have followed that rule,
but I question how will linked lists be set up in Homework #2 then?

<dd> In HW#2 the linked list will be subsumed (that is, replaced) by you
building a tree data
structure. If you built a linked list inside <code>yylex()</code>, that
would be a harmless waste of time and space and could be left in place.
If you malloc'ed the token structs inside <code>yylex()</code> but
built the linked list in your <code>main()</code>, your linked list
will just go away in HW#2 when we modify <code>main()</code> to call
the Bison parser function <code>yyparse()</code> instead of the loop
that repeatedly calls <code>yylex()</code>.

<dt> Can you test my scanner and see if I get an "A"?
<dd> No.
<dt> Can you post tests so I can see if my scanner gets an "A"?
<dd> See <A href="g0-sample/examp.html">these g0 sample files</A>.
     If you share additional tests that you devise, for example
     when you have questions, I will add them to this collection
     for use by the class.
<dt> So if I run OK on these files, do I get an "A"?
<dd> Maybe.
     You should devise "coverage tests" to hit all described features.

<!--
<dt>
Each time a regular <em>user-written</em> include file is "handled",
we must stop the current yyin file (and save it), and open this new
file and assigning it yyin, and read from the user-defined include
file. Once we finish with the include file, do we have to go back
(somehow) to where yylex was reading from the original yyin?

<dd> Yes. Excellent question because it points out that
switching between files is more than just switching saving and restoring
the global FILE * yyin variable, which (if left open) would retain its
cursor position: flex seems to do its own layer of buffering in addition to
the buffering built-in to C stdio files.
Note that the sample clex.l file omits the saving and restoring of flex's
buffer state, and naively tries to just assign a new yyin and go on.
<p>

Section 11 of the flex manual provides the tools to correct and complete
(or replace entirely) the include mechanism started in clex.l.  Function
<code>yypush_buffer_state()</code>, or function
<code>yy_switch_to_buffer()</code>, allows for switching back (either by
popping, or switching again) after an include file is completed.

<dt>
From reading the Homework #1 page, I can't seem to understand how
you want <em>system includes</em> to be handled. I'm still not really sure
what you want the 120++ lexical anyalzyer to do for system includes,
could you provide some more info?
<dd>
I dismiss the notion of including g++'s real system includes, because they
are too large and liable to have non-standard extensions.
You have two options: 1) set a global boolean flag for each
system include, from the small set that are allowed in 120++. Use those
flags later in your compiler to hardwire "built-in" globals/functions
into your global symbol table.
OR 2) implement the system includes by having the system includes pull in
a set of tiny "120++ include files" that you write for your compiler. For
portability, these should be located either relative to your compiler's
binary location, or built-in such that your compiler can place them in
the current directory as temporary files during the compile.

<dt>
When displaying the token per line, does that mean once we encounter a
user-defined include, it should begin displaying token info for its tokens?

<dd> Yes, and then switch back to the main source file after the #include has
been processed.
-->
</dl>


<h3> Flex Manpage Examplefest </h3>

To read a UNIX "man page", or manual page, you type "man <em>command</em>" 
where command is the UNIX program or library function you need information
on.  Read the man page for man to learn more advanced uses ("man man").
<p>

It turns out the flex man page is intended to be pretty complete, enough
so that we can draw our examples from it. Perhaps what you should figure
out from these examples is that flex is actually... flexible.  The first
several examples use flex as a filter from standard input to standard
output.


<UL>
<li> sneaky string removal tool:
<pre>
           %%
           "zap me"
</pre>
<li> excess whitespace trimmer
<pre>
           %%
           [ \t]+        putchar( ' ' );
           [ \t]+$       /* ignore this token */
</pre>
<li> sneaky string substitution tool:

<pre>
           %%
           username    printf( "%s", getlogin() );
</pre>
</ul>


<ul>
<li> Line Counter/Word Counter

<pre>
                   int num_lines = 0, num_chars = 0;

           %%
           \n      ++num_lines; ++num_chars;
           .       ++num_chars;

           %%
           main()
                   {
                   yylex();
                   printf( "# of lines = %d, # of chars = %d\n",
                           num_lines, num_chars );
                   }
</pre>


<li> Toy compiler example

<pre>
           /* scanner for a toy Pascal-like language */

           %{
           /* need this for the call to atof() below */
           #include &lt;math.h&gt;
           %}

           DIGIT    [0-9]
           ID       [a-z][a-z0-9]*

           %%

           {DIGIT}+    {
                       printf( "An integer: %s (%d)\n", yytext,
                               atoi( yytext ) );
                       }

           {DIGIT}+"."{DIGIT}*        {
                       printf( "A float: %s (%g)\n", yytext,
                               atof( yytext ) );
                       }

           if|then|begin|end|procedure|function        {
                       printf( "A keyword: %s\n", yytext );
                       }

           {ID}        printf( "An identifier: %s\n", yytext );

           "+"|"-"|"*"|"/"   printf( "An operator: %s\n", yytext );

           "{"[^}\n]*"}"     /* eat up one-line comments */

           [ \t\n]+          /* eat up whitespace */

           .           printf( "Unrecognized character: %s\n", yytext );

           %%

           main( argc, argv )
           int argc;
           char **argv;
               {
               ++argv, --argc;  /* skip over program name */
               if ( argc &gt; 0 )
                       yyin = fopen( argv[0], "r" );
               else
                       yyin = stdin;

               yylex();
               }
</pre>

</ul>


<h3> On the use of character sets (square brackets) in lex and similar tools </h3>

A student recently sent me an example regular expression for comments that read:
<pre>
   COMMENT [/*][[^*/]*[*]*]]*[*/]
</pre>
One problem here is that square brackets are not parentheses, they do not nest,
they do not support concatenation or other regular expression operators. They
mean exactly: "match any one of these characters" or for ^: "match any one
character that is not one of these characters".  Note also that you
<em>can't</em> use ^ as a "not" operator outside of square brackets: you
can't write the expression for "stuff that isn't */" by saying (^ "*/")


<A name=finiteautomata>
<h3> Finite Automata </h3>
</A>

Efficiency in lexical analyzers based on regular expressions is all about
how to best implement those wonders of CS 385: the finite automata. Today
we briefly review some highlights from theory of computation with an eye
towards implementation.  Maybe I will accidentally describe something
differently than how you heard it before.

<p>

A finite automaton (FA) is an abstract, mathematical machine, also known as a
finite state machine, with the following components:

<ol>
<li> A set of states S
<li> A set of input symbols E (the alphabet)
<li> A transition function move(state, symbol) : new state(s)
<li> A start state S0
<li> A set of final states F
</ol>

The word <em>finite</em> refers to the set of states: there is a fixed size
to this machine.  No "stacks", no "virtual memory", just a known number of
states.  The word <em>automaton</em> refers to the execution mode: there is
no brain, not so much as a instruction set and sequence of instructions.
The entire logic is just a hardwired short loop that executes the same
instruction over and over:

<pre>
   while ((c=getchar()) != EOF) S := move(S, c);
</pre>

What this "finite automaton algorithm" lacks in flexibility,
it makes up in speed.

<p>
<font size=1> <A name=8>lecture #8</A> began here</font>
<p>

No class on Monday; Monday is Labor Day.

<h3>Mailbag </h3>

<dl>
<dt> I am confused about stuff like string vs. String, and int vs. Integer.
<dd> In Java, String is a class, Integer is a class, and int is not a class.
     int and Integer are not the same thing, but are sort of the same thing.
     Although Godiva needs to accept a very Java-like notation,
     g0 maybe doesn't have to.  I would just as soon drop "Integer" and
     "String", and lowercase everything: int and string.  Some of my
     examples, derived from Godiva or Java, used the Caps.  I will fix all
     such examples.  Use int and string.

<dt> I am confused about the JSON thing, what do I have to do in HW#1 for it?
<dd> Supporting JSON entails that we should have comma and colon in your
     lexical analyzer.
     It provides some guidance regarding your other token categories,
     for example it tells you that negative numbers should be one token,
     not two. All larger JSON considerations, such as list and table literal
     values, will be handled in the grammar not the lexical analyzer. If we
     look at the "grammar" in the right column over on
     <A href="http://json.org">json.org</A>, about the top third of it is
     grammar rules for HW#2; the lower two thirds of it (from "string" through
     "ws") are lexical rules that you might choose to rewrite as macros or
     regular expressions in your flex file.

<dt>
Are we required to be using a lexical analysis error function lexerr()?
<dd>
<ul>
<li>
Whether you have a helper function with that particular name is up to you.
<li> You should report lexical errors in a manner that is helpful to the user.
Include line #, filename, and nature of the error if possible.
<li>Many lexical errors could consist of "Java token X is not legal in g0".
<li>You are allowed to stop with an error exit status when you find an error.
</ul>

<dt>
The HW1 Specification says we are to use at least 2 separately compiled
.c files. Does Flex's generated lex.yy.c count as one of them,
or are you looking for yet another .c file, aside from lex.yy.c? 

<dd>
lex.yy.c counts. You may have more, but you should at least have a lex.yy.c
or other lex-compatible module, and a main function in a separate .c file

<!--
<dt> The 120++ manual's lexical section does not include short/long int
and double types as it does in section 1, from Dr. Soule's book. Are we not
including these?
<dd> We are including short/long reserved words, they are in the 120++ book.
Subject to semantics requirements of ANSI C++, we might simplify our code
generation and implement all sizes as the same
thing (say, a 64-bit integer).

<dt> In reference to including libraries such as string or cstime, should be just use a flag to determine if these have been added, such as we did for iostream?
<dd> I recommend one flag for each supported include.  Technically, you do not
have to work out all the details in HW#1, since it will mainly start to get
used in the semantic analysis phase.

<dt> With those includes in mind, should we process functions included in those libraries differently? Such as cin.ignore() or rand(). 
<dd> These items are processed normally in the lexical and syntax analysis
phases*.  By the time we do semantic analysis, we will need a strategy for
pre-initializing the symbol table based on include-flags.   *Except:
typedef's, classes, and predefined type names may affect our syntax analysis.

<dt>
With the string library being included, do we not need to worry about char* types being present?
<dd> char * does appear in 120++. We will need to support basic pointer types.
More details will be needed in semantic analysis.  char  and * are two separate
tokens in your scanner of course.

<dt>
Do we need to include the referencing operator &amp;
<dd>
Yes.

<dt>
Is the distinction between and bitwise AND and referencing operation done by our grammar? 
<dd> Yes, the lexical analyzer just returns a token saying it saw an &amp;
and the syntax analyzer has to decide if that is used as a binary operator,
a unary modifer to a parameter, a unary address-of operator, etc.
-->

</dl>

<!--
<h3> <A href="http://www2.cs.uidaho.edu/~jeffery/courses/445/hw1/">Sample Solution for Homework #1</A> </h3>-->

<h3> DFAs </h3>

The type of finite automata that is easiest to understand and simplest to
implement <!--(maybe even in hardware)--> is called a deterministic finite
automaton (DFA).  The word <em>deterministic</em> here refers to the return
value of
function move(state, symbol), which goes to at most one state.

Example:
<p>
<pre>
S = {s0, s1, s2}
E = {a, b, c}
move = { (s0,a):s1; (s1,b):s2; (s2,c):s2 }
S0 = s0
F = {s2}
</pre>
<p>

Finite automata correspond in a 1:1 relationship to transition diagrams;
from any transition diagram one can write down the formal automaton in
terms of items #1-#5 above, and vice versa.  To draw the transition diagram
for a finite automaton:
<ul>
<li> draw a circle for each state s in S; put a label inside the circles
     to identify each state by number or name
<li> draw an arrow between S<sub>i</sub> and S<sub>j</sub>, labeled with x
     whenever the transition says to move(S<sub>i</sub>, x) : S<sub>j</sub>
<li> draw a "wedgie" into the start state S0 to identify it
<li> draw a second circle inside each of the final states in F
</ul>

<h3> The Automaton Game </h3>

If I give you a transition diagram of a finite automaton, you can hand-simulate
the operation of that automaton on any input I give you.


<h4> DFA Implementation </h4>

The nice part about DFA's is that they are efficiently implemented
on computers.  What DFA does the following code correspond to?  What
is the corresponding regular expression?  You can speed this code
fragment up even further if you are willing to use goto's or write
it in assembler.

<pre>
state := S0
for(;;)
   switch (state) {
   case 0: 
      switch (input) {
         'a': state = 1; input = getchar(); break;
         'b': input = getchar(); break;
	 default: printf("dfa error\n"); exit(1);
         }
   case 1: 
      switch (input) {
         EOF: printf("accept\n"); exit(0);
	 default: printf("dfa error\n"); exit(1);
         }
      }
</pre>

Flex has extra complications. It accepts multiple regular expressions, runs
them all in parallel in one big DFA, and adds semantics to break ties. These
extra complications might be viewed as "breaking" the strict rules of DFA's,
but they don't really mess up the fast DFA implementation.

<h4> Deterministic Finite Automata Examples </h4>

A lexical analyzer might associate different final states with different
token categories. In this fragment, the final states are marked by
"return" statements that say what category to return. What is incomplete
or wrong here?
<p>


<img src="http://www2.cs.uidaho.edu/~jeffery/courses/445/dfacat.png">
<p>


C Comments:<p>
<img src="http://www2.cs.uidaho.edu/~jeffery/courses/445/dfa-ccom.png">
<p>



<h3> C Comments Redux </h3>

<ul>
<li>
It takes less than 5 minutes to find a solution on the internet, but many
of them are in fact suboptimal.
<li> A FA might or might not give solution hints for the corresponding regex.
<li> Here is an internet solution, cleaned up:

<pre>
"/*"([^*]|"*"+[^/*])*"*"+"/"
</pre>
<li> Think hard about it. Does it have bugs?  It is pretty similar to the
     earlier amalgamated-student proposed solution, but a little cleaner.
</ul>


<h4> Nondeterministic Finite Automata (NFA's)</h4>

Notational convenience motivates more flexible machines in which function
move() can go to more than one state on a given input symbol, and some
states can move to other states even without consuming an input symbol
(&epsilon;-transitions).
<p>

Fortunately, one can prove that for any NFA, there is an equivalent DFA.
They are just a notational convenience. So, finite automata help us get
from a set of regular expressions to a computer program that recognizes
them efficiently.

<h4> NFA Examples </h4>

&epsilon;-transitions make it simpler to merge automata:<p>
<img src="http://www2.cs.uidaho.edu/~jeffery/courses/445/fa-eps.gif">
<p>

multiple transitions on the same symbol handle common prefixes:<p>
<img src="http://www2.cs.uidaho.edu/~jeffery/courses/445/fa-less.gif">
<p>

factoring may optimize the number of states.  Is this picture OK/correct?<p>
<img src="http://www2.cs.uidaho.edu/~jeffery/courses/445/fa-less2.gif">
<p>


<h4> C Pointers, malloc, and your future </h4>

For many of you success as a computer scientist may boil down to what it
will take for you to master the concept of dynamically allocated memory,
and whether you are willing to do that.  In C this means pointers and the
<code>malloc()</code> family of functions.  Here are some tips:

<ul>
<li> Draw "memory box" pictures of your variables.  Pencil and paper
     understanding of memory leads to correct running programs.
<li> Always initialize local pointer variables.  Consider this code:
<pre>
void f() {
   int i = 0;
   struct tokenlist *current, *head;
   ...
   foo(current)
}
</pre>

Here, <code>current</code> is passed in as a parameter to foo, but it is a
pointer that hasn't been pointed at anything. I cannot tell you how many
times I personally have written bugs myself or fixed bugs in student code,
caused by reading or writing to pointers that weren't pointing at anything
in particular.  Local variables that weren't initialized point at random
garbage. If you are lucky this is a coredump, but you might not be lucky,
you might not find out where the mistake was, you might just get a wrong answer.
This can all be fixed by

<pre>
   struct tokenlist *current = NULL, *head = NULL;
</pre>

<LI> Avoid this common C bug:
<pre>
struct token *t = (struct token *)malloc(sizeof(struct token *)));
</pre>
This compiles, but causes coredumps during program execution.  Why?

<li> Check your <code>malloc()</code> return value to be sure it is not
NULL.  Sure, modern programs have big memories so you think they will "never
run out of memory".  Wrong. <code>malloc()</code> can return NULL even on
big machines.  Operating systems often place limits on memory far beneath
the hardware capabilities.  wormulon (or cs-course42) is likely a conspicuous
example. Machine shared across 40 users?  You may have a lower memory
limit than you think.

</ul>


<h4> NFA examples - from regular expressions </h4>

Can you draw an NFA corresponding to the following?

<pre>
(a|c)*b(a|c)*

(a|c)*|(a|c)*b(a|c)*

(a|c)*(b|&epsilon;)(a|c)*
</pre>




<h3> Regular expressions can be converted automatically to NFA's </h3>

Each rule in the definition of regular expressions has a corresponding
NFA; NFA's are <i>composed</i> using &epsilon; transitions.  This is called
"Thompson's construction" <!--(Louden pg. 64, ASU Algorithm 3.3-->).
We will work
examples such as (a|b)*abb in class and during lab.

<ol>
<li> For &epsilon;, draw two states with a single &epsilon; transition.
     <br><img src="http://www2.cs.uidaho.edu/~jeffery/courses/445/fa-th2.gif">
<li> For any letter in the alphabet, 
     draw two states with a single transition labeled with that letter.
     <br><img src="http://www2.cs.uidaho.edu/~jeffery/courses/445/fa-th1.gif">
<li> For regular expressions r and s, draw r | s
     by adding a new start state with &epsilon; transitions to the start
     states of r and s, and a new final state with &epsilon; transitions
     from each final state in r and s.
     <br><img src="http://www2.cs.uidaho.edu/~jeffery/courses/445/fa-th4.gif">
<li> For regular expressions r and s, draw rs
     by adding &epsilon; transitions from the final states of r to the
     start state of s.
     <br><img src="http://www2.cs.uidaho.edu/~jeffery/courses/445/fa-th3.gif">
<li> For regular expression r, draw r*
     by adding new start and final states, and &epsilon; transitions
<ul>
	<li> from the start state to the final state,
	<li> from the final  state back to the start state,
	<li> from the new start to the old start and from the old final
            states to the new final state.
</ul>
     <br><img src="http://www2.cs.uidaho.edu/~jeffery/courses/445/fa-th5.gif">
<li> For parenthesized regular expression (r) you can use the NFA for r.
</ol>


<p>
<font size=1> <A name=9>lecture #9</A> began here</font>
<p>

<h3> Announcement </h3>

How many of you have tried out cs-course42 instead of wormulon?  We have the
following request from Victor, our system admin:

<blockquote>
It would be good to tell students that the updated software runs on the new
course server.  Wormulon is behind in the compiler.  I am not going to tell
students not to use Wormulon, but next semester it will be gone.  In a few
weeks I will change the banner to alert to its inevitable going away.

<p>

This is the semester to make sure it works before Wormulon goes away.  So if
you could encourage users to do all their work on cs-course42 that would be
great.
</blockquote>

You are officially so encouraged. Note that cs-course42 has gcc 4.8.5 (2015)
but wormulon is gcc 4.4.7 (2010). I will run tests on cs-course42.

<h3> Mailbag </h3>

The theme of today's exciting mailbag is: for HW#1, just worry about
lexical aspects. Leave syntax and semantics for when they are assigned.

<dl>
<dt> How do I deal with semi-colons?
<dd> For HW#1, add an integer token category for them, and return that if you
     see one, even though we don't expect it to appear
     explicitly in source code.  For HW#2 your options are to write a grammar
     that doesn't need semi-colons and works anyhow, or write a grammar that
     needs semi-colons, and perform semi-colon insertion.

<dt> I'm trying to understand the <code>d</code> operator.
     What about the following:
<pre>
  d20
  d 20
  d x
  d(x)
  5d16
  5d 16
  5 d16
  5 d 16
  x d16
  x d 16
  (x)d16
  (x)d 16
  5d x
  5 d x
  5d(x)
  5 d(x)
  x d y
  (x) d y
  x d (y)
  (x)d(y)
</pre>
<dd>
Thank you for really pushing the question: what is the d operator.
The intention is indeed that everything that makes sense shall work.
Almost ALL of the patterns listed here come about naturally from adding
a "d" operator in the context free grammar in HW#2. The only things you
have to worry about for HW#1 is what letters belong to how many tokens
in what token categories.  For example, is d20 one token, or two?  It
matches the regex for variable names, but we need it to be two tokens.
Can we do that with flex regular expressions' lookahead operator, or are
we going to have to special-case it as one complex token and have
special treatment for it in the grammar?


<!--
<dt>I'm still not super clear what should happen with system includes.
They will eventually be stored in a symbol table for Bison. The symbol 
table should be a hash table. But what is being stored there?
Should I look up every variable and function name in the 6 libraries 
mentioned by 120++, and manually add them all to the symbol table?
-->
<dd> By Homework #2, we will have to know what identifiers are the names
of types (classes) in order to return the correct category for them.
By homework #3 we will want to store type information for these system
functions and parameters and such, and be able to check calls for validity.

<!--
<dt>
120++ mentions "built-in" classes or functions -- <<, >>, cout, 
cin, string, ifstream, etc. What does that mean in terms of the lexer?
<dd> The lexer should include operators (separate integer categories/codes)
     for all C++ operators.  The lexer should treat built-ins that are not
     reserved words as identifiers.  We will need to revisit this topic
     next assignment.
-->

<!--
<dt> I was curious if character literals (i.e. 'a' or 'b') need to be stored as an ival or maybe sval?

<dd> Yes. Easiest would be to treat them similar to a string and store an
sval that is only one character long.
-->

<!--
<dt> Are we supposed to distinguish between pointers and multiplication for our scanner? They use the same symbol, but are we supposed to know when it's considered a pointer and when it's considered multiplication?

<dd> No. The lexical analyzer doesn't know the surrounding syntax context
that would say what the token is used for, it just knows it sees a *
-->
</dl>

<h3> Semi-Colon Insertion in Unicon </h3>

<ol>
<li> Categorize for each token: is it a legal Beginner?
<li> Categorize for each token: is it a legal Ender?
<li> Remember previous token's Ender status, update each call to yylex()
<li> Set a flag every newline to mark the next token First_on_a_line;
     update each call to yylex()
<li> Algorithm for new yylex():
<pre> 
   IF we saved last token and returned Semi-Colon last time THEN
      return saved token
   ELSE {
      call old yylex()
      IF First_on_a_line AND Beginner AND last.Ender THEN {
          save_token; return Semi-Colon
          }
      ELSE return token
      }
</pre>
</ol>



<h3> NFA's can be converted automatically to DFA's </h3>

In: NFA N<br>
Out: DFA D<br>
Method: Construct transition table Dtran (a.k.a. the "move function").
Each DFA state is a set of
NFA states. Dtran simulates in parallel all possible moves N can make
on a given string.
<p>

Operations to keep track of sets of NFA states:
<p>
<dl>
<dt>&epsilon;_closure(s)</dt>
<dd> set of states reachable from state s via &epsilon;</dd>
<dt>&epsilon;_closure(T)</dt>
<dd> set of states reachable from any state in set T via &epsilon;</dd>
<dt>move(T,a)</dt>
<dd> set of states to which there is an NFA transition from states in T on symbol a</dd>
</dl>
<p>

NFA to DFA Algorithm:
<p>
<pre>
Dstates := {&epsilon;_closure(start_state)}
while T := unmarked_member(Dstates) do {
	mark(T)
	for each input symbol a do {
		U := &epsilon;_closure(move(T,a))
		if not member(Dstates, U) then
			insert(Dstates, U)
		Dtran[T,a] := U
	}
}
</pre>

<p>
<font size=1> <A name=10>lecture #10</A> began here</font>
<p>

<h3> Mailbag </h3>

<dl>
<dt> In the hw1.html example, the string "Hello, world" in the source code
does not match the example token output.
<dd> Thanks for the catch, you are correct.  write() semantics includes
automatically appending a newline to its written output but that is NOT
something the lexical analyzer should know about.

<dt> Do you have any cool tips to share regarding the un-escaping of special
characters?
<dd> By default, you are copying character-by-character from the yytext into
a newly allocated array. Every escape sequence of multiple characters in yytext
represents a single character in
sval. Inside your loop copying characters from yytext into sval,
if you see a backslash in yytext, skip it and use a switch statement
on the next character.  See below for additional discussion.

<dt> Which of the following are allowed?
<pre>   write(3.14159)
   write("3.14" "159")
   write("3.14" 159)
   write(3.14 159)
</pre>
<dd> The first case activates the semantics of write(), which is
to automatically convert numeric arguments to string: OK.  The second
case utilizes the implicit concatenation operator and passes write() a string.
The third case and fourth cases attempt to invoke concatenation on numbers,
which is a semantic error (no error in HW#1 or 2, error will be caught in
HW#3). The reason implicit string concatenation does not autoconvert numbers
is that I suspect it is just as likely to be an inadvertently left-out
+ or * or whatever, as it is an attempt at a concatenation.


<dt>What do you mean, for ival/dval/sval, by telling us to
    "store binary value here"
<dd>A binary value is the actual native representation that corresponds to
the string of ASCII codes that is the lexeme, for example what you get when
you call atoi("1234") for the token "1234".

<dt> I am getting a lot of "unrecognized rule" errors in my .l file
<dd> Look for problems with regular expressions or semantic actions prior to
     the first reported error.  If you need better diagnosis, find a way to
     show me your code. One student saw these errors because they omitted
     the required space between their regular expressions and their C semantic
     actions.

<!--
<dt>
C++14 supports binary by using "0b"
<dd>
OK, that means you should write a regular expression for it, allow it on input,
and print an error message if you encounter it.
-->

<dt>
How can we represent and print out the binary value in ival and dval?
Wouldn't both ival and dval need to be char arrays types to actually display
a "binary representation"?

<dd>
You do NOT have to convert to a binary string representation or output anything
in 0b010101010000 format.

<!--
<dt>
The 120++ manual mentions "_123 is not a legal variable name (does not contain a letter), while the C/C++ languages allow it (underscore is considered to be a letter). The ideal treatment in 120++ would be to issue a warning (at most once).". So, should I follow that rule?
<dd>
Things in C++ that are not in 120++ are allowed to print an error
and exit.
-->

<dt>
Is a function name also an identifier?
<dd>
Yes.
</dl>

<h3> HW #1 Tips </h3>

These comments are based on historical solutions. I learned a lot from my
older siblings when I was young. Consider this your opportunity to learn
from your Vandal forebears' mistakes.

<UL>
<li> better solutions' lexer actions looked like
<pre>
...regex...      { return token(TERMSYM); }
</pre>
     where token() allocates a token structure, sets a global variable to
     point to it, and returns the same integer category that it is passed
     from yylex(), so yylex() in turn returns this value.
<li> Put in enough line breaks.
     Use &lt;= 80 columns in your code, so that it prints readably.
<li> Comment non-trivial helper functions.  Comment non-trivial code.
     Comment appropriate for a CS professional reader, not a newbie tutorial.
     I know what i++ does, you do not have to tell me.
<li> Do not leave in commented-out debugging code or whatever.
<!--
<li> Does lexer know about C++ library things like cin?  Can it report good
     errors for those if the required system include file was not included?
     (Generally: no, it can't).
-->
<li> Fancier formatting might calculate field widths from actual data
     and use a variable to specify field widths in the printf. You don't
     have to do this, but if you want to it is not that hard.
<li> Remind yourself of the difference between NULL and '\0' and 0
<li> Avoid O(n<sup>2</sup>) or worse, if at all possible
<li> Avoid big quantities of duplicate code
<li> Use a switch when appropriate instead of long chain of if-statements
<li> On strings, allocate one byte extra for NUL.
<li>  On all pointers,
     don't allocate and then just point the pointer someplace else
     (memory leak)
<li> Don't allocate the same thing over and over unless copies may need
     to be modified.
<li> Check all allocations for NULL return (good to have a helper function)
<li> Check all fopen() calls for NULL return (good to have a helper function)
<li> Beware losing the base pointer that you allocated. You can only free()
     if you still know where the start of what you allocated was.
<li> Avoid duplicate calls to strlen(), especially in a loop! (Its O(n<sup>2</sup>))
<li> Use strcpy() instead of strncpy() unless you are really
     copying only part of a string, or
     copying a string into a limited-length buffer.
</UL>



<h3> On resizing arrays in C </h3>

The sval attribute in the homework is a perfect example of a problem which a
Business (MIS) major might not be expected to solve well, but a CS major
should be able to do by the time they graduate.  This is not to encourage
any of you to consider MIS, but rather, to encourage you to learn how to
solve problems like these.

<p>

The problem can be summarized as: step through yytext, copying each character
out to sval, <!--removing doublequotes and plusses between the pieces, and
evaluating CHR$() constants. -- this was for BASIC -->
looking for escape sequences.

<P>

Space allocated with malloc() can be increased in size by realloc().
realloc() is awesome.  But, it COPIES and MOVES the old chunk of
space you had to the new, resized chunk of space, and frees the old
space, so you had better not have any other pointers pointing at
that space if you realloc(), and you have to update your pointer to
point at the new location realloc() returns.

<!--
<pre>
i = 0; j = 0;
while (yytext[i] != '\0') {
   if (yytext[i] == '\"') {
      /* copy string into sval */
      i++;
      while (yytext[i] != '\"') {
         sval[j++] = yytext[i++];
         }
      }
   else if ((yytext[i] == 'C') || (yytext[i] == 'c')) {
      /* handle CHR$(...) */
      i += 5;
      k = atoi(yytext + i);
      sval[j++] = k;           /* might check for 0-255 */
      while (yytext[i] != ')') i++;
      }
   /* else we can just skip it */
   i++;
}
sval[j] = '\0'; /* NUL-terminate our string */
</pre>
-->
<p>

There is one more problem: how do we allocate memory for sval, and how big
should it be?

<ul>
<li> Solution #1: sval = malloc(strlen(yytext)+1) is very safe, but wastes
     space.
<li> Solution #2: you could malloc a small amount and grow the array as
     needed.
<pre>
sval = strdup("");
...
sval = appendstring(sval, yytext[i]); /* instead of sval[j++] = yytext[i] */
</pre>
where the function appendstring could be:
<pre>
char *appendstring(char *s, char c)
{
    i = strlen(s);
    s = realloc(s, i+2);
    s[i] = c;
    s[i+1] = '\0';
    return s;
}
</pre>
Note: it is very inefficient to grow your array one character at
a time; in real life people grow arrays in large chunks at a time.

<li> Solution #3: use solution one and then shrink your array when you
find out how big it actually needs to be.
<pre>
sval = malloc(strlen(yytext)+1);
/* ... do the code copying into sval; be sure to NUL-terminate */
sval = realloc(sval, strlen(sval)+1);
</ul>


<h3> Practice converting NFA to DFA </h3>

OK, you've seen the algorithm, now can you use it?<p>
<img src="http://www2.cs.uidaho.edu/~jeffery/courses/445/nfadfa.gif">
<p>
...
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
...did you get:<p>
<img src="http://www2.cs.uidaho.edu/~jeffery/courses/445/nfadfa2.gif">
<p>
<br>
<br>
<br>
<br>
OK, how about this one: <p>
<img src="http://www2.cs.uidaho.edu/~jeffery/courses/445/nfadfa3.gif">
<p>

<p>
<font size=1> <A name=11>lecture #11</A> began here</font>
<p>

Congratulations on making it to HW#1 Is Due Today Day.

<h3>Mailbag</h3>

<dl>
<dt> Can I have an extension on HW#1?
<dd> A Dr's note or family emergency or school- or work-related required
     travel might constitute a valid excuse for an extention. For everyone
     else the late fee will be 10% per day. Falling behind might
     make doing the subsequent homeworks difficult or impossible.

<!--
<dt> when reading the 120++ manual, its sometimes hard to interpret the list
of rules/attributes, should I aim for everything in 120++ manual that I find
"mentioned" in regards to lexical rules being tokenized? and then playing it
safe by having all C++14-special rules state some lexical
error and then exit?

<dd> yes, you are charged with recognizing C++14 at the lexical level, even
though we will only be handling a tiny subset of C++14 (i.e. 120++) by the
time we get to code generation.  You can sort of view lexical, syntax, and
semantic analysis as all filtering out (or paring down) things in C++ so you
won't have to generate code for them.  But you want to give the programmer
a good message that explains why it won't compile, so they can fix it if they
want.
-->

</dl>

<h3> More Tips on HW#1 </h3> 

<dl>
<dt> You can't <code>malloc()</code> in a global initializer
<dd> <code>malloc()</code> is a runtime allocation from a memory
     region that does not
     exist at compile or link time. Globals can be initialized, but not to
     point at memory regions that do not exist until runtime.
<dt> Don't use raw constants like 260
<dd> use symbolic names, like LEFTPARENTHESIS or LP
<dt> The vertical bar (|) means nothing inside square brackets!
<dd> Square brackets are an implicit shortcut for a whole lot of ORs
<dt> If you don't allocate your token inside yylex() actions...
<dd> You'll have to go back and do it, you need it for HW#2.
<dt> If your regex's were broken
<dd> If you know it, and were lazy, then fix it.  If you don't know it,
     then good luck on the midterm and/or final, you need to learn these,
     and devise some (hard) tests!
</dl>

<h3> Look at <A href="hw2.html">HW#2</A> </h3>

<!--
<h2> Some Remarks (BASIC)</h2>

<ul>
<li> Color BASIC has two-letter identifiers.  We are doing Extended Color
     BASIC, so we will allow longer identifier names.  But in the current
     assignment #2 you will only be tested on short variable names.
<li> Whether we return the same or a different category for integer constants
     and for line numbers depends very much on the grammar we use to parse
     our language,
     and whether it can understand what's going on with the
     line numbers if it doesn't have two categories.  My instinct tells me
     we will probably need either a token for newline characters or will
     need to detect line numbers as distinct from normal integer constants.
     Before we can answer that question, we need to learn about syntax!
</ul>
-->

<!--
<h3> Lexical Analysis and the Literal Table </h3>

In many compilers, the memory management components of the compiler interact
with several phases of compilation, starting with lexical analysis.

<p>

<ul>
<li> Efficient storage is necessary to handle large input files.
<li> There is a colossal amount of duplication in lexical data:
     variable names, strings and other literal values duplicate frequently
<li> What token type to use may depend on previous declarations.
</ul>
<p>
A hash table or other efficient data structure can avoid this duplication.
The software engineering design pattern to use is called the "flyweight".


<h3> Literal Table: Usage Example </h3>

Example abbreviated from [ASU86]: Figure 3.18, p. 109.  Use "install_id()"
instead of "strdup()" to avoid duplication in the lexical data.

<pre>
%{
/* #define's for token categories LT, LE, etc.
%}

digit   [0-9]
id	[a-zA-Z_][a-zA-Z_0-9]*
num     {digit}+(\.{digit}+)?

%%

[ \t\n]+ { /* discard */ }
if	 { return IF; }
then	 { return THEN; }
else	 { return ELSE; }
{id}	 { yylval.id = install_id(); return ID; }
{num}    { yylval.num = install_num(); return NUMBER; }
"&lt;"	 { yylval.op = LT; return RELOP; }
"&gt;"	 { yylval.op = GT; return RELOP; }

%%

install_id()
{
   /* insert yytext into the literal table */
}

install_num()
{
   /* insert (binary number corresponding to?) yytext into the literal table */
}
</pre>

So how would you implement a literal table using a hash table?  We will see
more hash tables when it comes time to construct the symbol tables with which
variable names and scopes are managed, so you had better become fluent.


<h3> Major Data Structures in a Compiler </h3>

<dl>
<dt> token
<dd> contains an integer category, lexeme, line #, column #, filename...
     We could build these into a link list, but instead we'll use them
     as leaves in a tree structure.
<dt> syntax tree
<dd> contains grammar information about a sequence of related tokens.
     leaves contain lexical information (tokens).  internal nodes
     contain grammar rules and pointers to tokens or other tree nodes.
<dt> symbol table
<dd> contains variable names, types, and information needed to generate
     code for a name (such as its address, or constant value).  Look ups
     are by name, so we'll need a hash table.
<dt> intermediate &amp; final code
<dd> We'll need link lists or similar structures to hold sequences of machine
     instructions
</dl>


<h4> Quick Note on things to look for in HW </h4>

<ul>
<li> Adding reserved words is trivial. But clex.l was for C, and we
     need some of the C++ reserved words for 120++.
<li> Also look for: any new data types (besides bool) and their new
     types of literal constants?
     New literals require new nontrivial regular expressions in your
     lex file.
<li> If there are bugs in the clex.l file you were given, the
ones we would be most likely to care about are bugs in the regular expressions
for literal constants.  This calls for close scrutiny and painstaking attention
to detail...
</ul>

-->

<h3>Discussion of <A href="hw2.html">HW#2</A></h3>

<p>
<font size=1> <A name=12>lecture #12</A> began here</font>
<p>

<h3>Mailbag</h3>

<dl>
<dt> Do I have to support (comma-separated) lists of variables?
<dd> Yes.
<dt> In div0.g0 and if1.g0 there is a variable d. I thought d was a
     reserved word. What gives?
<dd> You are correct, d is a reserved word, trying to use it as a variable
     should result in a syntax error.
<dt> For built-in function write(), should I just allow any expression and
     typecheck it later?
<dd> Correct. For <code>write(x)</code> you won't know until semantic analysis
     whether <code>x</code> is something that you can write, or if it is an
     error.
<dt> For concatenation, should I restrict the types at this stage?
<dd> For <code>x y</code> you won't know x and y's types yet to know whether
     they can be concatenated. Save that for semantic analysis
<dt> calc.g0 had a lexeme "do" that wasn't on the reserved words list
<dd> Good catch. That would be an identifier for you.
<dt> foo.g0 has a list declaration with C-style initializer using curly
     braces, but if we are doing JSON it should be square brackets.
<dd> Good catch. We will stick to JSON. Square brackets it is.
<dt> body.g0 uses assignments in assignments. Are we supporting that?
<dd> Yes, like in C.  Assignment is an binary operator whose left-hand
     side must be a variable. It is right associative.  The result of the
     assignment expression is the variable that just received a new value;
     that is what is evaluated and used in any surrounding expression.
<dt> When it comes to the symbol table, should I enter a value every time I
     hit an identifier?
<dd> It is more complicated than that. We will discuss in class.
<dt> Should read and write already be in the symbol table?
<dd> Yes, you should insert them prior to the start of semantic analysis.
</dl>

<A name="syntax"><h2> Syntax Analysis </h2></A>

<em>Parsing</em> is the act of performing syntax analysis to verify an input
program's compliance with the source language.  A by-product of this process
is typically a tree that represents the structure of the program.


<h3> Context Free Grammars </h3>

A context free grammar G has:

<ul>
<li> A set of terminal symbols, T
<li> A set of nonterminal symbols, N
<li> A start symbol, s, which is a member of N
<li> A set of production rules of the form A -> &omega;,
     where A is a nonterminal and &omega; is a string of terminal and 
     nonterminal symbols.
</ul>

A context free grammar can be used to <em>generate</em> strings in the
corresponding language as follows:
<pre>let X = the start symbol s
while there is some nonterminal Y in X do
   apply any one production rule using Y, e.g. Y -> &omega;
</pre>
When X consists only of terminal symbols, it is a string of the language
denoted by the grammar.  Each iteration of the loop is a
<em>derivation step</em>.  If an iteration has several nonterminals
to choose from at some point, the rules of derviation would allow any of these
to be applied.  In practice, parsing algorithms tend to always choose the
leftmost nonterminal, or the rightmost nonterminal, resulting in strings
that are <em>leftmost derivations</em> or <em>rightmost derivations</em>.

<h3> Context Free Grammar Examples </h3>

Well, OK, so how much of the <!--BASIC--> C language grammar can we come up
with in class today?  Start with expressions, work on up to statements, and
work there up to entire functions, and programs.


<h3> Context Free Grammar Example (from BASIC) </h3>

How many terminals and non-terminals does the grammar below use?
Compared to the little grammar we started last time, how does this rate?
What parts make sense, and what parts seem bogus?

<pre>
Program : Lines
Lines   : Lines Line
Lines   : Line
Line    : INTEGER StatementList
StatementList : Statement COLON StatementList
StatementList : Statement
Statement: AssignmentStatement
Statement: IfStatement
<em> REMark: ... BASIC has many other statement types </em>

AssignmentStatement : Variable ASSIGN Expression
Variable : IDENTIFIER
<em> REMark: ... BASIC has at least one more Variable type: arrays </em>

IfStatement: IF BooleanExpression THEN Statement
IfStatement: IF BooleanExpression THEN Statement ELSE Statement

Expression: Expression PLUS Term
Expression: Term
Term      : Term TIMES Factor
Term      : Factor
Factor    : IDENTIFIER
Factor    : LEFTPAREN Expression RIGHTPAREN
<em> REMark: ... BASIC has more expressions </em>
</pre>



<h3> A brief aside on casting your mallocs </h3>

<li> If you don't put a prototype for malloc(), C thinks it returns an int.
<pre>
#include &lt;stdlib.h&gt;
</pre>
includes prototypes for malloc(), free(), etc.  malloc() returns a void *.
<br><br>

<li> void * means "pointer that points at nothing", or "pointer that points
     at anything".  You need to cast it to what you are really pointing at,
     as in:
<pre>
union lexval *l = (union lexval *)malloc(sizeof(union lexval));
</pre>
Note the stupid duplication of type information; no language is perfect!
Anyhow, always cast your mallocs.  The program may work without the cast,
but you need to fix every warning, so you don't accidentally let a serious
one through.<br><br>

<p>
<font size=1> <A name=13>lecture #13</A> began here</font>
<p>

<h3>Mailbag</h3>

Several of you have apologized for asking me lots of juicy questions by e-mail;
really, I want to <em>thank</em> all of you who are doing so.

<dl>
<dt> I am trying to get a more basic picture of the communication that happens between Flex and Bison. From my understanding:

<ol>
<li>main() calls yyparse()
<li>yyparse() calls yylex()
<li>yylex() returns tokens from the input as integer values which are enumerated to text for readability to the .y file
<li> yyparse() tries to match these integers against rules of our grammar
<br>
(if it unsuccessful it errors (shift/reduce, reduce/reduce, unable to parse))
</ol>
Is this correct?
<dd>1-3 are correct. 3 also includes: yylex() sets a global variable so that
yyparse() can pickup the lexical attributes, e.g. a pointer to struct token.
4 is correct except that shift/reduce and reduce/reduce conflicts are found
at bison time, not at yyparse() runtime.  But yes yyparse() can find syntax
errors and we have to report them meaningfully.

<dt> Does <code>yylval</code> have any use to us? In CS 210 we did a 
calculator and it was used to bring the value of the token into the parser.
<dd> Yes, <code>yylval</code> is how yyparse() picks up lexical attributes.
     We will talk about it more in class.

<dt>How would we add artificial tokens, like the semi-colon, without skipping
real tokens when we return?
<dd> Save the real, found token in a global or static, or figure out a way to
push it back onto the input stream.  Easiest is a one-token saved (pointer to
a) token struct.

<dt> Since we are adding semi-colons without knowledge
of the grammar how do we avoid simply putting a semi-colon at the end of
every line? Is there a set group of tokens that can't add semi-colons?
<dd> You make an interesting point that one could maybe do semi-colon
insertion with guidance from the parser, but it is intended that it be
done in the way described previously in class: classify every token as
to whether it is a legal statement-beginner, and whether it is a legal
statement-ender.  Insert semi-colons at newlines between an ender and
a beginner.  Example classification (via an array of booleans or whatever):

<table border>
<tr><th>token<th>Beginner?<th>Ender?
<tr><td>  x  <td> yes <td> yes
<tr><td>  1  <td> no?  <td> yes
<tr><td>  if <td> yes <td> no
<tr><td>  (  <td> yes <td> no
<tr><td>  )  <td> no <td> yes
<tr><td>  +  <td> no? <td> no
<tr><td>  -  <td> no? <td> no
</table>

<dt> Does g0 allow for one-line if-statements without curly braces?
<dd> No, curly braces are required.

<dt> true and false are listed as reserved words, but there is no "bool"
     reserved word in the g0 language reference.  Do we need a boolean
     primitive type in order to use true and false?
<dd> I tried (possibly overly hard) to keep things simple here. I waffled
     because technically it is possible to use bool values in conditional
     expressions without allowing bool variables to be declared.  You could
     say stuff like
     <code> if (x&lt;y == true){...}</code>. But we put true and false in
     because they are part of JSON; so for HW#2 add "bool" as a reserved word.

<dt> Should augmented assignment and swap allow chaining?  What would
   <code>a :=: b :=: c</code> mean?  What about <code>a += b += c</code>?
<dd> They are right associative and produce their left operand (the variable).
     After b swaps with c, c's value is in b and that gets swapped into a; the
     net on a chained swap would be a circular shift right.
     After b is incremented by c, a is incremented by b's (incremented) value.

<dt> How can I make Bison use a different yylex in order to allow for
     semi-colon insertion?
<dd> Two possibilities come to mind:
<ol>
<li> Modify output of bison to replace the call to yylex() with myyylex()
<li> Modify output of flex to change its declaration of yylex to realyylex()
</ol>

<dt> I am doing column number error reporting. Should I add a column for
semi-colon insertion.
<dt> The semi-colon's column is at the end of the first line; it does
not affect the column numbers for the other tokens.

<dt> Can <code>return</code> have no value, e.g. for void functions?
<dd> Yes, and that means it is a legal Ender for semi-colon insertion.
     A g0 programmer has to write "return x", they cannot write
<pre>
   return
           x
</pre>

<dt> Does g0 support both statements with semi-colons and statements without
semi-colons?
<dd> You were given the option of just not allowing semi-colons, or allowing
them as optional.  If you are doing semi-colon insertion that implies that
they are optional.

<dt>Does g0 support empty statements?
<dd> Most C-based grammars allow these.  Occasionally I find them handy.
I would say they are optional for your compiler.
You are partly asking whether an (inserted) semi-colon is a legal Beginner
or Ender.

<dt> Why are lists declared as list&lt;int&gt; but tables are declared as
table table1&lt;int,string&gt;  ?
<dd> This should read table&lt;int,string&gt; table1.  Good catch.

</dl>

<h3> Grammar Ambiguity </h3>

The grammar

<pre>
E -> E + E
E -> E * E
E -> ( E )
E -> ident
</pre>

allows two different derivations for strings such as "x + y * z".
The grammar is ambiguous, but the semantics of the language dictate
a particular operator precedence that should be used.  One way to
eliminate such ambiguity is to rewrite the grammar. For example,
we can force the precedence we want by adding some nonterminals and
production rules.

<pre>
E -> E + T
E -> T
T -> T * F
T -> F
F -> ( E )
F -> ident
</pre>

Given the arithmetic expression grammar from last lecture:
<p>

How can a program figure that x + y * z is legal?<br>
How can a program figure out that x + y (* z) is illegal?
<p>



<A name=yacc>
<h3> YACC </h3>
</A>

YACC ("yet another compiler compiler") is a popular tool which originated at
AT&T Bell Labs.  YACC takes a context free grammar as input, and generates a
parser as output.  Several independent, compatible implementations (AT&amp;T
yacc, Berkeley yacc, GNU Bison) for C exist, as well as many implementations
for other popular languages. There also exist other more "modern" parser
generators, but they are often less portable and are
heavily inspired/influenced by YACC so it is what we will study. <p>

YACC files end in .y and take the form
<pre>
declarations
%%
grammar
%%
subroutines
</pre>
The declarations section defines the terminal symbols (tokens) and
nonterminal symbols. The most useful declarations are:
<dl>
<dt> %token a
<dd> declares terminal symbol a; YACC can generate a set of #define's
that map these symbols onto integers, in a y.tab.h file. <em><b> Note: don't
#include your y.tab.h file from your grammar .y file, YACC generates the
same definitions and declarations directly in the .c file, and including
the .tab.h file will cause duplication errors.</b></em>
<dt> %start A
<dd> specifies the start symbol for the grammar (defaults to nonterminal
     on left side of the first production rule).
</dl>
<p>
The grammar gives the production rules, interspersed with program code
fragments called semantic actions that let the programmer do what's
desired when the grammar productions are reduced.  They follow the
syntax
<pre>
A : body ;
</pre>
Where body is a sequence of 0 or more terminals, nonterminals, or semantic
actions (code, in curly braces) separated by spaces.  As a notational
convenience, multiple production rules may be grouped together using the
vertical bar (|).


<p>
<font size=1> <A name=14>lecture #14</A> began here</font>
<p>

<h3>Mailbag</h3>

<DL>
<dt> What element types can be used in lists and tables?  Can I have a
     list of lists?  A table of tables?

<dd> Legal element types are: int, double, string, and any of the class types
     (a.k.a. objects). List of lists and table of tables are awesome but you
     do not have to do them.  Note that objects can have lists or tables in
     their member variables.

<dt> What index types can be used in tables?
<dd> string and int.

<dt> You mentioned no-op statements like 2+2; but didn't specifically ban them.
     What up?
<dd> g0 does not include no-op statements like 2+2.

<dt> The g0gram.y you gave us has many symbols that have not been mentioned
     (DOT, PACKAGE, IMPORT, etc.). Should we support them, or not?  If we don't
     have to support them does that mean we don't have to include all the
     grammar rules that use them?
<dd> DOT (.) is needed, I think, to support classes to the basic degree we
     require. But the suppled "g0gram.y" is really the Godiva grammar and you
     will need to delete from it <em>en masse</em> to get down to g0.

<dt> What about
<pre>
   list L1, L2, L3, L4

   L4
   += 
   L1
   L2
   L3
</pre>
<dd> Wow, implicit semi-colons vs. implicit concatenation! Death match
     throw down! Identifiers are legal Beginners and Enders, so we get
     semi-colons inserted and if you want implicit concatenation of L1 L2 L3
     you will have to put them on the same line.


<!--
<dt> What is the included "nonterm.h" used for in 120gram.y?

<dd> Bison generates integer symbolic names for terminal symbols, they are
part of its public interface, and you have to use theirs in your yylex().
No such story can be told for how to represent in your parse tree either the
non-terminals or grammar rules: yes Bison must have some internal
enumeration but does not provide symbolic names for you.
nonterm.h is a header file where symbolic names for non-terminals
and/or production rules would be stored.
-->

<dt> How about a tool that would generate numbers
automatically from our grammar .y files?  It should perhaps use negative
numbers (to avoid overlap/conflicts with Bison-generated numbers for
terminal symbols).
<dd> I wrote a <A href="nonterms.icn">cheap hack version 0</A>
of such a tool...
</dl>


<h3> Midterm Exam Date Discussion </h3>

We will need to have a midterm on Oct 11.



<h3> Bottom Up Parsing (How Does Bison's yyparse() Work?) </h3>

Bottom up parsers start from the sequence of terminal symbols and work
their way back up to the start symbol by repeatedly replacing grammar
rules' right hand sides by the corresponding non-terminal.  This is
the reverse of the derivation process, and is called "reduction".
<p>

Example. For the grammar
<pre>
(1)	S->aABe
(2)	A->Abc
(3)	A->b
(4)	B->d
</pre>
the string "abbcde" can be parsed bottom-up by the following reduction
steps:
<pre>
abbcde
aAbcde
aAde
aABe
S
</pre>


<h3> Handles </h3>

Definition: a <em>handle</em> is a substring that
<ol>
<li> matches a right hand side of a production rule in the grammar and
<li> whose reduction to the nonterminal on the left hand side of that
     grammar rule is a step along the reverse of a rightmost derivation.
</ol>

<A name=shiftreduce>
<h3> Shift Reduce Parsing </h3>     
</A>

A shift-reduce parser performs its parsing using the following structure
<pre>
<u>Stack</u>					<u>Input</u>
$						&omega;$
</pre>
At each step, the parser performs one of the following actions.
<ol>
<li> Shift one symbol from the input onto the parse stack
<li> Reduce one handle on the top of the parse stack. The symbols
     from the right hand side of a grammar rule are popped off the
     stack, and the nonterminal symbol is pushed on the stack in their place.
<li> Accept is the operation performed when the start symbol is alone
     on the parse stack and the input is empty.
<li> Error actions occur when no successful parse is possible.
</ol>


<h3> The YACC Value Stack </h3>

<ul>
<li> YACC's parse stack contains only "states"
<li> YACC maintains a parallel set of values
<li> $ is used in semantic actions to name elements on the value stack
<li> $$ denotes the value associated with the LHS (nonterminal) symbol
<li> $n denotes the value associated with RHS symbol at position n.
<li> Value stack typically used to construct the parse tree
<li> Typical rule with semantic action: A : b C d { $$ = tree(R,3,$1,$2,$3); }
</ul>

<p>
<font size=1> <A name=15>lecture #15</A> began here</font>
<p>

<h3>Mailbag</h3>

<dl>
<dt> Will we get marked off for any reduce/reduce conflicts we have?
<dd> You will lose points if you turn in a HW#2 with reduce/reduce
conflicts. Hopefully we will define those in class soon!

<dt> How are we supposed to integrate the token names we created in the
     lexer with those token names in the Bison .y file?
<dd> Any which way you can.  Probably, you
     either rename yours to use their names, or rename theirs to
     use your names.

<dt> what action should be taken in the case of epsilon statements
<dd> either $$=NULL; or $$=alctree(EPSILON, 0); (i.e. a leaf)

<dt> Will I be setting myself up for failure if I attempt to write
     my own grammar from scratch?
<dd> Go right ahead and ignore the Godiva grammar if you want; feel free to
     instead derive your grammar from the g0 reference manual
     and the JSON definition at json.org.

</dl>

<h3> YACC Value Stack's Element Type: YYSTYPE </h3>

<ul>
<li> The default value stack is an array of integers
<li> The value stack can hold arbitrary values in an array of unions
<li> The union type is declared with %union and is named YYSTYPE
</ul>


<h4> Getting Lex and Yacc to talk </h4>

<ul>
<li> YACC uses a global variable named <code>yylval</code>, of type YYSTYPE,
to receive lexical information from the scanner.
<li> Whatever is in this variable <code>yylval</code> gets copied onto the
top of the value stack each time <code>yylex()</code> returns to the parser
</ul>
<p>

Options:
<ol>
<li> Declare that struct token may appear in the %union.
     In that case the value stack is a mixture of struct node
     and struct token.  You still have to have a mechanism for
     how do tokens get wired into your tree. Are all children
     of type union YYSTYPE, and you use the prodrule R
     to tell which are which?
<li> For each terminal symbol, allocate a "leaf" tree node with 0 children
     and point its "leaf" field at your struct token.  0 children implies
     "don't use the kids field" and "a non-null leaf might be present"
<li> declare a tree type that allows tokens to include
     their lexical information directly in the tree nodes, perhaps tree nodes
     contain a union that provides EITHER an array of kids OR a struct token.
</ol>

If you have more than one %union type possible, be prepared to see type
conflicts and to declare the types of all your nonterminals.

<p>

Getting all this straight takes some time; you can plan on it.  Your best
bet is to draw pictures of how you want the trees to look, and then make the
code match the pictures. Given pictures, I can help you make the code do
what the pictures say.  No pictures == "Dr. J will ask to see your
pictures and not be able to help if you can't describe your trees."


<h3> Declaring value stack types for terminal and nonterminal symbols </h3>

Unless you are going to use the default (integer) value stack, you will
have to declare the types of the elements on the value stack.  Actually,
you do this by declaring which
union member is to be used for each terminal and nonterminal in the
grammar.
<p>
Example: in the cocogram.y that I gave you we could add a %union declaration
with a union member named treenode:
<pre>
%union {
  nodeptr treenode;
}
</pre>

This will produce a compile error if you haven't declared a nodeptr type
using a typedef, but that is another story.  To declare that a nonterminal
uses this union member, write something like:
<pre>
%type < treenode > function_definition
</pre>

Terminal symbols use %token to perform the corresponding declaration.
If you had a second %union member (say struct token *tokenptr) you
might write:
<pre>
%token < tokenptr > SEMICOL
</pre>

<p>
<font size=1> <A name=16>lecture #16</A> began here</font>
<p>
<h3> Reading Assignment </h3>

<ul>
<li> Read sections 1, 3, 4, 5 and 6 of the <A href="https://www.gnu.org/software/bison/manual/html_node/">Bison Manual</A>
<li> Read Louden Chapter 3, section 1-6. You can skip the Tiny language
     description in 3.7.
</ul>

<h3> HW#1 Feedback </h3>

<ul>
<li> graded; in process of posting to bblearn
<li> some will need to resubmit, as the build failed on course42.cs.uidaho.edu
<li> for next time: add -Wall
<li> for next time: separate compilation or Else
<li> How did you tokenize 3D6?
</ul>

<h3> Mailbag </h3>

<dl>
<dt> When I compile my .y file, bison complains spitting out a bunch of
     warnings about useless nonterminals and rules. how much attention
     should I pay to this?
<dd> "Useless" warnings sound innocuous, but they mean what they say.
     You probably have something wrong that will have to be fixed.
     Everything but shift/reduce conflicts is potentially serious, until
     you determine otherwise. If you can't figure out what some Bison error
     is after giving it the reasonable college try, send it to me by e-mail
     or schedule an appointment.  If I am not available or you are remote,
     we may schedule a Zoom meeting.  You might have to learn some Zoom.
     I might have to setup a camera on my many machines, and remember my
     Zoom credentials.
<dt> I've been trying to implement implicit concatenation in the grammar
     and I'm getting reduce/reduce errors. Do you have any tips for
     implementing implicit concatenation? Should I make specific rules
     for concatenating strings and lists and stop trying to integrate
     it into my expression syntax?
<dd> If you can't get implicit concatenation working, you might resort
     to explicit concatenation via (perhaps) the + operator. Tips to avoid
     reduce/reduce errors include: avoid epsilon rules. MERGE rules that
     look like the same thing (in Ada, functions and arrays both used the
     same syntax!  sad!).  Incidentally, neither Unicon nor Java have
     implicit concatenation, so in g0 it is a "can we do it?" question.
     I would be happy to consult with folks on your grammarly endeavors
     in office hours and additional appointments.

<dt> It seems after HW#2 we will have to implement a hash table.
     If this is the case, what would be a reasonable size (# buckets) of
     the table?  n=20?
<dd> Fixed-size tables should use a prime. For the size of inputs
     I will ever manage in this class, probably a prime less than 100 would do.
     How about n=41 ?
<!--
<dt> Are we just supporting class, enum, typedef, and namespace identifiers and <em>not</em> structs?
<dd> 120++ has to my knowledge class, typedef, and struct but not
     enum or namespaces other than std.  Furthermore, typedef and
     struct are only mentioned in passing and not used significantly.
     About the only mention of them is
<pre>
typedef struct pet {
int happy;
int hunger;
char name[100];
} pet;
pet pet1, pet2;
</pre>

For the purposes of our class, the Best thing to do would be to
make the "type names table" record, for each name, whether it was
a struct label, a typedef name, or a class name.  However, it will
sufficient if all you managed was to return CLASS_NAME
instead of IDENTIFIER for names that were declared as the names of
classes.

<dt> I have mysterious syntax errors, what do I do?
<dd> #define YYDEBUG and set yydebug=1 and read the glorious output, especially
   the last couple shifts or reduces before the syntax error.
<dt> I can't fix some of the shift/reduce conflicts, what do I do?
<dd> Nothing. You do not have to fix shift/reduce conflicts.
<dt> I can't fix some of the reduce/reduce conflicts, what do I do?
<dd> Possibly nothing. Bison will always use one of the possibles,
     and never use the other, but that might not kill 120++. It is only
     a deal breaker and has to be fixed if it prevents us from parsing
     correctly and building our tree. Sometimes epsilon
     rules can be removed successfully by adding grammar rules in a
     parent non-terminal that omit an epsilon-deriving child, and then
     modifying the child to not derive epsilon. This might or might not
     help reduce your number of reduce/reduce conflicts.
-->
</dl>


<h3> Conflicts in Shift-Reduce Parsing </h3>

"Conflicts" occur when an ambiguity in the grammar creates a situation
where the parser does not know which step to perform at a given point
during parsing.  There are two kinds of conflicts that occur.

<dl>
<dt> shift-reduce
<dd> a shift reduce conflict occurs when the grammar indicates that
     different successful parses might occur with either a shift or a reduce
     at a given point during parsing.  The vast majority of situations where
     this conflict occurs can be correctly resolved by shifting.
<dt> reduce-reduce
<dd> a reduce reduce conflict occurs when the parser has two or more
     handles at the same time on the top of the stack.  Whatever choice
     the parser makes is just as likely to be wrong as not.  In this case
     it is usually best to rewrite the grammar to eliminate the conflict,
     possibly by factoring.
</dl>

Example shift reduce conflict:
<pre>
S->if E then S
S->if E then S else S
</pre>
<P>
In many languages two nested "if" statements produce a situation where
an "else" clause could legally belong to either "if".  The usual rule
(to shift) attaches the else to the nearest (i.e. inner) if statement.
<p>

Example reduce reduce conflict:
<pre>
(1)	S -> id LP plist RP
(2)	S -> E GETS E
(3)	plist -> plist, p
(4)	plist -> p
(5)	p -> id
(6)	E -> id LP elist RP
(7)	E -> id
(8)	elist -> elist, E
(9)	elist -> E
</pre>
By the point the stack holds ...id LP id<br>
the parser will not know which rule to use to reduce the id: (5) or (7).



<h3> Further Discussion of Reduce Reduce and Shift Reduce Conflicts </h3>

The following grammar, based loosely on our expression grammar from
last time, illustrates a reduce reduce conflict, and how you have to
exercise care when using epsilon productions.  Epsilon productions
were helpful for some of the grammar rewriting methods, such as removing
left recursion, but used indiscriminately, they can cause much trouble.

<pre>
T : F | F T2 ;
T2 : p F T2 | ;
F : l T r | v ;
</pre>

The reduce-reduce conflict occurs after you have seen an F.  If the next
symbol is a p there is no question of what to do, but if the next symbol
is the end of file, do you reduce by rule #1 or #4 ?
<p>


<h3> Back to Bison Conflicts and Ambiguity </h3>

A slightly different grammar is needed to demonstrate a shift-reduce conflict:

<pre>
T : F g;
T : F T2 g;
T2 : t F T2 ;
T2 : ;
F : l T r ;
F : v ;
</pre>

This grammar is not much different than before, and has the same problem,
but the surrounding context (the "calling environments") of F cause the
grammar to have a shift-reduce instead of reduce-reduce.  Once again,
the trouble is after you have seen an F and dwells on the question of
whether to reduce the epsilon production, or instead to shift, upon
seeing a token g.
<p>

The .output file generated by "bison -v" explains these conflicts in
considerable detail.  Part of what you need to interpret them are the
concepts of "items" and "sets of items" discussed below.

<P>
<p>
<font size=1> <A name=17>lecture #17</A> began here</font>
<p>

<h3>Mailbag</h3>

<dl>
<dt> Can I put a string label in my tree nodes, saying what nonterminal it is?
<dd> You could have a string, you could have an integer; you could have both
     for all I care. Actually, both is a pretty good idea. The string makes
     for human-readable tree output, while the integer is superior for writing
     tree traversals and doing different behavior depending on what kind of
     tree node you are dealing with.
<dt> I haven't been able to find a way to edit the yylex() that's generated.
<dd> You aren't supposed to do this manually, you are supposed to do it
     automatically with a computer program whenever you (re)make it. Per
     a previous class discussion, there are several UNIX tools that could
     do this, including the option of writing a C program or a flex program
     to do it.  But one of the simplest options may be something like the
     following in your makefile:
<pre>
lex.yy.c: g0lex.l
	flex g0lex.l
	sed -i 's/yylex/myyylex/g' lex.yy.c
</pre>

<dt> In the example <code>A : b C d {$$ = tree(R,3,$1,$2,$3);} ;</code>
Suppose C is a terminal and b and d are non-terminals. Then $2 will be
OK, but when will I be able to get the data that $1 and $3 need to
be set to?
<dd>Bison parsers are bottom up. You don't reduce this grammar rule
or execute this code until sometime after the handle <code>b C d</code>
has already been parsed, and in that process the production rules for
b and d have already executed, just as surely as the shift of C which
placed whatever yylval held at that time onto the value stack in $2.
If the rules for b and d had actions that said {$$=...} at that point
in the past, then $1 and $3 now will be holding what was assigned to $$
back in those rules' semantic actions.

<dt> In the example <code>A : b C d {$$ = tree(R,3,$1,$2,$3);} ;</code>
     to what doth R refer?
<dd> R was intended to be an integer code that allows you to tell, when
     walking through the tree later on, what production rule built that node.
     I would typically do a code for each nonterminal, gapped large enough
     that R can be (nonterminal+rule#forthatnonterminal).  Suppose this was
     the first of three production rules that build an A.  The integer might
     be (__A__ + 1) to denote the first A rule.

<dt> I'm considering having some sort of stack that keeps track of the parent
     you should currently be attaching children to.
<dd> You can do anything you want, but bison's value stack is that stack and
     and at each level you should allocate a node for $$ and attach all of its
     children. That is it.

<dt> Should we be defining our own integer codes for token types or just use
 the ones in g0gram.h?
<dd> You can't define your own codes, you have to use the codes that bison
 generates. You'll have to modify your lexer to use bison's integers, or your
 flex and bison will not work together.

<dt>Are yylval's types defined in the %union?
<dd>Yes, yylval is of type YYSTYPE, the type bison generates for the %union.
<dt> What is the actual value of a $n variable?
<dd> Before your bison grammar's semantic action code triggers, $1, $2, ... 
     etc. will be holding either (A) whatever you put in yylval if the
     corresponding symbol is a terminal, or (B) whatever you put in $$
     for its rule if the symbol is a non-terminal.
  
<dt>Do we have to implicitly concatenate <em>sub</em>strings?
<dd>Yes, substrings are strings.
<dt> Since we're not doing initializers, what is required of a for-statement?
<dd> You don't have to do a declaration of a variable in a for initializer.
      Saying <code>for(int i=1; ...)</code> was a C++ thing.
<dt> what's a declarator?
<dd> A portion of a variable declaration, not including the base type,
     which includes the variable's name and pointer/reference/array status.
     It may optionally include an initializer.  Here is a definition from
     <A href="https://msdn.microsoft.com/en-us/library/86zce4y8.aspx">MS</A>.
     I have totally tried in g0 to get to where declarators are just the
     identifier (no "decorations" on it), to simplify your trees a bit.
</dl>

Examples:

<pre>
int x;      // declarator is x
int x, y=5; // declarators are x and y=5 in a declarator list
char *s[3]; // declarator is *s[3]
</pre>



<A name=precedence>
<h4> YACC precedence and associativity declarations </h4>
</A>

YACC headers can specify precedence and associativity rules for otherwise
heavily ambiguous grammars.  Precedence is determined by increasing order
of these declarations.  Example:

<pre>
%right ASSIGN
%left PLUS MINUS
%left TIMES DIVIDE
%right POWER
%%
expr: expr ASSIGN expr
    | expr PLUS expr
    | expr MINUS expr
    | expr TIMES expr
    | expr DIVIDE expr
    | expr POWER expr
    | IDENT
    ;
</pre>

<A name=yyerror>
<h4> YACC error handling and recovery </h4>
</A>
<ul>
<li> Use special predefined token <code>error</code> where errors expected
<li> On an error, the parser pops states until it enters one that has an
     action on the error token.
<li> For example: statement: error ';' ;
<li> The parser must see 3 good tokens before it decides it has recovered.
<li> yyerrok tells parser to skip the 3 token recovery rule
<li> yyclearin throws away the current (error-causing?) token
<li> yyerror(s) is called when a syntax error occurs (s is the error message)
</ul>


<h3> Improving YACC's Error Reporting </h3>

yyerror(s) overrides the default error message, which usually just says either
"syntax error" or "parse error", or "stack overflow".
<p>

You can easily add information in your own yyerror() function, for example
GCC emits messages that look like:
<pre>
goof.c:1: parse error before '}' token
</pre>
using a yyerror function that looks like
<pre>
void yyerror(char *s)
{
   fprintf(stderr, "%s:%d: %s before '%s' token\n",
	   yyfilename, yylineno, s, yytext);
}
</pre>
<p>

You could instead, use the error recovery mechanism to produce better messages.
For example
<pre>
lbrace : LBRACE | { error_code=MISSING_LBRACE; } error ;
</pre>
Where LBRACE is an expected token {<br>
This uses a global variable error_code to pass parse information to yyerror().
<P>


<h3> Improving YACC's Error Reporting, cont'd </h3>
<p>
Another related option is to call yyerror() explicitly with a better message
string, and tell the parser to recover explicitly:
<pre>
package_declaration: PACKAGE_TK error
	{ yyerror("Missing name"); yyerrok; } ;
</pre>
<p>

But, using error recovery to perform better error reporting runs against
conventional wisdom that you should use error tokens very sparingly.
What information from the parser determined we had an error in the first
place?  Can we use that information to produce a better error message?

<p>
<font size=1> <A name=18>lecture #18</A> began here</font>
<p>

<h3> Mailbag </h3>

<dl>
<dt> I have spent 30 hours and am not close to finishing adding the
     hundreds of grammar rules and tree construction semantic actions
     required for HW#2!
<dd> As a power programmer, you should learn a powerful programmer's
     editor with a key-memorizing macro facility that can let you insert
     semantic actions (for example)
     very rapidly.  If you've been typing them in by hand, ouch!
     Paste the right thing 500 times and then just tweak.  Or paste all
     the constructors with the same number of children in batches, so
     you have less to tweak because you already pasted in the right number
     of kids.

<!--
<dt> Your reference parser reports a bogus error on this simple
     120++ program of mine that uses strings:
<pre>
int main(){
  string name;	
}
</pre>
<dd> Yes, this is an error. It is not bogus.  Interestingly,
g++ still reports a syntax error if you add #include &lt;string&gt;.
In order to recognize the non-built-in type string, the
C++ program has to have "using namespace std;" and include one of:
&lt;string&gt;, &lt;iostream&gt;, or &lt;fstream&gt;.  It turns out the
{io,f}stream  includes include &lt;string&gt;.  If these conditions are
present, you should insert "string" into a type names table, such that
your lexical analyzer returns CLASS_NAME when it sees <code>string</code>.

<dt> Your new reference parser reports a bogus error on this simple
      120++ program that declares a class:
<pre>
class Foo{
public:
   Foo();   
   int play();
};
Foo::play(){
  return 0;
}
</pre>
<dd> Aside from probably needing the reserved word "int" before
Foo::play, the reference code posted does not populate the
"type names table" with the names of classes that it encounters.
Part of HW#2 would include this feedback from the parser to the
lexical analyzer.
-->

<dt> Do I need to add <code>%type &lt;treeptr&gt; nonterm</code> for every
non-terminal symbol in the grammar in order to have everything work
<dd> yes
<!--
<dt> when we run into using namespace std; we place string into our
      type name table, but what about cin/cout/endl ?
<dd> In HW#2 we only need the names of types, because they are needed in
      order to parse successfully and not get syntax errors. In addition
      to string, the type names ifstream, ofstream, and fstream
      appear in 120++ and should get added if the include(s) and
      "using namespace std" appear in the program.
-->
<dt> Are we supporting (syntactically) nested classes/structs?
<dd> no
<!--
<dt> Do we have to parse anything with ::
<dd> classname::function name (including classname::constructor) appear to
     be the only uses of :: in 120++.
-->
<dt> What do I do with epsilon rules? Empty tree nodes?
<dd> I previously said to use either $$ = NULL or
     <code>$$ = alctree(RULE, 0)</code>.
     Whether the latter is preferable depends on what will make your
     tree traversals easier later on, in HW#3, and maybe whether the
     encoding of an empty leaf with RULE would help you in reading the
     tree and knowing what to do with it.  Saying $$=NULL
     implies you will have to check children to see if they are NULL
     before you try to visit them.  Never setting $$ to NULL means you
     can "blindly" traverse child pointers if a parent has nkids &gt; 0.

</dl>


<h3> LR Syntax Error Messages: Advanced Methods </h3>

The pieces of information that YACC/Bison use to determine that there
is an error in the first place are the parse state (yystate) and the
current input token (yychar). These are exactly the pieces of information
one might use to produce better diagnostic error messages without
relying on the error recovery mechanism and mucking up the grammar
with a lot of extra production rules that feature the <code>error</code> token.
<p>

Even just the parse state is enough to do pretty good error messages.
yystate is not part of YACC's public interface, though, so you may
have to play some tricks to pass it as a parameter into yyerror() from
yyparse().  Say, for example:
<pre>
#define yyerror(s) __yyerror(s,yystate)
</pre>

Inside __yyerror(msg, yystate) you can use a switch statement or a global
array to associate messages with specific parse states.  But, figuring
out which parse state means which syntax error message would be by trial
and error.
<p>

A tool called Merr is available that let's you generate this yyerror
function from examples: you supply the sample syntax errors and messages,
and Merr figures out which parse state integer goes with which message.
Merr also uses the yychar (current input token) to refine the diagnostics
in the event that two of your example errors occur on the same parse state.
See the <A href="http://unicon.sf.net/merr/">Merr</A> web page.

<h3> Grind Out Some G0 Grammar </h3>

This is an in-class, spontaneous exercise.

<img src="g0-cfg.jpg" width=1080>

<p>
<font size=1> <A name=19>lecture #19</A> began here</font>
<p>

<h3>Mailbag</h3>

<dl>
<dt>
All of the leaves in the tree structure are/can be made of the lex token. To
that point then, what are the non-leaves supposed to be? I think I may have
over thought this point so I am not quite sure.

<dd> Non-leaves (i.e. internal nodes) correspond to non-terminal symbols,
built from particular production rules.

<dt> For the structure of the tree, HW#2 provides a possible "setup".
<pre>
struct tree {
   int prodrule;
   int nkids;
   struct tree *kids[9];
   struct token *leaf;
}
</pre>

While I understand nkids (number of kids this node has), *kids[9] (a pointer
array to up to 9 kids), and leaf (the lex token), what exactly is the
prodrule?  I am fairly certain that this is the production rule, but I am
not exactly sure what it associates with.

<dd> The prodrule integer was intended to encode what production rule was used
to build this node, which includes (of course) what non-terminal it represents,
and what syntactic role its children played.  By the way, *kids[9] is
an array of 9 pointers to kids, not a pointer to an array of nine kids.


<dt>  When I add implicit concatenation, Bison doesn't know whether (x - y)
      is a subtraction, or a concatenation of (x) and (-y).  It gives me
      33 reduce/reduce conflicts!  What do I do?

<dd> Possible solutions include:
<ol>
<li> get rid of implicit concatenation (the "Sorry Dr J" approach)
<li> get rid of unary minus, let's use ~ (eeww!) for unary minus
<li> wiggle around the reduce-reduce conflict, perhaps using Bison's
     precedence and associativity, or just the default tie-breaker
<li> get fancier about lexical rules in which unary minus would apply.
     For example, we could say the spaces are not so optional for one or the
     other.
<li> restrict concatenation to only apply to a subset of expressions such
     as adjacent string literals, or those plus variable names
<li> ... several others in class have worked on it, what have you come up with?
</ol>



<!--
<dt> Will we be using any of the following features?
<dd>
By "using" you mean: supporting in your compiler.
Based on my current understanding of g0:

<dl>
<dt>C++-style constructors for native types (i.e. double d(1.0);)
<dd>Not required.
<dt>The sizeof operator
<dd>Not required.
<dt>Array new/delete
<dd>Not required. new/delete only of single class instances. The book
    mentions "new int" in passing, but it is not used in programs.
<dt>The ternary operator (?:)
<dd>Not required.
<dt>Function pointers
<dd>Not required.
<dt>Fixed-size array declarations (i.e. int i[10];)
<dd>Required. These are used in Chapter 6 of 120++.
<dt>Brace initializers (i.e. int i[] = {1, 2, 3};)
<dd>Not required.
</dl>
-->

<dt>
What exactly is in $1 or $2 or ... when I am at a reduction building a
tree node in $$ for some non-terminal?
<dd>
<ul>
<li> If the rule's first righthandside symbol is a terminal, what is in
$1 is whatever you assigned to yylval when that terminal was matched in yylex.
<li> If the rule's first righthandside symbol is a non-terminal, what
is in $1 is whatever you assigned to $$ when that non-terminal was reduced.
</ul>

<!--
<dt>
Even though open hashing is recommended, do you lose points for
implementing hash tables with closed hashing instead?
<dd>
Hashing is not required until homework #3.
Not unless the tester constructs a test that exceeds your limits...which he
might. If you use closed hashing, use a bigger bucket size since you won't
handle overflow gracefully. 10K for global symbol table, 1K for local symbol
tables is probably sufficient.  Actually, we could calculate a much smaller
lower bound for g0, how would we go about doing that?
-->

<dt>
I was wondering if it is ok to have a linked list of syntax trees, where the
syntax tree for the current source file be inserted into a linked list (of
syntax trees), then at the end of main(), after generating syntax trees for
each file in command line argument, walk through the linked list and print
out each syntax tree.

<dd>
What is expected is that for each file, you build the tree,
return to main(), print it out, and then move on to the next filename. But
building a linked list of trees and looping again over that to print things
out would be fine. The main thing between each file on the command line is to
clear out the type name table; each file is being compiled independently of
whatever came before them during that compilation process.

</dl>


<h3> Recursive Descent Parsing </h3>

Perhaps the simplest parsing method, for a large subset of context free
grammars, is called recursive descent.  It is simple because the algorithm
closely follows the production rules of nonterminal symbols.

<ul>
<li> Write 1 procedure per nonterminal rule
<li> Within each procedure, a) match terminals at appropriate positions,
     and b) call procedures for non-terminals.
<li> Pitfalls:
<ol><li> left recursion is FATAL
<li> must distinguish between several
     production rules, or potentially, one has to
     try all of them via <em>backtracking</em>.
</ol>
</ul>


<h4> Recursive Descent Parsing Example #1</h4>

Consider the grammar we gave above.  There will be functions for
E, T, and F.  The function for F() is the "easiest" in some sense: based
on a single token it can decide which production rule to use.  The
parsing functions return 0 (failed to parse) if the nonterminal in
question cannot be derived from the tokens at the current point.
A nonzero return value of N would indicate success in parsing using
production rule #N.

<pre>
int F()
{
   int t = yylex();
   if (t == IDENT) return 6;
   else if (t == LP) {
      if (E() && (yylex()==RP) return 5;
      }
   return 0;
}
</pre>

Comment #1: if F() is in the middle of a larger parse of E() or T(), F()
may succeed, but the subsequent parsing may fail. The parse may have
to <em>backtrack</em>, which would mean we'd have to be able to put
tokens back for later parsing.  Add a memory (say, a gigantic array or
link list for example) of already-parsed tokens
to the lexical analyzer, plus backtracking logic to E() or T() as needed.
The call to F() may get repeated following a different production rule
for a higher nonterminal.
<p>

Comment #2: in a real compiler we need more than "yes it parsed" or
"no it didn't": we need a parse tree if it succeeds, and we need a
useful error message if it didn't.
<p>

Question: for E() and T(), how do we know which production rule to try?
Option A: just blindly try each one in turn.
Option B: look at the first (current) token, only try those rules that
start with that token (1 character lookahead).  If you are lucky, that
one character will uniquely select a production rule. If that is always
true through the whole grammar, no backtracking is needed.
<p>


Question: how do we know which rules start with whatever token we are
looking at?  Can anyone suggest a solution, or are we stuck?
<p>

Below is an industrious start of an implementation of the
corresponding recursive descent parser for non-terminal <code>T</code>.
Now is student-author time, what is our next step?  What is wrong with
this picture?


<pre>
int T()
{
   if (T() && (yylex()==ASTERISK) && F()) return 3;
   ... more to be filled in, like rule 4...
}
</pre>


<h3> Removing Left Recursion </h3>


<pre>
E -> E + T | T
T -> T * F | F
F -> ( E ) | ident
</pre>

We can remove the left recursion by introducing new nonterminals
and new production rules.

<pre>
E  -> T E'
E' -> + T E' | &epsilon;
T  -> F T'
T' -> * F T' | &epsilon;
F  -> ( E ) | ident
</pre>

Getting rid of such <em>immediate left recursion</em> is not enough, one must
get rid of indirect left recursion, where two or more nonterminals are
mutually left-recursive.
One can rewrite <em>any</em> CFG to remove left recursion (Algorithm 4.19). 

<pre>
for i := 1 to n do
   for j := 1 to i-1 do begin
      replace each A<sub>i</sub> -&gt; A<sub>j</sub> &gamma; with productions
         A<sub>i</sub> -&gt; &delta;<sub>1</sub>&gamma; | &delta;<sub>2</sub>&gamma; | ... | &delta;<sub>k</sub>&gamma;, where
            A<sub>j</sub> -&gt; &delta;<sub>1</sub> | &delta;<sub>2</sub> | ... | &delta;<sub>k</sub> are all current A<sub>j</sub>-productions
      end
   eliminate immediate left recursion
</pre>


<h3> Where We Are </h3>

<ul>
<li> We started in on recursive descent parsing by observing that for some
grammar rules, we could just write the code easy peasy by  matching
the first token and then calling nonterminal functions.
<li> Then we hit a wall, because the other nonterminals were left recursive,
we had to solve the infinite recursion problem, which is detailed in your
dragon book.
<li> If we ever clear the left recursion hurdle, THEN we can worry about the
backtracking problem: if we try to parse rule 1, and get into it a ways, and
find that it doesn't work, we have to "undo" all our parsing (and possibly
lexing) back to the starting point in order to try subsequent grammar rules
for a given nonterminal.
</ul>


<h3> Removing Left Recursion, part 2 </h3>

Left recursion can be broken into three cases
<p>
<h4>case 1: trivial</h4>

<pre>
A : A &alpha; | &beta;
</pre>

The recursion must always terminate by A finally deriving &beta; so you
can rewrite it to the equivalent
<pre>
A : &beta; A'
A' : &alpha; A' | &epsilon;
</pre>

Example:
<pre>
E : E op T | T
</pre>
can be rewritten
<pre>
E : T E'
E' : op T E' | &epsilon;
</pre>

<h4>case 2: non-trivial, but immediate</h4>

In the more general case, there may be multiple recursive productions
and/or multiple non-recursive productions.
<pre>
A : A &alpha;<sub>1</sub> | A &alpha;<sub>2</sub> | ... | &beta;<sub>1</sub> | &beta;<sub>2</sub>
</pre>

As in the trivial case, you get rid of left-recursing A and introduce an A'

<pre>
A :  &beta;<sub>1</sub> A' | &beta;<sub>2</sub> A' | ...
A' : &alpha;<sub>1</sub> A' | &alpha;<sub>2</sub> A' | ... | &epsilon;
</pre>


<h4> case 3: mutual recursion </h4>

<ol>
<li> Order the nonterminals in some order 1 to N.
<li> Rewrite production rules to eliminate all
     nonterminals in leftmost positions that refer to a "previous" nonterminal.
     When finished, all productions' right hand symbols start with a terminal
     or a nonterminal that is numbered equal or higher than the nonterminal
     no the left hand side.
<li> Eliminate the direct left recusion as per cases 1-2.
</ol>


<h4> Left Recursion Versus Right Recursion: When does it Matter? </h4>

A student came to me once with what they described as an operator precedence
problem where 5-4+3 was computing the wrong value (-2 instead of 4).  What
it really was, was an associativity problem due to the grammar:
<pre>
E : T + E | T - E | T
</pre>

The problem here is that right recursion is forcing right associativity, but
normal arithmetic requires left associativity.  Several solutions are:
(a) rewrite the grammar to be left recursive, or (b) rewrite the grammar
with more nonterminals to force the correct precedence/associativity,
or (c) if using YACC or Bison, there are "cheat codes" we will discuss later
to allow it to be majorly ambiguous and specify associativity separately
(look for %left and %right in YACC manuals).


<h3> Recursive Descent Parsing Example #2</h3>

The grammar

<pre>
S -> A B C
A -> a A
A -> <em>&epsilon;</em>
B -> b
C -> c
</pre>

maps to pseudocode like the following. (:= is an assignment operator)

<pre>
procedure S()
  if A() & B() & C() then succeed # matched S, we win
end

procedure A()
  if yychar == a then { # use production 2
     yychar := scan()
     return A()
     }
  else
     succeed # production rule 3, match &epsilon;
end

procedure B()
   if yychar == b then {
      yychar := scan()
      succeed
      }
   else fail
end

procedure C()
   if yychar == c then {
      yychar := scan()
      succeed
      }
   else fail
end
</pre>

<h3> Backtracking? </h3>


Could your current token begin more than one of your possible production rules?
Try all of them, remember and reset state for each try.
<pre>
S -> cAd
A -> ab
A -> a
</pre>

<em>Left factoring</em> can often solve such problems:

<pre>
S -> cAd
A -> a A'
A'-> b
A'-> (&epsilon;)
</pre>

One can also perform left factoring <!--(Algorithm 4.2)--> to reduce or
eliminate the lookahead or backtracking needed to tell which production rule
to use.  If the end result has no lookahead or backtracking needed, the
resulting CFG can be solved by a "predictive parser" and coded easily in a
conventional language.  If backtracking is needed, a recursive descent
parser takes more work to implement, but is still feasible.

As a more concrete example:

<pre>
S -> <b>if</b> E <b>then</b> S
S -> <b>if</b> E <b>then</b> S<sub>1</sub> else S<sub>2</sub>
</pre>

can be factored to:

<pre>
S -> <b>if</b> E <b>then</b> S S'
S'-> else S<sub>2</sub> | &epsilon;
</pre>

<p>
<font size=1> <A name=20>lecture #20</A> began here</font><p>
<p>

<h3>Mailbag</h3>

<dl>
<dt> Can I have an extension?
<dd> Yeah, but the further you fall behind, the more zeroes you end up with
     for assignments that you don't do.
     Late homeworks are accepted with a penalty per day (includes
     weekend days) except in the case of a valid excused absence.
     The penalty starts at 10% per day (HW#1), and reduces by 2% per
     assignment (8%/day for HW#2, 6%/day for HW#3, 4%/day for HW#4,
     and 2%/day for HW#5).  I reserve the right to underpenalize.

<dt> This g0 thing is too undefined, I wish we were writing a compiler for C++
     like the good old days!
<dd> That's like saying you prefer "CSI" to "Star Trek".  You can only say
     g0 is too undefined if you have spent hours asking me questions, and
     I haven't given you answers. Besides there being too many "120++"
     compilers out there on github, previous semesters' CS 445 projects were
     way too large partly because C++ is way too large and complicated; even
     the subset we did was tained with Colonel Oakes' famous quote: "Drop down
     and give me infinity."

<dt> What about prototypes?
<dd> Contrary to an example, g0 does not have to support prototype syntax.
     Java does not do prototypes...
     The compiler should find the function declaration, wherever it is, in
     order to type check it.  What are the implications?

<!--
<dt>The storage types given in 120gram.y (auto, extern, static, register,
and mutable) are not used, but the spec also uses the phrasing "most storage
classifiers are not used in 120++".  Are there some other I should be aware
of?

<dd> The only new storage class specifier in C++14 was
thread_local, which is not in 120++, and C++14 does not
list auto as a storage class specifier, which I find interesting. auto is still a reserved word and seems to mean something
different in C++14 than it did in classic ANSI C.
-->
</dl>



<h3> Some More Parsing Theory </h3>

Automatic techniques for constructing parsers start with computing some
basic functions for symbols in the grammar.  These functions are useful
in understanding both recursive descent and bottom-up LR parsers.

<h3> First(&alpha;) </h3>

First(&alpha;) is the set of terminals that begin strings derived from &alpha;,
which can include &epsilon;.

<ol>
<li> First(X) starts with the empty set.
<li> if X is a terminal, First(X) is {X}.
<li> if X -> &epsilon; is a production, add &epsilon; to First(X).
<li> if X is a non-terminal and X -> Y<sub>1</sub> Y<sub>2</sub> ... Y<sub>k</sub> is a production,
     add First(Y<sub>1</sub>) to First(X).
<li><pre>for (i = 1; if Y<sub>i</sub> can derive &epsilon;; i++)
        add First(Y<sub>i+1</sub>) to First(X)
</pre>
</ol>


<h3> First(a) examples </h3>

by the way, this stuff is all in section 4.3 in your text.
<p>
Last time we looked at an example with E, T, and F, and + and *.
The first-set computation was not too exciting and we need more
examples.

<pre>
stmt : if-stmt | OTHER
if-stmt:  IF LP expr RP stmt else-part
else-part: ELSE stmt | &epsilon;
expr: IDENT | INTLIT
</pre>

What are the First() sets of each nonterminal?



<h3> Follow(A) </h3>

(The helper function that goes along with First(X)) <p>

Follow(A) for nonterminal A is the set of terminals that can appear
immediately to the right of A in some sentential form S -> aAxB...
To compute Follow, apply these rules to all nonterminals in the grammar:

<ol>
<li> Add $ to Follow(S)
<li> if A -> aB&beta; then add First(b) - &epsilon; to Follow(B)
<li> if A -> aB or A -> aB&beta; where &epsilon; is in First(&beta;), then add
     Follow(A) to Follow(B).
</ol>


<h3> Follow() Example </h3>

For the grammar:

<pre>
stmt : if-stmt | OTHER
if-stmt:  IF LP expr RP stmt else-part
else-part: ELSE stmt | &epsilon;
expr: IDENT | INTLIT
</pre>

It can get pretty muddy on the Follow() function, for even this simple grammar.
It helps if you follow the algorithm, instead of just "eyeballing it".

<pre>
For all non-terminals X in the grammar do
   1. if X is the start symbol, add $ to Follow(X)
   2. if N -&gt; &alpha;X&beta; then add First(&beta;) - &epsilon; to Follow(X)
   3. if N -&gt; &alpha;X or N -&gt; &alpha;X&beta; where &epsilon; is in
       First(&beta;) then add Follow(N) to Follow(X)
</pre>

Since the algorithm depends on First(), what are First sets again?
<pre>
First(stmt) = {IF, OTHER}
First(if-stmt) = {IF}
First(else-part) = {ELSE, &epsilon;}
First(expr) = {IDENT, INTLIT}
</pre>


Because each non-terminal has three steps, and our toy grammar has
4 non-terminals, there are 12 steps.
When you just apply these twelve steps, brute force, it is clear
that the statement of what to do to compute them was not an algorithm,
it was only a declarative specification, and there is an ordering needed
in order to compute the result.
<pre>
   1. stmt is the start symbol, add $ to Follow(stmt)
   2. if N -&gt; &alpha; stmt &beta; then add First(&beta;) - &epsilon; to Follow(stmt)
	---- add First(else-part)-&epsilon; to Follow(stmt)
   3. if N -&gt; &alpha; stmt or N -&gt; &alpha; stmt &beta; where &epsilon;
	 is in First(&beta;) then add Follow(N) to Follow(stmt)
	---- add Follow(else-part) to Follow(stmt)
   4. if-stmt is not the start symbol (noop)
   5. if N -&gt; &alpha;if-stmt&beta; then add First(&beta;) - &epsilon; to Follow(if-stmt)
	---- n/a
   6. if N -&gt; &alpha;if-stmt or N -&gt; &alpha;if-stmt&beta; where &epsilon; is in
       First(&beta;) then add Follow(N) to Follow(if-stmt)
	---- add Follow(stmt) to Follow(if-stmt)
   7. else-part is not the start symbol (noop)
   8. if N -&gt; &alpha;else-part&beta; then add First(&beta;) - &epsilon; to Follow(else-part)
	---- n/a
   9. if N -&gt; &alpha;else-part or N -&gt; &alpha;else-part&beta; where &epsilon; is in
       First(&beta;) then add Follow(N) to Follow(else-part)
	--- add Follow(if-stmt) to Follow(else-part)
   10. expr is not the start symbol (noop)
   11. if N -&gt; &alpha;expr&beta; then add First(&beta;) - &epsilon; to Follow(expr)
	---- add RP to Follow(expr)
   12. if N -&gt; &alpha;expr or N -&gt; &alpha;expr&beta; where &epsilon; is in
       First(&beta;) then add Follow(N) to Follow(expr)
	---- n/a
</pre>

What is the dependency graph? Does it have any cycles?  If it has cycles,
you will have to iterate to a fixed point.
<pre>
Follow(stmt) depends on Follow(else-part)
Follow(if-stmt) depends on Follow(stmt)
Follow(else-part) depends on Follow(if-stmt)
</pre>
If I read this right, there is a 3-way mutual recursion cycle.


<h3> Can we First/Follow Anything Else </h3>

Like preferably, a real-world grammar example?  Please remember that real
world grammars for languages like ANSI C are around 400+ production rules,
so in-class examples will by necessity be toys.  If I pick a random* (*LOL)
<A href="unigram.y">YACC grammar</A>, can we First/Follow any of its non-terminals?




<!--
There are test cases posted on the class website.  If you create additional
test cases, turn them in (say, in a subdirectory test/ in your tar file).
Extra credit will be awarded to the best suite of test cases.-->


<h3> LR vs. LL vs. LR(0) vs. LR(1) vs. LALR(1) </h3>

The first char ("L") means input tokens are read from the left
(left to right).  The second char ("R" or "L") means parsing
finds the rightmost, or leftmost, derivation.  Relevant
if there is ambiguity in the grammar.  (0) or (1) or (k) after
the main lettering indicates how many lookahead characters are
used.  (0) means you only look at the parse stack, (1) means you
use the current token in deciding what to do, shift or reduce.
(k) means you look at the next k tokens before deciding what
to do at the current position.



<h3> LR Parsers </h3>

LR denotes a class of bottom up parsers that is capable of handling virtually
all programming language constructs.  LR is efficient; it runs in linear time
with no backtracking needed.  The class of languages handled by LR is a proper
superset of the class of languages handled by top down "predictive parsers".
LR parsing detects an error as soon as it is possible to do so.  Generally
building an LR parser is too big and complicated a job to do by hand, we use
tools to generate LR parsers.
<p>

The LR parsing algorithm is given below.<!--See Figure 4.29 for a schematic.-->
<pre>
ip = first symbol of input
repeat {
   s = state on top of parse stack
   a = *ip
   case action[s,a] of {
      SHIFT s': { push(a); push(s') }
      REDUCE A->&beta;: {
         pop 2*|&beta;| symbols; s' = new state on top
         push A
         push goto(s', A)
         }
      ACCEPT: return 0 /* success */
      ERROR: { error("syntax error", s, a); halt }
      }
   }
</pre>



<!--
<h3> Little-known Mysteries of the BASIC Language </h3>

<ul>
<li> BASIC has arrays.  They default to a size of 11 elements.
     Other array sizes are specified via a DIM statement, as in:<br>
     10 DIM A(100)
<li> BASIC has three versions of every variable name (number, string, array)
<li> Variables in BASIC are preinitialized to 0.
<li> PRINT statements have multiple arguments (implicit concatenation?)
<li> PRINT statements can have commas or semicolons between their arguments
<li> Some of our tests have syntax errors; others use features (e.g. graphics)
     that are beyond our scope. Extra credit, but only if you catch up first.
<li> cocogram.y is not infallible, you are to fix it, and then brag about it
<li> Jimenez' COCO emulator is how I test what should and should not work.
</ul>
-->


<p>

<H3>Constructing SLR Parsing Tables: </H3>

<P>
<DFN>Definition: An LR(0) item of a grammar G is a production
of G with a dot at some position of the RHS.</DFN>
<P>
Example: The production A-&gt;aAb gives the items: 
<P>
A -&gt; . a A b<br>
A -&gt; a . A b<br>
A -&gt; a A . b<br>
A -&gt; a A b .
<P>
Note: A production A-&gt; &epsilon; generates
only one item:
<P>
A -&gt; .
<P>
Intuition: an item A-&gt; &alpha; . &beta; denotes:
<OL>
<LI>&alpha; - we have already seen a string
derivable from &alpha;
<LI>&beta; - we hope to see a string derivable
from &beta;
</OL>

<H3>Functions on Sets of Items </H3>

<P>
<DFN>Closure: if I is a set of items for a grammar G, then closure(I)
is the set of items constructed as follows:</DFN>
<OL>
<LI><DFN>Every item in I is in closure(I).</DFN>
<LI><DFN>If A-&gt;</DFN>&alpha; . <DFN>B</DFN>&beta;<DFN>
is in closure(I) and B-&gt;</DFN>&gamma;<DFN>
is a production, then add B-&gt; .</DFN>&gamma;<DFN>
to closure(I).</DFN> 
</OL>

<P>
These two rules are applied repeatedly until no new items can
be added.
<P>
Intuition: If A -&gt; &alpha; . B &beta; is in
closure(I) then we hope to see a string derivable from B in the
input. So if B-&gt; &gamma; is a production,
we should hope to see a string derivable from &gamma;.
Hence, B-&gt;.&gamma; is in closure(I).<BR>

<P>
Goto: if I is a set of items and X is a grammar symbol, then goto(I,X)
is defined to be:
<P>
goto(I,X) = closure({[A-&gt;&alpha;X.&beta;] | [A-&gt;&alpha;.X&beta;]
is in I})
<P>
Intuition: 
<UL>
<LI>[A-&gt;&alpha;.X&beta;]
is in I =&gt; we've seen a string derivable
from &alpha;; we hope to see a string derivable
from X&beta;.
<LI>Now suppose we see a string derivable from X
<LI>Then, we should &quot;goto&quot; a state where we've seen
a string derivable from &alpha;X, and where
we hope to see a string derivable from &beta;.
The item corresponding to this is [A-&gt;&alpha;X.&beta;] 
</UL>


<UL>
<LI>Example: Consider the grammar
</UL>

<PRE>
<FONT SIZE=3>	E -&gt; E+T | T
	T -&gt; T*F | F
	F -&gt; (E) | id 
</font></pre>

&nbsp;
&nbsp;
&nbsp;
&nbsp;
&nbsp;
&nbsp;
&nbsp;
Let I = {[E -&gt; E . + T]} then:
<pre><font size=3>        goto(I,+) = closure({[E -&gt; E+.T]})
		  = closure({[E -&gt; E+.T], [E -&gt; .T*F], [T -&gt; .F]})
		  = closure({[E -&gt; E+.T], [E -&gt; .T*F], [T -&gt; .F], [F-&gt; .(E)], [F -&gt; .id]})
		  = { [E -&gt; E + .T],[T -&gt; .T * F],[T -&gt; .F],[F -&gt; .(E)],[F -&gt; .id]}</FONT>
</PRE>

<H3>The Set of Sets of Items Construction</H3>

<OL>
<LI>Given a grammar G with start symbol S, construct the augmented
grammar by adding a special production S'-&gt;S where S' does
not appear in G.
<LI>Algorithm for constructing the canonical collection of
sets of LR(0) items for an augmented grammar G': 
</OL>

<P>
<FONT SIZE=3 FACE="Courier New"></FONT>
<PRE>
<TT>	begin
	   C := { closure({[S' -&gt; .S]}) };
</TT>	   <TT>repeat
	      for each set of items I in C:
		  for each grammar symbol X:
   		     if goto(I,X) != 0 and goto(I,X) is not in C then
		 	 add goto(I,X) to C;
	   until no new sets of items can be added to C;
	   return C;
	end<BR>
</TT>
</PRE>




<P>
<DFN>Valid Items: an item A -&gt; </DFN>&beta;<DFN><SUB>
1</SUB>. </DFN>&beta;<DFN> <SUB>2</SUB>
 is valid for a viable prefix </DFN>&alpha;<DFN>
</DFN>&beta;<DFN><SUB> 1  </SUB>if
there is a derivation:</DFN>
<PRE>
<FONT SIZE=3 FACE="Courier New">S' =&gt;<SUP>*</SUP><SUB>rm</SUB> </FONT>&alpha;<FONT SIZE=3 FACE="Courier New">A</FONT>&omega;<FONT SIZE=3 FACE="Courier New"> =&gt;<SUP>*</SUP><SUB>rm</SUB></FONT>&alpha; &beta;<SUB><FONT SIZE=3 FACE="Courier New">1</FONT></SUB>&beta;<SUB><FONT SIZE=3 FACE="Courier New"> 2</FONT></SUB>&omega;
</PRE>

<P>
Suppose A -&gt; &beta;<SUB>1</SUB>.&beta; <sub>2</sub> is valid for &alpha;&beta;<SUB>1</SUB>,
and &alpha;B<SUB>1</SUB> is on the parsing
stack
<OL>
<LI>if &beta;<SUB>2</SUB> != &epsilon;,
we should shift
<LI>if &beta;<SUB>2</SUB> = &epsilon;,
A -&gt; &beta;<SUB>1</SUB> is the handle,
and we should reduce by this production 
</OL>

<P>
Note: two valid items may tell us to do different things for the
same viable prefix. Some of these conflicts can be resolved using
lookahead on the input string. 

<H3>Constructing an SLR Parsing Table</H3>

<OL>
<LI>Given a grammar G, construct the augmented grammar by adding
the production S' -&gt; S.
<LI>Construct C = {I<SUB>0</SUB>, I<SUB>1</SUB>, &#133; I<SUB>n</SUB>},
the set of sets of LR(0) items for G'.
<LI>State I is constructed from I<SUB>i</SUB>, with parsing action
determined as follows:
<UL>
<LI>[A -&gt; &alpha;.aB] is in
I<SUB>i</SUB>, where a is a terminal; goto(I<SUB>i</SUB>,a) = I<SUB>j</SUB>
: set action[i,a] = &quot;shift j&quot;
<LI>[A -&gt; &alpha;.] is in
I<SUB>i</SUB> : set action[i,a] to &quot;reduce A -&gt; x&quot;
for all a &isin; FOLLOW(A), where A != S'
<LI>[S' -&gt; S .] is in I<SUB>i</SUB> :
set action[i,$] to &quot;accept&quot; 
</UL>

<LI>goto transitions constructed as follows: for all non-terminals:
if goto(I<SUB>i</SUB>, A) = I<SUB>j</SUB>, then goto[i,A] = j
<LI>All entries not defined by (3) &amp; (4) are made &quot;error&quot;.
If there are any multiply defined entries, grammar is not SLR.
<LI>Initial state S<SUB>0</SUB> of parser: that constructed from
I<SUB>0</SUB> or [S' -&gt; S] 
</OL>


<H3>Constructing an SLR Parsing Table: Example</H3>

<PRE>
<FONT SIZE=3>	S -&gt; aABe		FIRST(S) = {a}		FOLLOW(S) = {$}
	A -&gt; Abc		FIRST{A} = {b}		FOLLOW(A) = {b,d}
	A -&gt; b			FIRST{B} = {d}		FOLLOW{B} = {e}
	B -&gt; d			FIRST{S'}= {a}		FOLLOW{S'}= {$}
</FONT>I<SUB>0</SUB><FONT FACE="Courier New"> = closure([S'-&gt;.S]
   = closure([S'-&gt;.S],[S-&gt;.aABe])
goto(I<SUB>0</SUB>,S) = closure([S'-&gt;S.]) = I<SUB>1
</SUB>goto(I<SUB>0</SUB>,a) = closure([S-&gt;a.ABe])
	    = closure([S-&gt;a.ABe],[A-&gt;.Abc],[A-&gt;.b]) = I<SUB>2
</SUB>goto(I<SUB>2</SUB>,A) = closure([S-&gt;aA.Be],[A-&gt;A.bc])
	    = closure([S-&gt;aA.Be],[A-&gt;A.bc],[B-&gt;.d]) = I<SUB>3
</SUB>goto(I<SUB>2</SUB>,b) = closure([A-&gt;b.]) = I<SUB>4
</SUB>goto(I<SUB>3</SUB>,B) = closure([S-&gt;aAB.e]) = I<SUB>5
</SUB>goto(I<SUB>3</SUB>,b) = closure([A-&gt;Ab.c]) = I<SUB>6
</SUB>goto(I<SUB>3</SUB>,d) = closure([B-&gt;d.]) = I<SUB>7
</SUB>goto(I<SUB>5</SUB>,e) = closure([S-&gt;aABe.]) = I<SUB>8
</SUB>goto(I<SUB>6</SUB>,c) = closure([A-&gt;Abc.]) = I<SUB>9</SUB></FONT>
</PRE>


<h3> Fun with Parsing </h3>

Let's play a "new fun game"* and see what we can do with the following subset
of the C grammar:

<table>
<tr><th> C grammar subset <th> First sets
<tr><td>
<pre>
ats : INT | TYPEDEF_NAME | s_u_spec ;
s_u_spec : s_u LC struct_decl_lst RC |
	s_u IDENT LC struct_decl_lst RC |
	s_u IDENT ;
s_u : STRUCT | UNION ;
struct_decl_lst : s_d | struct_decl_lst s_d ;
s_d : s_q_l SM |
	s_q_l struct_declarator_lst SM ;
s_q_l : ats | ats s_q_l ;
struct_declarator_lst:
	declarator |
	struct_declarator_list CM declarator ;
declarator: IDENT |
	declarator LB INTCONST RB ;
</pre>
<td>
<pre>
First(ats) = { INT, TYPEDEF_NAME, STRUCT, UNION }
First(s_u_spec) = { STRUCT, UNION }
First(s_u) = { STRUCT, UNION }
First(struct_decl_lst) = { INT, TYPEDEF_NAME, STRUCT, UNION }
First(s_d) = { INT, TYPEDEF_NAME, STRUCT, UNION }
First(s_q_l) = { INT, TYPEDEF_NAME, STRUCT, UNION}
First(struct_declarator_lst) = { IDENT }
First(declarator) = { IDENT }
</pre>
</table>

<pre>
Follow(ats) = { $, INT, TYPEDEF_NAME, STRUCT, UNION, IDENT, SM }
Follow(s_u_spec) = { $, INT, TYPEDEF_NAME, STRUCT, UNION, IDENT, SM }
Follow(s_u) = { LC, IDENT }
Follow(struct_decl_lst) = { RC, INT, TYPEDEF_NAME, STRUCT, UNION }
Follow(s_d) = { RC, INT, TYPEDEF_NAME, STRUCT, UNION }
Follow(s_q_l) = { IDENT, SM }
Follow(struct_declarator_lst) = { CM, SM }
Follow(declarator) = { LB , CM, SM }
</pre>

Now, Canonical Sets of Items for this Grammar:

<pre>
I<sub>0</sub> = closure([S' -&gt; . ats]) =
	 closure({[S' -&gt; . ats], [ ats -&gt; . INT ],
	 	  [ ats -&gt; . TYPEDEF_NAME ], [ ats -&gt; . s_u_spec ],
		  [ s_u_spec -&gt; . s_u LC struct_decl_lst RC],
		  [ s_u_spec -&gt; . s_u IDENT LC struct_decl_lst RC],
		  [ s_u_spec -&gt; . s_u IDENT ],
		  [ s_u -&gt; . STRUCT ],
		  [ s_u -&gt; . UNION ]
		  })

goto(I<sub>0</sub>, ats) = closure({[S' -&gt; ats .]}) = {[S' -&gt; ats .]} = I<sub>1</sub>

goto(I<sub>0</sub>, INT) = closure({[ats -&gt; INT .]}) = {[ats -&gt; INT .]} = I<sub>2</sub>
goto(I<sub>0</sub>, TYPEDEF) = closure({[ats -&gt; TYPEDEF_NAME .]}) = {[ats -&gt; TYPEDEF_NAME .]} = I<sub>3</sub>
goto(I<sub>0</sub>, s_u_spec) = closure({[ats -&gt; s_u_spec .]}) = {[ats -&gt; s_u_spec .]} = I<sub>4</sub>

goto(I<sub>0</sub>, s_u) = closure({
		  [ s_u_spec -&gt; s_u . LC struct_decl_lst RC],
		  [ s_u_spec -&gt; s_u . IDENT LC struct_decl_lst RC],
		  [ s_u_spec -&gt; s_u . IDENT ]}) = I<sub>5</sub>

goto(I<sub>0</sub>, STRUCT) = closure({[ s_u -&gt; STRUCT .]}) = I<sub>6</sub>
goto(I<sub>0</sub>, UNION) = closure({[ s_u -&gt; UNION .]}) = I<sub>7</sub>

goto(I<sub>5</sub>, LC) = closure({[ s_u_spec -&gt; s_u LC . struct_decl_lst RC],
[ struct_decl_lst -&gt; . s_d ],
[ struct_decl_lst -&gt; . struct_decl_lst s_d ],
[ s_d -&gt; . s_q_l SM],
[ s_d -&gt; . s_q_l struct_declarator_lst SM],
[ s_q_l -&gt; . ats ],
[ s_q_l -&gt; . ats s_q_l ],
[ ats -&gt; . INT ],
[ ats -&gt; . TYPEDEF_NAME ],
[ ats -&gt; . s_u_spec ],
})
</pre>

<font size=1>* Arnold Schwartzenegger. Do you know the movie? </font>


<h3> On Trees </h3>

Trees are classic data structures.
<ul>
<li> Trees have nodes and edges; they are
a special case of graphs.
<li> Tree edges are directional, with roles "parent"
and "child" attributed to the source and destination of the edge.
<li> A tree has the property that every node has zero or one parent.
<li> A node with no parents is called a root.
<li> A node with no children is called a leaf.
<li> A node that is neither a root nor a leaf is an "internal node".
<li> Trees have a size (total # of nodes), a height (maximum count
     of nodes from root to a leaf),
     and an "arity" (maximum number of children in any one node).
</ul>
<p>

Parse trees are k-ary, where there is a
variable number of children bounded by a value k determined by the grammar.
You may wish to consult your old data structures book, or look at some books
from the library, to learn more about trees if you are not totally
comfortable with them.

<p>
<pre>
#include &lt;stdarg.h&gt;

struct tree {
   short label;			/* what production rule this came from */
   short nkids;			/* how many children it really has */
   struct tree *child[1];	/* array of children, size varies 0..k */
				/* Such an array has to be the LAST
				   field of a struct, and "there can
				   be only ONE" for this to work. */
};

struct tree *alctree(int label, int nkids, ...)
{
   int i;
   va_list ap;
   struct tree *ptr = malloc(sizeof(struct tree) +
                             (nkids-1)*sizeof(struct tree *));
   if (ptr == NULL) {fprintf(stderr, "alctree out of memory\n"); exit(1); }
   ptr-&gt;label = label;
   ptr-&gt;nkids = nkids;
   va_start(ap, nkids);
   for(i=0; i &lt; nkids; i++)
      ptr-&gt;child[i] = va_arg(ap, struct tree *);
   va_end(ap);
   return ptr;
}
</pre>
<P>



<!--
<h3> Changes to Sigala's ISO 96 C++ Grammar Made for 120++ in 120gram.y </h3>

The actual draft ISO 96 C++ grammar was modified a fair bit for use
in this class, to produce a subset C++ grammar that was Bison-friendly.
For what its worth, here is a summary of those changes.  You are at least
nominally charged with looking at what grammar additions would be needed
to handle (as much as possible of) C++14, although such additions would
be met with "C++14 feature XXX is not part of 120++" error messages.

<ul>
<li> changes were motivated by a need to eliminate reduce/reduce
     conflicts.
<li> removing adjacent optional items was generally mandatory
<li> removing optional items at beginning and ending of a rule
       was usually required
<li> optional items in the middle of a rule were often OK
</ul>

Specific changes include:

<dl>
<dt> removed namespace_alias from namespace_name
<dd> ambiguity of these identifier-like rules not needed since we aren't
     doing namespaces properly in 120++.
<dt> removed :: prefixed primary expressions
<dd> overriding current namespace not necessary since we aren't doing
     namespaces properly in 120++.
<dt> removed template_id from unqualified_id
<dd> we aren't doing templates in 120++
<dt> refactored TEMPLATE_opt into two productions in qualified_id
<dt> refactored class_or_namespace_name and nested_name_specifier_opt in
      nested_name_specifier
<dd> class_or_namespace_name basically gave two ways to use an identifier;
      difference is semantic
<dt> removed a rule starting with simple_type_specifier in postfix_expression
<dt> factored out adjacent optionals in postfix_expression
<dt> remove pseudo_destructor names
<dt> pulled '*' and '&' out of unary_operator to avoid reduce/reduce conflicts
<dd> but allow them explicitly in unary_expression
<dt> factored out COLONCOLON_opt in new_expression and delete_expression
<dt> removed possibility of empty simple_declaration (empty ; is not a
     declaration) and init_declarator_list with no decl_specifier_seq
     in front of it
<dt> refactored adjacent optionals in
     simple_declaration,
     simple_type_specifier, elaborated_type_specifier
      qualified_namespace_specifier, using_declaration, direct_declarator,
      direct_abstract_declarator, parameter_declaration_clause,
      member_declaration, base_specifier
<dt> removed optionality of ENUM_opt in enum_specifier
<dd> not that 120++ has to do enum's
<dt> removed optionals at beginning and end of ptr_operator
<dt> refactored optional at end of cv_qualifier_seq
<dt> refactored optional begin of declarator_id
<dt> refactored optional beginning and internal element of function_definition
<dt> refactored class_head to avoid adjacent optionals, removed
      possibility of class head with no identifier
<dt> refactored optionals at end of member_declarator
<dt> removed optionality of identifiers in type_parameter
</dl>
-->

<h3> Having Trouble Debugging? </h3>

To save yourself on the semester project in this class, you should
learn gdb (or some other source level debugger) as well as you can.
Sometimes it can help you find your bug in seconds where you would have
spent hours without it.  But only if you take the time to read the manual
and learn the debugger.

<p>

To work on segmentation faults: recompile all .c files with -g and run your
program inside gdb to the point of the segmentation fault.  Type the gdb
"where" command.  Print the values of variables on the line mentioned in the
debugger as the point of failure.  If it is inside a C library function, use
the "up" command until you are back in your own code, and then print the
values of all variables mentioned on that line.

<p>

After gdb, the second tool I recommend strongly is valgrind.  valgrind
catches some kinds of errors that gdb misses.  It is a non-interactive
tool that runs your program and reports issues as they occur, with a big
report at the end.
<p>

<!--
There is another tool you should know about, although it is a little long in
the tooth at this point. It is useful for certain kinds of bugs, primarily
subtle memory violations.  It is called electric fence.  To use electric
fence you add

<pre>
	/home/.../libefence.a
</pre>

to the line in your makefile that links your object files together to
form an executable.  Assuming you can find or build a copy of libefence.a
somewhere.
-->


<h3> Reading Tree Leaves </h3>

In order to work with your tree, you must be able to tell, preferably
trivially easily, which nodes are tree leaves and which are internal nodes,
and for the leaves, how to access the lexical attributes.
<p>
Options:
<ol>
<li> encode in the parent what the types of children are
<li> encode in each child what its own type is (better)
</ol>
How do you do option #2 here?
<p>
There are actually nonterminal symbols with 0 children (nonterminal with
a righthand side with 0 symbols) so you don't necessarily want to use
an nkids of 0 is your flag to say that you are a leaf.

Perhaps the best approach to all this is to unify the tokens and parse tree
nodes with something like the following, where perhaps an nkids value of -1
is treated as a flag that tells the reader to use
lexical information instead of pointers to children:

<pre>
struct node {
int code;		/* terminal or nonterminal symbol */
int nkids;
union {
   struct token { ...  } leaf; // or: struct token *leaf;
   struct node *kids[9];
   }u;
} ;
</pre>




<h3> Tree Traversals </h3>

Besides a function to allocate trees, you need to write one or more recursive
functions to visit each node in the tree, either top to bottom (preorder),
or bottom to top (postorder).  You might do many different traversals on the
tree in order to write a whole compiler: check types, generate machine-
independent intermediate code, analyze the code to make it shorter, etc.
You can write 4 or more different traversal functions, or you can write
1 traversal function that does different work at each node, determined by
passing in a function pointer, to be called for each node.

<pre>
void postorder(struct tree *t, void (*f)(struct tree *))
{
   /* postorder means visit each child, then do work at the parent */
   int i;
   if (t == NULL) return;

   /* visit each child */
   for (i=0; i &lt; t-&gt; nkids; i++)
      postorder(t->child[i], f);

   /* do work at parent */
   f(t);
}
</pre>

You would then be free to write as many little helper functions as you
want, for different tree traversals, for example:
<pre>
void printer(struct tree *t)
{
   if (t == NULL) return;
   printf("%p: %d, %d children\n", t, t->label, t->nkids);
}
</pre>


<!--
<h3> Compiling <A href="cgram.y">cgram.y</A> </h3>

It was ripped out of an anesthetized patient...for transplanting,
the buck ultimately stops with you.  Cgram.y was already legal Bison,
but to compile the resulting cgram.tab.c, cgram.y needed a %union
definition.  In order to link or work properly, it will still need
you to write helper functions and coordinate its token definitions
with your lexical analyzer / flex output.  The -d flag causes Bison
to write out a compatible header file to define tokens for flex.
-->

<h3> Parse Tree Example </h3>

Let's do this by way of demonstrating what yydebug=1 does for you, on a
very simple example such as:

<pre>
int fac(unsigned n)
{
   return !n ? 1 : n*fac(n-1);
}
</pre>

Short summary: yydebug generates 1100 lines of tracing output
that explains the parse in Complete Detail.  From which we ought
to be able to build our parse tree example.


<h3> Observations on Debugging the ANSI C++ Grammar to be more YACC-able </h3>

<dl>
<dt>Expectation
<dd> not that you pick it up by magic and debug it all yourself,
     but rather that you spend enough time monkeying with yacc grammars
     to be familiar with the tools and approach, and to ask the right questions.
<dt> Tools
<dd> YYDEBUG/yydebug, --verbose/--debug/y.output
<dt> Approach
<dd>
<ul>
<li> Run with yydebug=1 to study current behavior
<li> Do the minimum number of edits necessary to fix*
<li> reduce obvious epsilon vs. epsilon
<li>  Examine y.output to understand remaining reduce/reduce conflicts.
<li>  Delete the causes if they are not in 120++
<li> Refactor the causes if they are in 120++
</dl>
<p>

*why?  why not?
<p>

<!--
<h3> Bison debugging example </h3>

<ul>
<li> turned on yydebug=1
<li> trace shows reduce to ctor_initializer_opt before '{', looks good
<li> shift of '{' OK
<li> shift of INT leads to reduce of simple_type_specifier, seems OK
<li> should reduce to type_specifier, decl_specifier, decl_specifier_seq,
      decl_specifier_seq_opt: should be OK
<li> init_declarator_list_opt should go to init_declarator_list,
      init_declarator, declarator, direct_declarator, declarator_id,
      id_expresssion, unqualified_id, identifier, IDENTIFIER
<li> _opt grammar rules introduce epsilons, they were for the convenience
     of the ISO C++ committee, but we know epsilons are evil
<li> removed _opt grammar rules; adjacent ones, at least, were trouble
<li> removing adjacent ones helped, but removing others did not
<li> built with --verbose and --debug, looked at y.output
<li> before removing _opt's, reduce/reduce conflicts were very
     distributed 2,1,5,6,5,3,4,4,6,6,2,6,6,6,6,2,6,6,6,6,6
<li> after removing _opt's, reduce/reduce conflicts were more concentrated:
     45, 13, 9, 9, 9, 9 and a couple strays
<li> about half of reduce/reduce were due to "pseudo-destructors". delete
<li> 13 due to template_id's not knowing whether they are class_name or unqualified_id's. could delete trivially for 120++ (no templates)
<li> four batches of 9 reduce/reduce: type_name could be simple_type_specifier or declarator_id, COLONCOLON type_name not knowing if it is a simple_type_specifier or declarator_id, nested_name_specifier type_name not knowing if it is a simple_type_specifier or a declarator_id, and COLONCOLON nested_name_specifier type_name not knowing if it is a simple_type_specifier or a declarator_id
<li> a couple oddballs: class_key identifier not knowing if it is an elaborated_type_specifier or a class_head, with and without a nested_name_specifier after the class_key
<li> ^-- these latter two bullets identify grammar rules we will either
      delete (if not in 120++) or refactor
</ul>
-->
<p>


<h3> On the mysterious TYPE_NAME </h3>

<em>This may have been covered earlier, it is here for review.
Soule's 120++ text introduces struct's and typedef in passing (interlude 3).
For Fall 2017 you do not
have to handle typedef but DO have to handle class names similarly.</em>
<p>

The C/C++ typedef construct is an example where all the beautiful
theory we've used up to this point breaks down.  Once a typedef is
introduced (which can first be recognized at the syntax level), certain
identifiers should be legal type names instead of identifiers.  To make
things worse, they are still legal variable names: the lexical analyzer
has to know whether the syntactic context needs a type name or an
identifier at each point in which it runs into one of these names. This
sort of feedback from syntax or semantic analysis back into lexical
analysis is not un-doable but it requires extensions added by hand to
the machine generated lexical and syntax analyzer code.
<p>
<pre>
typedef int foo;
foo x;                    /* a normal use of typedef... */
foo foo;                  /* try this on gcc! is it a legal global? */
void main() { foo foo; }  /* what about this ? */
</pre>
<p>

<font size=1> <A name=21>lecture #21</A> began here</font>

<h3> Mailbag </h3>

<dl>
<dt>
What exactly gives the
shape of the tree? I know that it is formed from the rules defined in bison,
but I am having trouble visualizing it.
<dd>
At each node of the tree, the shape (a.k.a. "fan-out", or # of children)
is defined by the # of symbols on the
righthand side of the production rule used to construct that node.

<!--
<dt>
For homework #2, how should we handle user includes?  Should we open the
user include file(s) and generate/output the parse tree for everything in
that file?

<dd>
If HW#1 did the right thing, which was for includes to be handled seamlessly
with a continued sequence of yylex() tokens, HW#2 will generally not have to
do anything special or extra for the included file(s).  HW#2 does
need to clear out its type table and system-includes flags, reset the lexical
analyzer, and call a new yyparse() for each file named on its command line.
-->

<dt> I totally have an example where a shift-reduce conflict was a Real
     Problem even though you said we could ignore shift-reduce conflicts!

<dd> Ouch! When you showed me this in my office, you found that you could
     fix it by simply changing a right recursion to a left recursion!
     Very cool, we finally know why Bison warns of this kind of ambiguity
     in the grammar: sometimes it is really a problem.  I have taken the
     liberty of reducing your example to just about its simplest form:

<pre>
%%
Program:	DeclarationList ProgramBody ;
ProgramBody: 	Function SEMICOLON ProgramBody	| ;
Function:	Declaration OPEN_PAREN CLOSE_PAREN ;
DeclarationList:Declaration SEMICOLON DeclarationList | ;
Declaration:		    INT IDENTIFIER ;
</pre>

The corresponding input that dies on this is:
<pre>
int x;
int main();
</pre>

<dt> How about a tool that would generate numbers
automatically from our grammar .y files?  It should perhaps use negative
numbers (to avoid overlap/conflicts with Bison-generated numbers for
terminal symbols).
<dd> We looked again to see if Bison had an option to generate that, but I
am not aware of one.  Awhile back
I wrote a <A href="nonterms.icn">cheap hack version 0</A>
of such a tool...feel free to adapt it or rewrite something similar.
</dl>

<A name="semantic">
<h3> Semantic Analysis </h3>
</A>

Semantic ("meaning") analysis refers to a phase of compilation in which the
input program is studied in order to determine what operations are to be
carried out.  The two primary components of a classic semantic analysis
phase are variable reference analysis and type checking.  These components
both rely on an underlying symbol table.
<p>

What we <em>have</em> at the start of semantic analysis is a syntax tree that
corresponds to the source program as parsed using the context free grammar.
Semantic information is added by annotating grammar symbols with
<em>semantic attributes</em>, which are defined by <em>semantic rules</em>.
A semantic rule is a specification of how to calculate a semantic attribute
that is to be added to the parse tree.
<p>
So the input is a syntax tree...and the output is the same tree, only
"fatter" in the sense that nodes carry more information. 
Another output of semantic analysis are error messages detecting many
types of semantic errors.
<p>

Two typical examples of semantic analysis include:
<dl>
<dt> variable reference analysis
<dd> the compiler must determine, for each use of a variable, which
     variable declaration corresponds to that use.  This depends on
     the semantics of the source language being translated.
<dt> type checking
<dd> the compiler must determine, for each operation in the source code,
     the types of the operands and resulting value, if any.
</dl>
<p>

Notations used in semantic analysis:<br>
<dl>
<dt> <strong><u>syntax-directed definitions</u></strong> </dt>
<dd> high-level (<em>declarative</em>) specifications of semantic rules </dd>
<dt> <strong><u>translation schemes</u></strong> </dt>
<dd> semantic rules and the order in which they get evaluated </dd>
</dl>
<p>

In practice, attributes get <em>stored</em> in parse tree nodes, and the
semantic rules are evaluated either (a) during parsing (for easy rules) or
(b) during one or more (sub)tree traversals.
<p>


<h3> Two Types of Attributes:</h3>
<dl>
<dt> synthesized
<dd> attributes computed from information contained within one's children.
     These are generally easy to compute, even on-the-fly during parsing.
<dt> inherited
<dd> attributes computed from information obtained from one's parent or siblings
     These are generally harder to compute.  Compilers may be able to jump
     through hoops to compute some inherited attributes during parsing,
     but depending on the semantic rules this may not be possible in general.
     Compilers resort to tree traversals to move semantic information around
     the tree to where it will be used.
</dl>


<h3> Attribute Examples </h3>

<h4> Isconst and Value </h4>

Not all expressions have constant values; the ones that do may allow
various optimizations.

<table border>
<tr>
<th> CFG	<th> Semantic Rule
</tr>
<tr>
<td>
E<sub>1</sub> : E<sub>2</sub> + T
<td>
E<sub>1</sub>.isconst = E<sub>2</sub>.isconst && T.isconst<br>
if (E<sub>1</sub>.isconst)<br>
&nbsp;&nbsp;&nbsp; E<sub>1</sub>.value = E<sub>2</sub>.value + T.value<br>
</tr>
<tr>
<td>
E : T
<td>
E.isconst = T.isconst<br>
if (E.isconst)<br>
&nbsp;&nbsp;&nbsp; E.value = T.value<br>
</tr>
<tr>
<td>
T : T * F
<td>
T<sub>1</sub>.isconst = T<sub>2</sub>.isconst && F.isconst<br>
if (T<sub>1</sub>.isconst)<br>
&nbsp;&nbsp;&nbsp; T<sub>1</sub>.value = T<sub>2</sub>.value * F.value<br>
</tr>
<tr>
<td>
T : F
<td>
T.isconst = F.isconst<br>
if (T.isconst)<br>
&nbsp;&nbsp;&nbsp; T.value = F.value<br>
</tr>
<tr>
<td>
F : ( E )
<td>
F.isconst = E.isconst<br>
if (F.isconst)<br>
&nbsp;&nbsp;&nbsp; F.value = E.value<br>
</tr>
<tr>
<td>
F : ident
<td>
F.isconst = FALSE<br>
</tr>
<tr>
<td>
F : intlit
<td>
F.isconst = TRUE<br>
F.value = intlit.ival<br>
<td>
</tr>
</table>

<h3> HW Code Sharing Policy Reminder </h3>

<ul>
<li>You can share ideas but are not to share code with your classmates.
<li>If you used an external source, be sure to cite it and make clear
the scope/extent of code that is not your own.
<li>If anything is shared in this class (e.g. yacc grammars, or donuts) it must
be shared with the whole class.  Otherwise, it ruins the level playing field
and makes grading impossible...
<li>On anything else that gives me excessive deja vu in this class,
     I will give zeros, or refer you to the
     appropriate university committee.
</ul>



<h3> Symbol Table Module </h3>

Symbol tables are used to resolve names within name spaces. Symbol
tables are generally organized hierarchically according to the
scope rules of the language.  Although initially concerned with simply
storing the names of various that are visible in each scope, symbol
tables take on additional roles in the remaining phases of the compiler.
In semantic analysis, they store type information.  And for code generation,
they store memory addresses and sizes of variables.
<p>

<dl>
<dt> mktable(parent)
<dd> creates a new symbol table, whose scope is local to (or inside) parent
<dt> enter(table, symbolname, type, offset)
<dd> insert a symbol into a table
<dt> lookup(table, symbolname)
<dd> lookup a symbol in a table; returns structure pointer including type and offset.  lookup operations are often <em>chained</em> together progressively from most local scope on out to global scope.
<dt> addwidth(table)
<dd> sums the widths of all entries in the table.
<ul>
<li> "widths" = #bytes.
<li> The sum of widths is the #bytes needed for the entire memory region
   reserved for this scope.
<li> Examples: activation record (for a function call),
     global data section, or class/struct instance.
</ul>
   Worry not about this method until code generation you wish to implement.
<dt>enterproc(table, name, newtable)
<dd> enters the local scope of the named procedure
</dl>


Note: finish discussing addwidth() and enterproc(). <p>

<font size=1> <A name=22>lecture #22</A> began here</font>

<h3><A href="hw3.html"></A></h3>


<h3> Variable Reference Analysis </h3>

The simplest use of a symbol table would check:

<ul>
<li> for each variable, has it been declared?  (undeclared error)
<li> for each declaration, is it already declared? (redeclared error)
</ul>


<p>


<H3> Semantic Analysis in Concrete Terms </h3>

Broadly, we can envision the semantic analysis as two passes:

<dl>
<dt> Pass 1: Symbol Table Population
<dd> Symbol table population is a syntax tree traversal in which
we look for nodes that introduce symbols, including the creation
and population of local scopes and their associated symbol tables.
As you walk the tree, we look for specific nodes that indicate
symbols are introduced, or new local scopes are introduced. What
are the tree nodes that matter (from <A href="cgram.y">cgram.y</A>)
in this particular example?
<ol>
<li> create a global symbol table (initialization)
<li> each function_declarator introduces a symbol.
<li> each init_declarator introduces a symbol.
<li> oh by the way, we have to obtain the types for these.
<li> "types" for functions include parameter types and return type
<li> "types" for init_declarators come from declaration_specifiers,
     which are "uncles" of init_declarators
</ol>

<dt> Pass 2: Type Checking
<dd> Type checking occurs during a bottom up traversal of the expressions
within all the statements in the program.
</dl>


<h3> Discussion of <A href="semantic.c">a Semantic Analysis Example</A></h3>

<ul>
<li> several example tree traversals that do different tasks
     during semantic analysis.
<li> this was "ripped out" of a past project
<li> goal: give you ideas
<li> not meant to force you to use this code, or do things this way
</ul>

<p>


<p>
<font size=1> <A name=23>lecture #23</A> began here</font>
<p>



<h3> Type Checking </h3>

Perhaps the primary component of semantic analysis in many traditional
compilers consists of the type checker.  In order to check types, one first
must have a representation of those types (a type system) and then one must
implement comparison and composition operators on those types using the
semantic rules of the source language being compiled.  Lastly, type checking
will involve adding (mostly-) synthesized attributes through those parts of
the language grammar that involve expressions and values.

<h4> Type Systems </h4>

Types are defined recursively according to rules defined by the source
language being compiled. A type system might start with rules like:

<ul>
<li> Base types (int, char, etc.) are types
<li> Named types (via typedef, etc.) are types
<li> Types composed using other types are types, for example:
    <ul>
    <li> array(T, indices) is a type. In some
         languages indices always start with 0, so array(T, size) works.
    <li> T1 x T2 is a type (specifying, more or
         less, the tuple or sequence T1 followed by T2;
	 x is a so-called cross-product operator).
    <li> record((f1 x T1) x (f2 x T2) x ... x (fn x Tn)) is a type
    <li> in languages with pointers, pointer(T) is a type
    <li> (T<sub>1</sub> x ... T<sub>n</sub>) -> T<sub>n+1</sub> is a
         type denoting a function mapping parameter types to a return type
    </ul>
<li> In some language type expressions may contain variables whose values
     are types.
</ul>

In addition, a type system includes rules for assigning these types
to the various parts of the program; usually this will be performed
using attributes assigned to grammar symbols.




<h3> Representing Types </h3>

In statically-typecheck'ed languages,
the target language's type system must be represented using data
structures in the compiler's implementation language.
In the symbol table and in the parse tree attributes used in type checking,
there is a need to represent and compare source language types.  You might
start by trying to assign a numeric code to each type, kind of like the
integers used to denote each terminal symbol and each production rule of the
grammar.  But what about arrays?  What about structs?  There are an infinite
number of types; any attempt to enumerate them will fail.  Instead, you
should create a new data type to explicitly represent type information.
This might look something like the following:
<p>

<pre>struct type {
   /*
    * Integer code that says what kind of type this is.
    * Includes all primitive types: 1 = int, 2=float,
    * Also includes codes for compound types that then also
    * hold type information in a supporting union...
    * 7 = array, 8 = struct, 9 = pointer etc. */
   int base_type;
   union {
      struct array {
         int size; /* allow for missing size, e.g. -1 */
	 struct type *elemtype; /* pointer to type for elements in array,
	 				follow it to find its base type, etc.*/
      } a;
      struct struc {		/* structs */
         char *label;
	 int nfields;
         struct field **f;
	 } s;
      struct type *p;		/* pointer type, points at another type */
   } u;
}

struct field {			/* members (fields) of structs */
   char *name;
   struct type *elemtype;
}

</pre>

Given this representation, how would you initialize a variable to
represent each of the following types:

<pre>
int [10][20]
struct foo { int x; char *s; }
</pre>

<p>



<h3> Lessons From the Godiva Project </h3>

By way of comparison, it may be useful for you to look at
some symbol tables and type representation code that were written for
the Godiva programming language project.  Being a dialect of Java, Godiva
has compile-time type checking and might provide relevant ideas for OOP
languages.

<ul>
<li> <A href="type.h">type.h</A>
<li> <A href="type.c">type.c</A>
<li> <A href="symtab.h">symtab.h</A>
<li> <A href="symtab.c">symtab.c</A>
</ul>

<p>
<em> Ask about packages and "import" declarations
here, if the source language this semester supports them.</em>
<p>
<!--
<h3> Discussion of "Import", and more Generally, Packages </h3>

Suggested approaches for implementing semantic analysis of packages/imports:

<dl>
<dt> "import" == concatenate, or include
<dd>
<Ul>
<li> Pros: moderately easy to implement
<li> import x.y.z means class z out of package x.y
<li> Cons: code duplication, reparsing stuff a lot
</ul>
<dt> "import" == symbol table insert/merge
<dd>
<ul>
<li> Pro: don't have cons of the include approach
<li> Con: either have to reparse whole files in order to suck in types
     for symbols we import OR have to write out symbol tables as external
     files/repositories of info about compiled packages/classes
</ul>
</dl>
-->


<pre>
/*
 * Build Type From Prototype (syntax tree) Example
 */
void btfp(nodeptr n)
{
   if (n==NULL) return;
   for(int i = 0; i < n->nkids; i++) btfp(n->child[i]);
   switch (n->prodrule) {
   case INT:
      n->type = get_type(INTEGER);
      break;
   case CHAR:
      n->type = get_type(CHARACTER);
      break;
   case IDENTIFIER:
      n->type = get_type(DONT_KNOW_YET);
      break;
   case '*':
      n->type = get_type(POINTER);
      break;
   case PARAMDECL_1:
      n->type = n->child[0]->type;
      break;
   case THINGY:
      n->type = n->child[0]->type;
      break;
   case PARAMDECL_2:
      n->type = clone_type(n->child[1]->type);
      n->type->u.p.elemtype = n->child[0]->type;
      break;
   case PARAMDECLLIST_2:
      n->type = get_type(TUPLE);
      n->type->u.t.nelems = 1;
      n->type->u.t.elems = calloc(1, sizeof(struct typeinfo *));
      n->type->u.t.elems[0] = n->child[0]->type;
      break;
   case PARAMDECLLIST_1:
      n->type = get_type(TUPLE)

      /* consider whether left child, guaranteed to be a PARAMDECLLIST,
         is guaranteed to be a tuple.  Maybe its not. */
      n->type->u.t.nelems = n->child[0]->type->u.t.nelems + 1;
      n->type->u.t.elems = calloc(n->type->u.t.nelems,
				      sizeof(struct typeinfo *));
      for(i=0;i < n->child[0]->type->u.t.nelems; i++)
         n->type->u.t.elems[i] = n->child[0]->type->u.t.elems[i];
      n->type->u.t.elems[i] = n->child[1]->type;

      break;
   case INITIALIZER_DECL:
      n->type = get_type(FUNC)
      n->type->u.f.returntype = get_type(DONT_KNOW);
      n->type->u.f.params = n->child[1].type;
      break;
   case SIMPLE_DECLARATION_1:
      n->type = clone_type(n->child[1]->type);
      n->type->u.f.returntype = n->child[0]->type;
   }
}
</pre>


<h3>Discussion of Tree Traversals that perform Semantic Tests</h3>

This example illustrates just one of the
myriad-of-specialty-traversal-functions that might be used.
This mindset is one way
to implement semantic analysis. <p>

Suppose we have a grammar rule
<pre>
AssignStmt : Var EQU Expr
</pre>

We want to detect if a variable has not been initialized, before it is
used.  We can add a boolean field to the symbol table entry, and set it
if we see, during a tree traversal, an initialization of that variable.
What are the limitations or flaws in this approach?

<p>
We can write traversals of the whole tree after all parsing
is completed, but for some semantic rules, another option is to
extend the C semantic action for that rule with
extra code after building our parse tree node:
<pre>
AssignExpr : LorExpr '=' AssignExpr { $$ = alctree(..., $1, $2, $3);
	lvalue($1);
	rvalue($3);
	}
</pre>

<ul>
<li> In this example, <code>lvalue()</code> and <code>rvalue()</code>
are mini-tree traversals for the lefthand side
and righthand side of an assignment statement.
<li> Their missions are to
propagate information from the parent, namely, inherited attributes
that tell nodes whether their values are being assigned to (initialized)
or being read from.
<li> Warning: since this is happening during parsing,
it would only work if all semantic information that it depends on,
for example symbol tables, was also done during parsing.

<li> Side note: I might be equally or more interested in implementing a
semantic check to make sure the left-hand-side of an assignment is actually
an assignable variable. How would I check for that?
</ul>

<pre>
void lvalue(struct tree *t)
{
   if (t-&gt;label == IDENT) {
      struct symtabentry *ste = lookup(t->u.token.name);
      ste->lvalue = 1;
   }
   for (i=0; i&lt;t-&gt;nkids; i++) {
      lvalue(t->child[i]);
      }
}
void rvalue(struct tree *t)
{
   if (t-&gt;label == IDENT) {
      struct symtabentry *ste = lookup(t-&gt;u.token.name);
      if (ste-&gt;lvalue == 0) warn("possible use before assignment");
   }
   for (i=0; i&lt;t-&gt;nkids; i++) {
      rvalue(t-&gt;child[i]);
      }
}
</pre>

<h4> What is different about real life as opposed to this toy example</h4>

This example illustrated walking through subtrees looking for specific
nodes where some information was inserted into the tree.  In real life...
<ul>
<li> information passed down (i.e. inherited attributes) may be passed
     as a (second or subsequent)
     parameter after the tree node the traversal is visiting.
<li> this example might apply mainly to local variables whose definition
     and use are in this same (function definition) subtree
<li> if you wanted to ensure a class or global variable was initialized before
     use, you might build a flow graph (often used in an optimization or
     final code generation phase anyhow)
<li> variable definition and use attributes are more reliably analyzed
     using a flow graph instead of the syntax tree.
</ul>

For example, if the program starts by calling
a subroutine at the bottom of code which initializes all the
variables, the flow graph will not be fooled into generating warnings
like you would if you just started at the top of the code and checked
whether for each variable, assignments appear earlier in the source
code than the uses of that variable.

<p>
<font size=1> <A name=24>lecture #24</A> began here</font>
<p>
<h3> Discussion of the State of HW#2 </h3>

<ul>
<li> Batch #1 graded, posted to bblearn, details available in my office.
<li> Batch #2 maybe by tomorrow
<li> Grades ranged from around 4/20 (compiles but doesn't work) to 20/20
     (passed all tests).
<li> Deja vu check: did you <em>cite</em> everything you used?
     You don't have to cite code from lecture notes and/or obtained
     from my webpages. Cite everything else.
<li> LOTS of folks will be fixing and resubmitting.
<li> (Revised) late policy for future homeworks: 10%/day was for HW#1.
     8%/day for HW#2.  6%/day for HW#3. 4%/day for HW#4.
     2%/day for HW#5.  I may waive or reduce late fees for resubmits that
     just fix minor bugs affecting tests
<li> Most common problems with HW#2:
<ul>
<li> missing prototypes and type problems that cause warnings
<li> reduce/reduce conflicts
<li> not deleting enough C++ or Java cruft from the grammar
</ul>
<li> Best practices in HW#2:
<ul>
<li> semi-colon insertion directly in the lexer's "build token" helper function
<li> syntax trees, not parse trees
<li> not saying {$$=$1} because it is the default
<li> not putting punctuation in your tree if unlikely to be needed later
</ul>
<li> g0 Reference lexer and scanner: you can expect it in another day or two;
     if your HW#2 is not close, it may help you, but I don't plan to give you
     a full compiler front-end with trees and all. To pass: own your trees,
     symbol tables, etc.
<li> HW#2 tests. Let's play language lawyer and ask how many things were
legal in here, and what (if any) shouldn't be:
<ul>
<li> <A href="g0tests/test0.g0">test0.g0</A>
<li> <A href="g0tests/test1.g0">test1.g0</A>
<li> <A href="g0tests/test2.g0">test2.g0</A>
<li> <A href="g0tests/for.g0">for.g0</A>
<li> <A href="g0tests/class.g0">class.g0</A>
<li> <A href="g0tests/g0stuff.g0">g0stuff.g0</A> (amended/corrected)
</ul>

<h3> Mailbag</h3>

<dl>
<dt> I got a much lower grade than I expected on HW#2!
<dd> If you didn't receive points for some graded category (say, syntax trees)
     in homework 2, and you did the work, Please see me about it.  If all that
     was wrong was: you need semi-colons everywhere, and all my tests didn't
     include them, let me know. I will construct some versions of the tests
     with semi-colons and add appropriate partial credit.

<dt> What about symbol table lookups related to classes in HW#3, Dr. J?  The
     homework doesn't talk about them much.
<dd> You should catch redeclared variables in all scopes. You should catch
     undeclared variables in all scopes.
<dt> Are we supposed to create a separate symbol table for each function?
     Or just a symbol table for functions in general?
<dd> You are supposed to create one global symbol table, one local symbol
     table for each function, and one local symbol table for each class type.
<dt> I am still struggling on figuring out how to detect undeclared variables.
<dd> We should talk about this in detail looking at the non-terminals used in
     your grammar. With any big vague software task,
     it is wise to break it up into smaller, well-defined pieces.  Before you
     try to find all undeclared variables, you could:
<ol>
<li> write a tree traversal that just lists
     all the <em>uses</em> of a variable (in expressions, where values are
     read or written), showing the variable name and line number.  These are
     the things that must be checked.
     <br> Still too big a job?  Break it into even smaller pieces:
     <ul>
     <li> write a tree traversal that just lists the names of functions for
          which you have a function body, and therefore a compound statement
          that contains executable expressions.
     <li> are there anything besides function bodies where you would have to
          check for undeclared variables?
     </ul>
<li> write a tree traversal that inserts all the variable declarations.
     print out the whole symbol table when finished, to show what you've got.
<li> modify the tree traversal #1 to lookup within the symbol table(s) and
     print semantic errors if any lookup fails.
</ul>


</dl>


<h3> Example Semantic Rules for Type Checking </h3>

<ul>
<li> We have previous seen: representation of types using C structs.
<li> We could maybe use an additional example of constructing such type
     structures from a syntax tree, but we saw a basic one, for parameters.
<li> Now it is time to consider: using such type structures to perform
     type checking.
<li> Type Checking is a primary example
     of using synthesized semantic attributes.
<li> Q before we start: what-all has to be checked?
</ul>

<table border>
<tr>
<th> grammar rule <th> semantic rule
<tr>
<td>E<sub>1</sub> : E<sub>2</sub> PLUS E<sub>3</sub>
<td>E<sub>1</sub>.type = check_types(PLUS, E<sub>2</sub>.type, E<sub>3</sub>.type)
<tr>
</table>

Where check_types() returns a (struct type *) value.  One of the values
it can return is TypeError.  The operator (PLUS) is passed in to
the check types function because behavior may depend on the operator --
the result type for array subscripting works different than the result
type for the arithmetic operators, which may work different (in some
languages) than the result type for logical operators that return booleans.

<h3> In-class brainstorming: what other type-check rules can we derive? </h3>

Consider the class project. What else will we need to check during semantic
analysis, and specifically during type checking?

<p>
<font size=1> <A name=25>lecture #25</A> began here</font>
<p>

<h3> Mailbag </h3>

<dl>
<dt> What up with those bugs in g0stuff.g0?
<dd> Upon scrutinizing, the test g0stuff.g0 has some things that might very well be
     a syntax error on lines 85-86: <code>pet.p()</code> and <code>pet.happy</code>
     are bogus.  <code>p.play()</code> and <code>p.happy</code> are fair game, but
     g0 has no static members and you can't generally say
     <code><em>classname.member</em></code> in g0.
<dt> At class.g0:6 and g0stuff.g0:60, the method pet() does not include a return type.
     Is this legal? I was under the assumption that functions must have a return type.
<dd> functions have to have a return type (unlike legacy C default behavior) but the
     class constructor is an exception.
<dt> How should I focus my midterm studying? There is a lot of material
     in this class and I would like to try to optimize my study time.
     Should I focus on the lecture notes? Should I be studying the book?
<dd> Perhaps the best way to study for the exams in this course is to do
     your homework assignments.  I try to write exam questions that you
     should know if you have done your assignments.  Having said that,
     if I were picking and choosing between the lecture notes or the book
     I would hit the lecture notes the hardest, referring to the book
     when more (or different) explanations are needed.
</dl>



<h3>Type Promotion and Type Equivalence</h3>

When is it legal to perform an assignment x = y?  When x and y are
identical types, sure.  Many languages such as C have automatic
promotion rules for scalar types such as shorts and longs.
The results of type checking may include not just a type attribute,
they may include a type conversion, which is best represented by
inserting a new node in the tree to denote the promoted value.
Example:
<pre>
int x;
long y;
y = y + x;
</pre>
<p>

For records/structures, some languages use name equivalence, while
others use structure equivalence.  Features like typedef complicate
matters.  If you have a new type name MY_INT that is defined to be
an int, is it compatible to pass as a parameter to a function that
expects regular int's?  Object-oriented languages also get interesting
during type checking, since subclasses usually are allowed anyplace
their superclass would be allowed.





<h3> Implementing Structs (a C thing) </h3>

You are implementing classes, not structs. How much of this is similar,
and how much needs to be different?

<ol>
<li> storing and retrieving structs by their label -- the struct label is
    how structs are identified.  You do not have to do typedefs and such.
    The labels can be keys in a separate hash table, similar to the global
    symbol table.  You can put them in the global symbol table so long as
    you can tell the difference between them and variable names.

<li> You have to store fieldnames and their types, from where the struct is
    declared.  You could use a hash table for each struct, but a link list
    is OK as an alternative.

<li> You have to use the struct information to check the validity of each
    dot operator like in rec.foo.  To do this you'll have to lookup rec
    in the symbol table, where you store rec's type.  rec's type must be
    a struct type for the dot to be legal, and that struct type should
    include a hash table or link list that gives the names and types of
    the fields -- where you can lookup the name foo to find its type.
</ol>



<h3> Type Checking Example </h3>

Work through a type checking example for the function call to foo() in:

<pre>
int foo(int x, string y) {
   return x
   }

int main()
{
   int z
   z = foo(5, "funf")
   return 0
}
</pre>

<p>
After parsing, the symbol table (left) and syntax tree for the call (right)
looks like:
<p>

<img src="typechk_args.png">
<p>

The typecheck of this tree proceeds as a post-fix traversal of the tree.
Type information starts from leaves, which either know their type if they
have one (constants) or look up their type in the symbol table (identifiers).
Can you hand-simulate this in the correct order, filling in .type fields for
each tree node?


<h3> Need Help with Type Checking? </h3>

<ul>
<li> Implement the C Type Representation given previously
<li> Read the Book
<li> What OPERATIONS (functions) do you need, in order to check
     whether types are correct?  What parameters will they take?
</ul>

<p>
<font size=1> <A name=26>lecture #26</A> began here</font>
<p>

<h3> Update on HW#2 </h3>

<dl>
<dt> Batch 3 (re)grading is now finished. A few of you have or will still
     resubmit a HW#2 and they will get processed as time allows.
<dd> We are pretty much done with HW#2, but for HW#3+, avoid mistakes
     learned from HW#2
<dt> Did you Test your Work on cs-course42?
<dd> Lots of folks doing work on lots of OSes, but if it doesn't run well
     on the test machine, you won't get many points.
<dt> Warnings are seldom OK
<dd> You were told shift/reduce warnings are OK (although they are not
     always). Get rid of other warnings so that when warning of a real
     issue shows up, you don't ignore it like "the boy who cried Wolf!".
<dt> Most folks turned in good .zip files, only 1-2 folks submitted
     archive files that unpacked in a subdirectory, or included
     spurious stuff like a .git/ subdirectory with wonky file permissions.
<dd> Thank you. There is a reason your instructions are to just include
     your project
     source code in a .zip archive that unpacks in the current directory.
<dt> Several folks turned in code that didn't "make" for me (missing files etc)
<dd> Test your work by unzipping in a new temp directory and seeing if "make"
     works there.
<dt> Folks DID NOT leave yydebug/YYDEBUG turned on in submitted code
<dd> Thanks. Also, do not leave your own debugging printf's in submitted code.
     Some folks tree prints were so chatty it bordered in hindering readability
<dt> Using <code>{ $$ = $4; }</code> is probably a bad idea
<dd> Q: Why?  Q: under what circumstances is this fine?
<dt> Using <code>{ $$ = $1; }</code> goes without saying
<dd> It is the default...
<dt> passing an fopen() or a malloc() as a parameter into a function is
     probably a bad idea
<dd> usually, this is a resource leak. It gives you no way to close/free.
<dt> Some of you are still not commenting to a minimum professional level
     needed for you to understand your own code in 6 months
</dl>

<h3> g0 Language: what-all is under-specified? </h3>

We've had various reasonable requests for clarification, and corrections
needed for examples which were translated incompletely from C++. Are there
any for which you haven't got a straight answer yet?

<dl>
<dt> no need for prototypes
<dd> prototypes are a concession to single-pass
     compilers run on slow low-memory computers in the 1970's and 80's.
     Your g0 compiler is allowed to use a "big-inhale" model of compilation
     in which all source code is available and symbol tables can be fully
     populated before type checking.
<dt> switch to JSON syntax for list constructors
<dd> Yeah, I admit I like square bracket list constructors.
</dl>

<h3> Type Checking Function Calls </h3>

<ul>
<li> at every node in our tree, we build a .type field
<li> Probably logically two separate jobs:
<ul>
<li> Build types for declarations, insert them into symbol table(s).
      Performed during the declarations pass of semantic analysis.
<li> Build types for expressions, lookup symbols from symbol table(s)
      Performed during the typecheck pass of semantic analysis.
</ul>

<li> For the typecheck pass, a recursive function, typecheck(n), traverses the
     tree sticking types into expression nodes.
<li> you may choose to write a helper function check_types(OPERATOR,
operandtype, operandtype) to do the heavy lifting at each node
<li> What will type checking a function call need?
<li> Can we just check the type of the symbol against the type of the call
expression?
<li> Type of symbol: constructed as per last lecture. In symbol table.
<li> Type of call expression (built within expression part of grammar), SANS
     return type.
<li> Type check verifies it and replaces it with return type.
</ul>

<pre>
void typecheck(nodeptr n)
{
   if (n==NULL) return;
   for(int i; i &lt; n-&gt;nkids; i++) typecheck(n->child[i]);
   switch(n->prodrule) {
   ...
   case POSTFIX_EXPRESSION_3: {
      n->type = check_types(FUNCALL, n->child[0]->type, n->child[2]->type);
      }
   }
}

...

typeptr check_types(int operand, typeptr x, typeptr y)
{
   switch (operand) {
   case  FUNCALL: {
      if (x->basetype != FUNC)
         return type_error("function expected", x);
      if (y->basetype != TUPLE)
         return type_error("tuple expected", y);
      if (x->u.f.nparams != y->u.t.nelems)
         return type_error("wrong number of parameters", y);

      /*
       * for-loop, compare types of arguments
       */
      for(int i = 0; i < x->u.f.nparams; i++)
         if (check_types(PARAM, x->u.f.params[i], y->u.t.elems[i]) ==
	     TYPE_ERROR) return TYPE_ERROR;
      /*
       * If the call is OK, our type is the function return type.
       */
      return x->u.f.returntype;
      break;
      }
   }
}
</pre>


<h3> Building Type Information </h3>

<ul>
<li> So far, the main discussion and pseudo-code for populating
     the symbol table that has been presented was for constructing
     tuple types for parameter lists, as needed for the type-check
     example that we then worked on.
<li> More generally, how do we construct type representations
     from syntax trees for other kinds of declarations?
<li> If we had time, we could stand to do a more concrete example of
     populating the symbol table
</ul>

<p>

<!--<img src="c_type_rep.png" width=1200>-->
<p>
<font size=1> <A name=27>lecture #27</A> began here</font>
<p>

<h3> Populating the Symbol Table and Type Checking Example </h3>

What the heck, let's consider what it would take to do this for
one of the HW#2 tests: <A href="g0tests/class.g0">class.g0</A>.

<p>
<font size=1> <A name=28>lecture #28</A> began here</font>
<p>

<h3> Mailbag </h3>

<dl>
<dt>
What is the difference between a function declaration and a variable
declaration, when it comes to adding the symbols to the table?  as far as
the tree is concerned they are almost exactly the same, with the exception
of which parent node you had.  Is there (or should there be) a line in the
symbol entry which states the entry as a function vs a variable?

<dd>
You add the symbols to the same table. For HW#3 they are thus treated
basically identically. For HW#4 you put in different type information for
functions (whose basetype says they are a function, and whose typeinfo
includes their parameters and return type) than for simple variables.

<dt>

I have code written which (hopefully) creates the symbol table entry for
variables.  This code uses a function which spins down through non-terminals
to get the identifier. Can I use this same function to get the identifier for
a function? A function is
<pre>direct_function_declarator: direct_declarator LP ... RP ...</pre>
so after the direct_declarator it has other useful things that I'm not sure
need to be in the symbol table entry.

<dd>

You can re-use functions that work through similar subtrees, either as-is
(if the subtrees really use the same parts of the grammar) or by generalizing
or making generic the key decisions about what to do based on production rule.
For example, you might add a flag parameter to a function that spins through
nonterminals, indicating whether this was in a function
declaration or not; that might allow you to tweak the tree traversal to adjust
for minor differences.

<dt>

You state "You do not have to support nested local scopes".  Does this mean
there will only be a global scope, or will there be a global + function
scopes, but no secondary scopes inside the local functions?

<dd> Correct, function scopes for locals and parameters, but not nested
local scopes inside those.

<dt>
you have the type checking done at the same time as the symbol table entry.  Is there any reason not to break these out into 2 separate functions?
<dd> No, no reason at all. In the old days there were reasons.

<dt> What is wrong with this hash?
<pre>
for(i=0;i&lt;strlen(s);i++) {
   sum+=s[i];
   sum%=ARRAYSIZE;
   }
</pre>
<dd> How many potential problems can <em>you</em> find in this code?

<dt>

In the enter_newscope() function in your sample code, what is
<pre>t = (typ==CLASS_TYPE) ?
      alcclasstype(s, new):alcmethodtype(NULL,NULL,new);
</pre>
It is code to deal with methods and classes, but what is
different about member functions ("methods") than ordinary functions?

<dd> Both regular functions and class member functions introduce a new
scope, the difference is that class member functions' enclosing scope is
the class, and within that class, they can find and use other members
(variables and functions) of the class, including private members.
In order to do this, they use an extra parameter (named "this" or "self"),
which will affect us mainly in code generation.
</dl>

Wow, what a great segue into our next section:

<h3> Semantic Analysis and Classes </h3>

What work is performed during the semantic analysis phase, to support classes?

<ul>
<li> Build class-level symbol tables
<li> Within class member functions, three-level symbol lookup
     (local first, then class, then global).
<li> In the implementation of <code>x.y</code> (and <code>x->y</code>
     in languages that have it),
     lookup <code>y</code> within <code>x</code>'s type's symbol table,
     using privacy rules.
<li> ...what are the other issues for semantic analysis of objects in
     our language, as you understand it?
</ul>



<h3> How to TypeCheck Square Brackets </h3>

This is about the grammar production whose right-hand side is:
<pre>
postfix_expression LB expression RB
</pre>

<ol>
<li> recursively typecheck $1 and $3 ... compute/synthesize their .type fields.
<li> What type(s) does $1 have to be?  LIST/ARRAY (or TABLE, if a table type exists)
<li> What type(s) does $3 have to be?  INTEGER (or e.g. STRING/ARRAY OF CHAR, for tables)
<li> What is the result type we assign to $$?  Lookup the element type from $1
</ol>

Pseudo-code fragment.  Goal is to find errors and determine n's type.
<pre>
int typecheck_array(struct tree *n)
{
   struct tree *n1 = n->child[0];
   struct tree *n3 = n->child[2];
   /*
    * recursively typecheck children.
    */
   if (typecheck(n1) == TYPE_ERROR ||
       typecheck(n3) == TYPE_ERROR) {
      n->type = TYPE_ERROR;
      return TYPE_ERROR;
      }
   /*
    * Given the children's types, see whether n1[n3] is legal
    */
   switch (n1->type->basetype) {
   case LIST:
      /* ... insert list typecheck code here */
      break;
   case TABLE:
      /* ... insert table typecheck code here */
      break;
   default:
      bad_type("list or table expected in [] operation", n1);
      return TYPE_ERROR;
      }
}
</pre>

<p>
<font size=1> <A name=29>lecture #29</A> began here</font>
<p>

<H3> Mailbag </h3>

<dl>

<dt> Am I understanding correctly that for Homework 3 we don't need any type
information? We could theoretically get full credit without storing type
details in our symbol tables?
<dd> Yes.

<dt> Is it normal to feel like my code for adding to and checking the
symbol tables is messy, gross, and more hard-coded than I'd like?
<dd>HW#1 and HW#2 were using a declarative language. HW#3 will be
messy and gross by comparison, because from here on out we are using
the imperative paradigm. Walking trees and getting the details all in
there will require a lot of code. How gross it is, "zis is all up to you"
(from a Geronimo Stilton book).

<dt> Does our language really require comma-separated lists of variables in
     declarations?  It would be <em>so</em> much easier if it only did one
     variable per declaration.
<dd> Don't exaggerate.  It would not be that much easier.  We want to be
able to handle declarations like
<pre>
int x, y
</pre>
So maybe we should talk about how hard is that.
<ul>
<li> Find a variable declaration (whatever you call it). Let's call its
     lefthand (the type) a "declaration specifier" and its
     righthand subtree a "declarator list"
<li> An declarator_list that consisted of just an IDENTIFIER leaf might
     be easier, I admit, but...
<li> a declarator_list that is
     just a linked list of identifiers isn't that much harder.
<li> Write a helper function that does nothing but walk through
     a chain of declarator_list nodes.
<li> When HW#4 comes along, pass type information obtained from synthesizing
     the declaration_specifier into the traversal of the declarator list.
     Options include:
     <ol><li> pass it as a parameter into the helper function, or
     <li> add it as (another) field in the tree structure, and copy
     it downwards
     in the tree from the declartion into the declarator list nodes.</ol>
</ul>
It is FINE to start by just getting it working for one-variable
declarations, then detect and handle two-variable declarations
as a special case, then generalize to 3+ variables.

<!--
<dt> I am not sure what to do with
    <code>endl</code>, <code>cout</code>, and <code>cin</code>.
     I've checked that
    <code>namespace std</code> appears and that <code>iostream</code>
    is included, but I'm not sure what
    type to give them.  Should I mark them as methods... or perhaps class
    names?
<dd> There are different answers for: "what these really are in C++" and for
     "what our subset 120++ would find adequate".
     As you may recall, you are always allowed to do things more C++-ish
     than the toy behavior I will recommend.
<dt> OK so what about <code>endl</code>?
<dd> Really: <code>endl</code> is an "IO manipulator" that
     inserts a newline and flushes the stream.
     What 120++ could live with: insert into your global symbol table the
      equivalent of having seen:
<pre>
const char endl = '\n';
</pre>
<dt> And what about <code>cin</code> and <code>cout</code>?
<dd> Really: these are are predefined global symbols of type
     <code>ostream</code> and
     <code>istream</code>. What 120++ could live with: CS 120 does not
    distinguish <code>ostream</code> from <code>ofstream</code>, or
    <code>istream</code> from <code>ifstream</code>.
    Insert into your global symbol table the equivalent of:
<pre>
ofstream cout;
ifstream cin;
</pre>
<dt> Doesn't that beg the question of what to insert for these predefined
     classes?
<dd> Yes, and its worse than that.
     120++ does not go into operator overloading, but
     we need <code>&lt;&lt;</code> and <code>&gt;&gt;</code>
     to be predefined to work on them. Table A.5
     in Soule's appendix, also found in our 120++ reference manual, mentions
     a few methods defined on streams.

<dt> What about the class named <code>string</code>?
<dd> I would guess we need to predefine the class string, like we do
ofstream and ifstream.  I don't think defining it as char * will work,
unless 120++ never actually uses methods of class string, and only
passes them as parameters.
-->

<dt> Can you please clarify what to do with prototypes and what to do
    with Function Definitions?
<dd> You are not required to handle prototypes in g0. If you do,
     prototypes insert something into a global symbol table, enough to
     typecheck calls to the prototyped function.  They do not need
     a local symbol table, and would normally ignore names of parameters.
     They might have a boolean flag or other means of remembering
     in the global symbol table that they are just a prototype, so that
     they would not trigger a redeclaration error when the definition of that
     function finally shows up.  In fact, a prototype can appear multiple
     times with no redeclaration error.
     You would think that when the function definition occurs on a
     function that has an existing prototype, it should trigger a
     typecheck on the number and type of existing parameters.  In
     C++ there is function overloading, so the story is not so simple.
</dl>

<h3>Typechecking Square Brackets Example, cont'd </h3>

Where we left off was:

<pre>
   /*
    * Given the children's types, see whether n1[n3] is legal
    */
   switch (n1->type->basetype) {
   case LIST:
      /* check if n3's type is integer */
      if (n3->type->basetype != BT_INTEGER) {
          bad_type("list must be subscripted with integers", n3);
	  return TYPE_ERROR;
          }
      /* assign n's type to be n1's element type */
      n->type = n1->type->u.l.elemtype;
      break;
   case TABLE:
      /* check if n3's type is n1's index type */
      if (n3->type->basetype != n1->type->u.t.indextype->basetype) {
          bad_type("table must be subscripted with its declared index type", n3);
	  return TYPE_ERROR;
         }
      /* assign n's type to be n1's element type */
      n->type = n1->type->u.t.elemtype;
      break;
   default:
      bad_type("list or table expected in [] operation", n1);
      /* what does n's type field hold, then */
      n->type = /* ?? */
      return TYPE_ERROR;
      }
</pre>

<br>
<br>
<br>
<br>
<br>
Did we get something like:

<pre>
      if (n3->type->basetype != INTEGER) {
         bad_type("index must be integer in [] operation", n3);
         }
      n->type = n1->type->elemtype;
</pre>
and
<pre>
      if (n3->type->basetype != n1->type->indextype) {
         bad_type("index type must be compatible in [] operation", n3);
         }
      n->type = n1->type->elemtype;
</pre>

<h3> What other type checking examples should we be doing? </h3>

So far in lecture we have seen possibly-too-handwavy examples of
<ul>
<li> Operators like x + y
<li> Parameters for a function call f(x,y) where tuple types must be checked
<li> Subscript operator x[y]
</ul>

What else would help you wrap your brains around type checking?

<p>
<font size=1> <A name=30>lecture #30</A> began here</font>
<p>

<h3> Mailbag </h3>

<dl>
<dt> When putting together my grammar for Homework 2, I didn't implement any
postfix expressions. Instead my grammar rules for a list access looks
something like this:

<pre>
ArrayAccess: IDENTIFIER '[' Expression ']' ;
</pre>

i.e. I only allow brackets after an identifier, so something like
<code>function_that_returns_list()[1]</code> is invalid.
Will I need to implement postfix expressions, so that expressions
like that one are valid?
<dd> While in real languages such expressions are supported, in g0
tests will only get as complicated as those that come
up in CS120. I don't think function returns are subsequently
subscripted, so f()[i] is out, and we have ruled out L[i][j] even
though CS120 does that much. The main postscript expressions that
might be chained together involve the dot operator, so x.y.z or maybe
L[i].x[j] for example.

</dl>

<h3> Midterm Exam Review </h3>

The Midterm will cover lexical analysis, finite automatas, context free
grammars, syntax analysis, parsing, and semantic analysis.
<p>

Q: What is likely to appear on the midterm?
<p>

A: questions that allow you to demonstrate that you know
<ul>
<li> regular expressions
<li> the difference between an DFA and an NFA
<li> lex and flex and tokens and lexical attributes
<li> the %union and yylval interface between flex and bison
<li> context free grammars:
   ambiguity, factoring, removing left recursion, etc.
<li> bison syntax and semantics
<li> parse trees
<li> symbol tables
<li> semantic attributes, type checking
</ul>


<p>

Sample problems:

<ol>
<li> Write a regular expression for numeric quantities of U.S. money
     that start with a dollar sign, followed by one or more digits.
     Require a comma between every three digits, as in $7,321,212.
     Also, allow but do not require a decimal point followed by two
     digits at the end, as in $5.99
<li> Use Thompson's construction to write a non-deterministic finite
     automaton for the following regular expression, an abstraction
     of the expression used for real number literal values in C.<pre>
     (d+pd*|d*pd+)(ed+)? </pre>
<li> Write a regular expression, or explain why you can't write a
     regular expression, for Modula-2 comments which use (* *) as
     their boundaries.  Unlike C, Modula-2 comments may be nested,
     as in (* this is a (* nested *) comment *)
<li> Write a context free grammar for the subset of C expressions
     that include identifiers and function calls with parameters.
     Parameters may themselves be function calls, as in f(g(x)),
     or h(a,b,i(j(k,l)))
<li> What are the FIRST(E) and FOLLOW(T) in the grammar: <pre>
     E : E + T | T
     T : T * F | F
     F : ( E ) | <b>ident</b></pre>
<li> What is the &epsilon;-closure(move({2,4},b)) in the following NFA?
     That is, suppose you might be in either state 2 or 4 at the time
     you see a symbol b: what NFA states might you find yourself in
     after consuming b?<br> (<em>automata to be written on the board</em>)
</ol>

<p>
<font size=1> <A name=midtermsolutions>lecture #m</A> began here</font>
<p>



<h3> Midterm Exam Discussion </h3>

<p>
<font size=1> <A name=31>lecture #31</A> began here</font>
<p>

<h3> HW#3 Discussion </h3>

<ul>
<li> As of 10/16, there are 15 submissions out of 34 enrollees.
<li> If you need assistance, please make an appointment and come visit.
     Remote students: I believe that I can do Zoom appointments. This
     could be audio plus screen sharing, or if you have a camera, maybe
     audio+video plus screen sharing.
<li> I am not very concerned about your "lateness"
<li> I am concerned about preserving enough time for you to finish
     semantic analysis and write a code generator.
<li> <A href="hw4.html">HW#4</A> is posted.  It is due in 2.5 weeks.
</ul>

<h3>From Type Checking on Towards Code Generation</h3>

<ul>
<li> We may yet want to do a larger example of type checking.
<li> It is fair game for you to ask more questions as you work on it.
<li> Main reason to compute all this type information was: we need it
     for code generation.  And we need it because different types are
     different sizes and call for different machine instructions.
<li> Fancy words for adding information to the syntax tree (and symbol tables,
     which are mainly used so you can look up things in the syntax tree):
     decoration, annotation... Kochava had an interesting word for it
     in their CS400 presentation last week... but basically, it is a
     fundamental task of computing to
     turn <em>data</em> into <em>information</em> by analyzing it
     and adding value.
</ul>

<h3>Run-time Environments </h3>

<dl>
<dt>How does a compiler (or a linker) compute the addresses for the various
instructions and references to data that appear in the program source code?
<dd>To generate code for it, the compiler has to "lay out" the data as it will
be used at runtime, deciding how big things are, and where they will go.
</dl>

<ul>
<li> Relationship between source code names and data objects during execution
<li> Procedure activations
<li> Memory management and layout
<li> Library functions
</ul>





<h4> Scopes and Bindings </h4>

<ul>
<li> Variables may be declared explicitly or implicitly in some languages

<li> Scope rules for each language determine how to go from names to
     declarations.
<li> Each use of a variable name must be associated with a declaration.
</ul>

This last item is generally done via a symbol table. In most compiled
languages it happens at compile time (in contrast, for example ,with LISP).

<h4> Environment and State </h4>

Environment maps source code names onto storage addresses (at compile time),
while state maps storage addresses into values (at runtime).  Environment
relies on binding rules and is used in code generation; state operations
are loads/stores into memory, as well as allocations and deallocations.
Environment is concerned with scope rules, state is concerned with things
like the lifetimes of variables.
<p>


<!--
<h3> Thoughts on the Predefined Classes </h3>

Tables 1.4 and 1.5 of the 120++ manual present Dr. Soule's reference
on built-in classes such as string, ifstream, and ofstream.

One way to implement these would be to write actual source code for (the
     tiny subset of) these classes that we need, and feed it into your
     compiler as if it were an #include.  Another way would be to just
     execute code that performs the corresponding symbol table inserts and
     type constructors.

<pre>
class ifstream {
   public:
      ignore();
   }
class ofstream {
   }
</pre>
-->

<!--
<h3> Semantics Things Checked </h3>

<dl>
<dt> extern
<dd> this word does not appear in 120++
<dt> static
<dd> this word does not appear in 120++
<dt> default constructor
<dd> this is used (without discussion) in an example in 120++
     Your semantic rule would be: if no constructor is present,
     insert a default constructor into the symbol table for a class.
<dt> delete
<dd> this is used in a trivial way on a simple pointer variable.
     Your typecheck rule would be: its operand must be a pointer.
</dl>
-->


<h3> Runtime Memory Regions </h3>

Operating systems vary in terms of how the organize program memory
for runtime execution, but a typical scheme looks like this:

<table border>
<tr><th>code
<tr><th>static data
<tr><th>stack (grows down)
<tr><td>heap (may grow up, from bottom of address space)
</table>

The code section may be read-only, and shared among multiple instances
of a program.  Dynamic loading may introduce multiple code regions, which
may not be contiguous, and some of them may be shared by different programs.
The static data area may consist of two sections, one for "initialized data",
and one section for uninitialized (i.e. all zero's at the beginning).
Some OS'es place the heap at the very end of the address space, with a big
hole so either the stack or the heap may grow arbitrarily large.  Other OS'es
fix the stack size and place the heap above the stack and grow it down.


<h4> Questions to ask about a language, before writing its code generator</h4>

<ol>
<li> May procedures be recursive? (Duh, all modern languages...)
<li> What happens to locals when a procedure returns? (Lazy deallocation rare)
<li> May a procedure refer to non-local, non-global names?
     (Pascal-style nested procedures, and object field names)
<li> How are parameters passed? (Many styles possible, different
     declarations for each (Pascal), rules hardwired by type (C)?)
<li> May procedures be passed as parameters?  (Not too awful)
<li> May procedures be return values? (Adds complexity for non-local names)
<li> May storage be allocated dynamically (Duh, all modern languages...
     but some languages do it with syntax (new) others with library (malloc))
<li> Must storage by deallocated explicitly (garbage collector?)
</ol>

<p>
<font size=1> <A name=32>lecture #32</A> began here</font>
<p>

<h3>"Mailbag"</h3>

<dl>
<dt> I am having a problem with a segmentation fault.  Can you help?
<dd> When sticking print statements into your program no longer cuts it,
     your two best hopes are GDB and Valgrind.  Yes, I can help
<ul>
<li> the first thing I will want to see is your valgrind run on your segfault
<li> the second thing I am going to want to see is your open gdb session
     at the point of the segfault, with the "where" output, and the "print"
     command run on each variable on the line where the segfault occurred
</ul>
</dl>

<h3>Another Typecheck Example</h3>

Consider the following small program.

<pre>
void main()
{
   int i;
   i = 0;
   while (i &lt; 5) {
      write(fib(i))
      i += 1
      }
}
int fib(int n)
{
  if (n &lt; 3) { return 1 }
  return fib(n-2) + fib(n-1)
}
</pre>

<ul>
<li> given a parse tree, we want to compute the types of all
     symbols and expressions.
<li> You have exactly one hammer to use: tree traversal
<pre>
   void visit(struct tree *n) {
      /* pass inherited attribs into children */
      /* visit children */
      /* make use of synthesized attribs in children */
   }
</pre>
<li> Previous Sample Tree traversal code described populating symbol tables.
     Let's simulate/visualize that code on the tree for this program.
<li> Previous Sample Tree traversal code described type checking.
     Let's simulate/visualize that code on the tree for this program.
</ul>

<p>
<font size=1> <A name=33>lecture #33</A> began here</font>
<p>

<h4>Mailbag </h4>

<dl>
<!--
<dt> Regarding pointers, are we only supporting char *? Or are we supporting
all pointer types, like int*, double*? I also wasn't sure if we were
supporting char * as a return type for functions, like char *func().

<dd> Professor Soule uses pointer types like <code>FILE *</code>, but
we are skipping C stdio in favor of a small subset
of C++ iostreams.   When professor Soule explcitly introduces
pointer types he uses int *ptr, and ptr = &x; but these are in
artificial toy fragments. The program example of chapter 7, however,
declares a 2D array of pointers to objects (i.e. class instances),
and uses a pointer to object to swap elements within the 2D array.
Later on he explicitly uses object pointer to implement linked lists.
<blockquote>
Your official charge is to support pointers, except you do not have
to support pointer arithmetic (p + i). Unofficially it seems that
you could get away without supporting pointers to types other than
char and class instances, but I am not sure that will save you much.
</blockquote>
-->

<dt>
The problem is, there's just so much to type check (I mean, literally
everything has a type!); can you suggest any ways to go about this in a
quicker manner, or anything in the aforementioned list that could be
pruned/ignored?
<dd>
<ul>
<li> Not literally. The expression grammar.
     And the subset of declarations that you must support.
<li>
     The type checking will typically not happen on $$=$1 rules, so
     the expression grammar has around 18 productions where type checking
     goes.
<li> Feel free to rewrite the grammar to reduce the number of productions
     where you do type checking.
<li> Type checking rules for like-minded operators are identical; use that.
<li> Write helper functions, share common logic.
</ul>


<dt> Hey, look how easy it is to modify our tree-print function to instead
generate a .dot file which the <code>dot(1)</code> program on cs-course42
can turn into a tree that looks like this:
<p>

<img src="am-tree.png">
<p>

[Student shows ~110 lines of C code that writes two .dot files with
different levels of detail via a traversal function similar to your
HW#2 tree printer.]

<dd> That is pretty darned awesome, thank you. Folks are encouraged to check
out <A href="https://linux.die.net/man/1/dot"><code>dot(1)</code></A>.


</dl>

Rest of class was spent on type checking example.
By the way, we decided <code>read()</code> always returns a string.
If you want it to give you an int or a double, write a function to
construct the number from the string.

<p>
<font size=1> <A name=34>lecture #34</A> began here</font>
<p>

<h3> Mailbag </h3>

<dl>
<dt> You talked about promotion from <code>int</code> to <code>double</code>.
     Do we ever have to demote from  <code>double</code> to <code>int</code>?
<dd> What should happen if the g0 program contains:
<pre>
   int i
   double r
   r = 27.0
   i = 3.1415 * r * r // error, no autodemotion
   i = (int) (3.1415 * r * r) // error, no typecasting
</pre>
No, we do not have to support type demotion in g0.
</dl>

<h3> "Modern" Runtime Systems </h3>

Modern languages' runtime systems have extra properties compared with
that of a traditional language like C. Here are a few examples.
<p>

<dl>
<dt> A "self" or "this" in every method call.
<dd> Possibly implemented via a dedicated register, or an implicit,
     extra parameter.  Either way, OO slightly alters the activation record.

<dt> Garbage collection.
<dd> Automatic (heap) storage management is one of the most important features
     that makes programming easier.
The Basic problem in garbage collection is: given a piece of memory, are there
any pointers to it?  (And if so, where exactly are all of them please).
Approaches:

<ul>
<li> reference counting
<li> traversal of known pointers (marking)
	<ul>
	<li> copying (2 heaps approach)
	<li> compacting (mark and sweep)
	<li> generational
	</ul>
<li> conservative collection
</ul>
Note that there is a fine 
<A href="http://www.cs.virginia.edu/~cs415/reading/bacon-garbage.pdf">
paper</A> presenting a "unified theory of garbage collection</A>

<dt> Reflection.
<dd> Objects can describe themselves, via a set of member functions.
     This plays a central role in Visual GUI builders, IDE's,
     component architectures and other uses.

<dt> Just-in-time compilation.
<dd> A virtual machine ("byte code") execution model...can be augmented
     by a compiler built-in to the VM that converts VM instructions
     to native code <em>for frequently executed methods or code blocks</em>.

<dt> Security model.
<dd>  Modern languages may attempt to guarantee certain
     security properties, or prevent certain kinds of attacks.
</dl>

For what its worth, goal-directed programs in languages such as Unicon have
an activation tree each instant, due to suspended activations that may be
resumed for additional results.  The lifetime view is a sort of
multidimensional tree, with three types of nodes.

<p>

<h4>Activation Records</h4>

Activation records organize the stack, one record per method/function call.

<p>

<table border>
<tr><td><td>return value
<tr><td><td>parameter
<tr><td><td>...
<tr><td><td>parameter
<tr><td><td>previous frame pointer (FP)
<tr><td><td>saved registers
<tr><td><td>...
<tr><td>FP--&gt;<td>saved PC
<tr><td><td>local
<tr><td><td>...
<tr><td><td>local
<tr><td><td>temporaries
<tr><td>SP--&gt;<td>...
</table>

<p>

At any given instant, the live activation records form a chain and
follow a stack (push/pop) discipline for allocation/deallocation.
Since each activation record contains a pointer to the previous one,
it is really pretty much a linked list we are talking about, with a
base pointer register holding the pointer to the top of the stack.
<p>

Over the lifetime of the program, all these activation records,
if saved, would form a gigantic tree.  If you remember all
prior execution up to a current point, you have a big tree in which
its rightmost edge are live activation records, and the non-rightmost
tree nodes are an execution history of prior calls. (Program Monitoring
and Visualization could allow us to depict and inspect this history tree.)

<p>

<!--<h3> Reference Implementation Files </h3>

Here are some files containing example code you may use in your compiler
project.  Note that understanding and using someone else's code may require
just as much or more work than writing it yourself, and that no warranty
is expressed or implied: you are responsible for your compiler working,
even if it uses code from these files and it turns out they have a bug!

<ul>
<li> <A href="hw4/main.c">main.c</A>
<li> <A href="hw4/tree.h">tree.h</A>
<li> <A href="hw4/type.h">type.h</A>
<li> <A href="hw4/sym.h">sym.h</A>
<li> <A href="hw4/sym.c">sym.c</A>
<li> <A href="hw4/semantic.c">semantic.c</A>
</ul>-->


<!--
<h3> Reduction in Typecheck Work </h3>

<dl>
<dt> 120++ does not use pointer arithmetic
<dd> so no pointer + integer.
<dt> 120++ does not mention any type promotion
<dd> so no char + integer or integer + double.
</dl>


<h3> On Type-checking of &lt;&lt; </h3>

Consider

<pre>
   cout &lt;&lt;"Player"&lt;&lt;current_player&lt;&lt;endl;
</pre>

We deduce:
<ul>
<li> &lt;&lt; requires a stream on its left side
<li> &lt;&lt; accepts string, char *, int, or double on its right side
       (but not: ... what?)
<li> &lt;&lt; is left-associative
<li> &lt;&lt; produces a value of type ifstream as its result
</ul>
-->




<h3> Variable Allocation and Access Issues</h3>

Given a variable name, how do we compute its address?
<dl>
<dt> globals
<dd> easy, symbol table lookup... once we have figured out how to
     allocate addresses in a process that does not exist yet.
<dt> locals
<dd> easy, symbol table gives offset in (current) activation record
<dt> objects
<dd> Is it "easy"? If no virtual semantics*, symbol table gives offset in
     object, activation record has
     pointer to current object in a standard location. (<em>This is the
     reason C++ does not use virtual semantics by default</em>.)
     <br>
     For virtual semantics, generate code to look up offset
     in a table at runtime, based on the current object's type/class.
<dt> locals in some enclosing block/method/procedure
<dd> ugh.  Pascal, Ada, and friends offer their own unique kind of pain.
     Q: does the current block support recursion?  Example: for procedures
     the answer would be yes; for nested { { } } blocks in C the answer
     would be no.
<ul>
<li> if no recursion, just count back some number of frame pointers based
     on source code nesting
<li> if recursion, you need an extra pointer field in activation record
     to keep track of the "static link", follow static link back some
     # of times to find a name defined in an enclosing scope
</dl>

<h3> *What are "Virtual" Semantics? </h3>

C++ is (just about) the only major object-oriented language
that has to compete with C in the performance arena. For this
reason, it chose early on to be different than every other
OO language. By default, if you are working on a class Foo
object, you can find Foo's member variables and call Foo's
methods by compile-time-determinable memory offsets and
addresses.  So a class is basically no worse than a struct to
generate code for.
<p>

If you say the keyword "virtual" in C++, or if you use just
about any other OOP language, subclassing and interfacing
semantics mean that the address referred to by o.x or o.m()
has to be calculated at runtime by looking up o's actual
class, using runtime type information.





<h3> Sizing up your Regions and Activation Records </h3>

Add a size field to every symbol table entry. Many types are not required
for your C445 project but we might want to discuss them anyhow.<br>

<ul>
<li> The size of chars is 1. We could make them use an alignment of 8,
     but then arrays of char would be all...wrong.<br>
<li> The size of integers is 8 (for x86_64; varies by CPU).<br>
<li> The size of reals is... 8 (for x86_64 doubles; varies by CPU).<br>
<li> The size of strings is... 8? (varies by CPU and language)
<li> The size of arrays is (sizeof (elementype)) * the number of elements.
      In static languages.
   The size of arrays/lists in dynamic languages might be more complicated.
<li> what about sizes of structs/objects?  They are the size of the sum of
     their members... after adding in padding to meet alignment requirements.
</ul>
<p>

You do this sizing up once for each scope.  The size of each scope is the
sum of the sizes of symbols in its symbol table.




<A name="codegen">
<h3> Intermediate Code Generation </h3>
</A>

Goal: list of machine-independent instructions for each procedure/method
in the program.  Basic data layout of all variables.
<p>

Can be formulated as syntax-directed translation
<ul>
<li> add new semantic attributes where necessary.
     For expression E we might have
<dl>
<dt> <code>E.place</code>
<dd> the location that at run-time will hold the value of E
<dt> <code>E.code</code>
<dd> the sequence of intermediate code statements evaluating E.
</dl>
     How does the compiler talk at compile-time about addresses that
     will exist at runtime?
<ul>
<li>  Option (A): leave everything as names for now.  "declare" the names
     in intermediate code, specifying which memory region they live in, and
     how many bytes big they are. assume an assembler will convert names to
     addresses during final code generation.
<li> Option (B): designate only four names for the four memory regions:
     code, global/static, stack, and heap. Specify all addresses as offsets
     in one of those regions. For first two, offsets are relative to a base
     pointer that is the start of the two region. For the latter two, offsets
     are relative to a register (current activation record/base pointer, and
     current "this/self" object pointer).
</ul>
</ul>

<p>
<font size=1> <A name=35>lecture #35</A> began here</font>
<p>

<h3> Helper Functions for Intermediate Code Generation </h3>

<ul>
<li> new helper functions, e.g.
<dl>
<dt><code>newtemp(n)</code>
<dd> returns a new temporary variable each time it is called.
     Parameter <code>n</code> could be #words, or #bytes. Let's say it
     is the number of 8-byte words.  Default is
     one word (8 bytes), always out of the local region, on the stack.
<dt><code>newlabel()</code>
<dd> returns a new label each time it is called.  A label is a name for
     a code region address, but for practical purposes newlabel() could
     just return a unique integer i by incrementing a counter each time,
     or string "L"||i (e.g. "L29") each time it is called.
</dl>
<li> actions that generate intermediate code formulated as semantic rules
</ul>

These helper functions might really be best described
as returning "addresses". Intermediate code addresses
are described down below.

<h3>Semantic Rules for Intermediate Code Generation</h3>

Code for evaluating traditional expressions can be synthesized
via bottom-up traversal.

<p>

<table border>
<tr><th>Production</th><th>Semantic Rules</th></tr>

<tr>
<td>S -&gt; id ASN E  <td> S.place = id.place<br>
			   S.code = E.code || gen(ASN, id.place, E.place)
<tr>
<td>E -&gt; E1 PLUS E2 <td> E.place = newtemp()<br>
			    E.code = E1.code || E2.code || gen(PLUS,E.place,E1.place,E2.place)

<tr>
<td>E -&gt; E1 MUL E2 <td> E.place = newtemp()<br>
			    E.code = E1.code || E2.code || gen(MUL,E.place,E1.place,E2.place)

<tr>
<td>E -&gt; MINUS E1 <td> E.place = newtemp()<br>
			    E.code = E1.code || gen(NEG,E.place,E1.place)

<tr>
<td>E -&gt; LP E1 RP <td> E.place = E1.place<br>
			  E.code = E1.code

<tr>
<td>E -&gt; IDENT <td> E.place = id.place<br>
			  E.code = emptylist()

</table>

<A name="tac">
<h4> Three-Address Code </h4>
</A>

Basic idea: break down source language expressions into simple pieces that:
<ul>
<li> translate easily into real machine code
<li> form a linearized representation of a syntax tree
<li> allow us to check our own work to this point
<li> allow machine independent code optimizations to be performed
<li> increase the portability of the compiler
</ul>

You can literally just make up this intermediate code file format. It
should be human readable and resemble assembler code.

<p>

<b>Instructions:</b>

<p>

<table>
<tr><th>mnemonic<th>C equivalent</th><th> description
<tr><td><code>ADD,SUB,MUL,DIV</code><th>x = y <em>op</em> z;<td> store result of binary operation on y and z to x
<tr><td><code>NEG</code><th>x = -y; </th><td> store result of unary operation on y to x
<tr><td><code>ASN</code><th>x = y </th><td> store y to x
<tr><td><code>ADDR</code><th>x = &y </th><td> store address of y to x
<tr><td><code>LCONT</code><th>x = *y </th><td> store contents pointed to by y to x
<tr><td><code>SCONT </code><th>*x = y </th><td> store y to location pointed to by x
<tr><td><code>GOTO</code><th>goto L </th><td> unconditional jump to L
<tr><td><code>BLT,...</code><th>if x <em>rop</em> y then goto L </th><td> binary conditional jump to L; <em>rop</em> is a "relational operator" (comparison)
<tr><td><code>BIF</code><th>if x then goto L </th><td> unary conditional jump to L
<tr><td><code>BNIF</code><th>if !x then goto L </th><td> unary negative conditional jump to L
<tr><td><code>PARM</code><th>param x </th><td> store x as a parameter
<tr><td><code>CALL</code><th>call p,n,x </th><td> call procedure p with n parameters, store result in x
<tr><td><code>RET</code><th>return x </th><td> return from procedure, use x as the result
</table>
<p>

<b>Declarations (Pseudo instructions):</b>

These declarations list size units as "bytes"; in a uniform-size environment
offsets and counts could be given in units of "words", where a slot (8 bytes
on 64-bit machines) holds anything.
<p>

<table>
<tr><th>Declaration<th>Definition
<tr><td><pre>global x,n1,n2 &nbsp;&nbsp;&nbsp;</pre></td><td>declare a global named x at offset n1 having n2 bytes of space
<tr><td><pre>proc x,n1,n2</pre></td><td>declare a procedure named x with n1 bytes of parameter space and n2 bytes of local variable space
<tr><td><pre>local x,n</pre></td><td>declare a local named x at offset n from the procedure frame.<br>
Optional, allows you to use names in your
three-address instructions to denote the offset. Beware scope.
<tr><td><pre>label L<sub>n</sub></pre></td><td>designate that label <code>L<sub>n</sub></code> refers to the next instruction
<tr><td><pre>end</pre></td><td>declare the end of the current procedure
</table>

<p>
<font size=1> <A name=36>lecture #36</A> began here</font>
<p>

<h3>TAC Adaptations for Object Oriented Code</h3>

The sketchiness of the following table is pretty good evidence that we are
just making this up as we go along.

<p>

<table>
<tr><th>mnemonic<th>equivalent<th>description
<tr><td><pre>MEMBER</pre><th>x = y.z</th><td>lookup field named z within y, store address to x
<tr><td><pre>NEW</pre><th>x = new Foo,n<td>create a new instance of class named x, store
address to x.<br> Constructor is called with n parameters (previously pushed
on the stack).
<tr><td><pre>class</pre><th>class x,n1,n2<td>pseudoinstruction to declare a class named x with n1 bytes of class variables and n2 bytes of class method pointers
<tr><td><pre>field</pre><th>field x,n<td>pseudoinstruction to declare a field named x at offset n in the class frame
</table>

<p>

Note: no new instructions are introduced for a member function call.  In a
non-virtual OO language, a member function call <code>o.m(x)</code> might be
translated as <code>Foo__m(o,x)</code>, where <code>Foo</code> is
<code>o</code>'s class.  Other translation schemes are possible.


<h3> Variable Reference, Dereference, and Assignment Semantics </h3>

Given, say, x having a value of 2, what does the following compute?

<pre>
   int y = x + (x = x + 1) + x;
</pre>

OK, what about

<pre>
   int y = x + x + (x = x + 1) + x;
</pre>

In order to get the answers right, one has to understand the moment at which
a variable reference is computed versus the moment at which it is dereferenced
to obtain its value, versus the moment at which it is assigned a new value.
<p>

Operator precedence (and parentheses) determine what order the expressions
are evaluated.  But evaluating something as simple as
<em>expr</em>+<em>expr</em> can give surprise results if variables' values
can change between their reference construction and dereferencing operation.



<h3> Tree Traversals for Moving Information Around </h3>

Like with semantic analysis, the intermediate code generation game is
largely one of moving information around in the tree.

<ul>
<li> NOT a "blind" traversal that does the same thing at each node.
<li> often a switch statement pre- or post- the traversal of children
<li> switch cases are the grammar rules used to build each node
<li> lots of similar-but-different cases, for similar-but-different
       production rules for the same non-terminal.
</ul>

The alternative to writing one huge recursion
consisting of gigantic switch statements is the "swarm" model:
write a suite of mutually-recursive functions that know
how to do work for each different rule or each different type of
non-terminal node for that traversal.



<h4> Traversal code example </h4>

The following code sample illustrates a code generation tree traversal.
Note the gigantic switch statement.  A student once asked the question
of whether the link lists might grow longish, and if one is usually appending
instructions on to the end, wouldn't a naive link list do a terrible
O(n<sup>2</sup>) job.  To which the answer was: yes, and it would be good
to use a smarter data structure, such as one which stores both the head
and the tail of each list.

<pre>
void codegen(nodeptr t)
{
   int i, j;
   if (t==NULL) return;

   /*
    * this is a post-order traversal, so visit children first
    */
   for(i=0;i&lt;t-&gt;nkids;i++)
      codegen(t-&gt;child[i]);

   /*
    * back from children, consider what we have to do with
    * this node. The main thing we have to do, one way or
    * another, is assign t-&gt;code
    */
   switch (t-&gt;label) {
   case PLUS: {
      t-&gt;code = concat(t-&gt;child[0].code, t-&gt;child[1].code);
      g = gen(PLUS, t-&gt;address,
              t-&gt;child[0].address, t-&gt;child[1].address);
      t-&gt;code = concat(t-&gt;code, g);
      break;
      }
   /*
    * ... really, a bazillion cases, up to one for each
    * production rule (in the worst case)
    */
   default:
      /* default is: concatenate our children's code */
      t-&gt;code = NULL;
      for(i=0;i&lt;t-&gt;nkids;i++)
         t-&gt;code = concat(t-&gt;code, t-&gt;child[i].code);
   }
}
</pre>


<p>
<font size=1> <A name=37>lecture #37</A> began here</font>
<p>

<h3> Mailbag </h3>

<dl>
<dt> How do I get started on code generation?
<dd> Start at the leaves, a.k.a. basis cases.
<ul>
<li>     Fill in attributes, possibly one at a time.
<li>     For example, assign .place values for everything.
<li>     Allocate all your labels and temporary variables
<li>     Assign .true and .false fields in your condition exprs
<li>     You can do all this in 1, 2, or 3 or more tree traversals
</ul>     
       After you have done these things (you may need to print trees
       that show), you are ready to start allocating .code

</dl>

Decisions made 10/25: int does not autoconvert to bool, && and || are
allowed to require bool arguments.  Strings can be compared with == and !=.


<h3> Codegen Example #1 </h3>

<ul>
<li> A lecture or two ago we had a request in class to do an example
     of intermediate code generation.
<li> But we aren't ready to do any non-toy example yet, you
have to get through some more lecture material on code generation for
control flow.
<li>  But consider the following example.
</ul>

<pre>
void main()
{
   int i
   i = 5
   i = i * i + 1
   write(i)
}
</pre>

We want something like

<pre>
proc main,0,32
	ASN	loc:0,const:5
	MUL	loc:8,loc:0,loc:0
	ADD	loc:16,loc:8,const:1
	ASN	loc:0,loc:16
	PARAM	loc:0
	CALL	write,1,loc:24
	RETURN
</pre>

We will do more substantive examples, in a bit.

<!--
<h3> Run Time Type Information </h3>

Some languages would need the type information around at runtime; for
example, dynamic object-oriented languages.  Its almost the case that one
just writes the type information, or symbol table information that includes
type information, into the generated code in this case, but perhaps one
wants to attach it to the actual values held at runtime.

<pre>
struct descrip {
   short type;
   short size;
   union {
      char *string;
      int ival;
      float rval;
      struct descrip *array;
      /* ... for other types */
      } value;
   };
</pre>
-->


<h3> Compute the Offset of Each Variable </h3>

Add an address field to every symbol table entry.
The address contains a region plus an offset in that region.
No two variables may occupy the same memory at the same time.

<h3> Locals and Parameters are not Contiguous! </h3>

For each function you need either to manage two separate regions
for locals and for parameters, or else you need to track where
in that region the split between locals and parameters will be.
This may become more "interesting" if parameters are passed in registers.

<h3> Basic Blocks </h3>

A basic block is a sequence of 1+ instructions in which
there are no jumps into or out of the middle.  In the most extreme
case, every instruction is a basic block.  Start from that perspective
and then lump adjacent instructions together if nothing can come between
them.<p>

What are the basic blocks in the following 3-address code?
("read" is a 3-address code to read in an integer.)

<pre>
	read x
	t1 = x > 0
	if t1 == 0 goto L1
	fact = 1
	label L2
	t2 = fact * x
	fact = t2
	t3 = x - 1
	x = t3
	t4 = x == 0
	if t4 == 0 goto L2
	t5 = addr const:0
	param t5		; "%d\n"
	param fact
	call p,2
	label L1
	halt
</pre>


<h4> Discussion of Basic Blocks </h4>

<dl>
<dt> Basic blocks are often used in order to talk about
     specific types of optimizations.
<dd> For example, there are optimizations that are only safe to do
     within a basic block, such as "instruction reordering for superscalar
     pipeline filling".
<dt> So, why introduce basic blocks here?
<dd> our next topic is intermediate code for control flow, which includes
     gotos and labels, so maybe we ought to start thinking in terms of
     basic blocks and flow graphs, not just linked lists of instructions.
<dt> view every basic block as a hamburger
<dd> it will be a lot easier to eat if you
     sandwich it inside a pair of labels:
<pre>
	label START_OF_BLOCK_7031
	<em>...code for this basic block...</em>
	label END_OF_BLOCK_7031
</pre>
<dt> the label sandwich lets you:
<dd> <ul>
     <li> target any basic block as a control flow destination
     <li> skip over any basic block
     </ul>
      For example, for an if-then statement, you may need to jump to
      the beginning of the statement in the then-part...or you may need
      to jump over it, the choice depending on the outcome of a boolean.
</dl>

Yeah, these lecture notes repeat themselves about the label sandwich, almost
immediately. That must be on purpose.


<h4> C Operators </h4>

In case you were fuzzy on the operators you need to support:

<table border><tr><th> Essential <th> Non-essential
<tr><td> = += -= <td> *= /= %= &lt;&lt;= &gt;&gt;= &amp;= ^= |=
<tr><td> + - * / % <td> &gt;&gt; &lt;&lt; ++ -- ^
<tr><td> &amp;&amp; || ! <td> &amp; | ~
<tr><td> &lt; &lt;= &gt; &gt;= == != <td> ternary x ? y : z
<tr><td> expr[expr] x.y <td> &amp;x x-&gt;y *x
<tr><td> x:=:y; d x; y d x; #x expr[i:j]
</table>

Plus concatenation, which is invisible, but not unimportant.


<h4>Intermediate Code for Control Flow </h4>

Code for control flow (if-then, switches, and loops) consists of
code to test conditions, and the use of goto instructions and
labels to route execution to the correct code.  Each chunk of code
that is executed together (no jumps into or out of it) is called
a <em>basic block</em>.  The basic blocks are nodes in a control flow graph,
where goto instructions, as well as falling through from one basic block
to another, are edges connecting basic blocks.
<p>

Depending on your source language's semantic rules for things like
"short-circuit" evaluation for boolean operators, the operators
like || and && might be similar to + and * (non-short-circuit) or
they might be more like if-then code.
<p>

A general technique for implementing control flow code:
<ul>
<li> add new attributes to tree nodes to hold labels that denote the
possible targets of jumps.
<li>  The labels in question are sort of
analogous to FIRST and FOLLOW
<li>for any given list of instructions
corresponding to a given tree node,
add a .first attribute to the tree to hold the label for the beginning
of the list, and a <code>.follow</code> attribute to hold the label for the next
instruction that comes after the list of instructions.
<li>The .first attribute can be easily synthesized.
<li> The <code>.follow</code> attribute must be
inherited from a sibling.
</ul>

<p>
<font size=1> <A name=38>lecture #38</A> began here</font>
<p>

<h3>Mailbag</h3>

<dl>
<dt> Should the size operator (#) work on classes?
<dd> no
<dt> Does + work for list concatenation?
        e.g. L = L1 + L2. 
<dd> Yes, if you do not implement implicit list concatenation you should
implement an explicit list concatenation operator.
<dt> Is <code>L = L1 + x</code>
be legal if x is the correct element type?
<dd> Yes.

<dt> Are we supporting comparisons of doubles with ==, !=, <=, and >=?
<dd> Yes.

<dt> Is it possible/legal to have variables of type void?
<dd> No.

<dt> To what types of variable is it legal to assign 'null'? 
<dd> Reference types: list, tables and class instances can be null.
</dl>

<h3> If-Then and If-Then-Else </h3>

The labels have to actually be allocated and attached to instructions
at appropriate nodes in the tree corresponding to grammar production
rules that govern control flow.  An instruction in the middle of a
basic block need neither a first nor a follow.

<table border>
<tr><th>C syntax<th>Attribute Manipulations
<tr><td>S-&gt;if '(' E ')' S<sub>1</sub><td>E.true = newlabel();<br>
					E.false = S.follow;<br>
					S<sub>1</sub>.follow = S.follow;</br>
					S.code = E.code || gen(LABEL, E.true)||<br>
					&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
					S<sub>1</sub>.code
<tr><td>S-&gt;if '(' E ')' S<sub>1</sub> else S<sub>2</sub>
<td>E.true = newlabel();<br>
    E.false = newlabel();<br>
	S<sub>1</sub>.follow = S.follow;</br>
	S<sub>2</sub>.follow = S.follow;</br>
	S.code = E.code || gen(LABEL, E.true)||<br>
					&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	S<sub>1</sub>.code || gen(GOTO, S.follow) ||<br>
					&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	gen(LABEL, E.false) || S<sub>2</sub>.code
</table>


<!--
<h4> BASIC </h4>

As a student reported in class, Color BASIC supports statements in
the bodies of THEN and ELSE as an alternative to a line number to GOTO.
Indeed, it supports colon-separated lists of statements.<p>

This means the discussion in class about generating labels for the
starts and ends of then-parts and else-parts applies to BASIC, not
just C.<p>

BASIC also supports boolean AND, OR and NOT operators, and computes them
as integer (0 = FALSE, -1 = TRUE) but they are not short-circuit so the
handling of them is identical to (and simpler than) arithmetic operators
such as + and -.  Since we have not considered them up to now, and they
do not introduce interesting new challenges but instead are just handled
the same as required operators, Booleans are OPTIONAL EXTRA CREDIT for
your homework #4 and 5.  Don't bother with them unless everything else
in your assignment is finished.<p>
-->

<p>


<h3> Generating Code for Conditions </h3>

Understanding the big picture on code generation for control structures such
as if's and while's requires an understanding of how to generate code for
the boolean expressions that control these constructs.
<ul>
<li> Consider the inherited attributes such as E.true and E.false.
<li> These are the destination instruction labels that say where to
      go if the condition is true, or false, respectively.
<li> The parent statement creates or inherits (from its parent
     or sibling) these destination goto labels
<li> They have to get passed down into boolean subexpressions
<li> Options for inherited attributes:
<ul>
<li> Allocate them ahead of time and pass them down in
     an extra tree-traversal before code generation, <b>OR</b>
<li> Go back into E.code afterwards and fill them in after the
     information becomes known! For
     that you'll have to remember/store/track spots where such labels
     are missing. This implies more attributes and/or auxiliary structures.
</ul>
</ul>

<h4> Comparing Regular and Short Circuit Control Flow </h4>

Different languages have different semantics for booleans.
<ul>
<li> Pascal and similar languages treat them similar to arithmetic operators.
<ul>
<li> allocate a temporary variable to store E.place at each tree node
     where a new boolean value is computed.
<li> compute a true or a false result into an E.place.
<li> The .code of the statement using the result inserts, after the E.code, a
     <code>gen(BNIF, E.place, E.false)</code> to skip over a then-part
     for an if with no else, or <br>
     <code>gen(BIF, E.place, E.true) || gen(GOTO, E.false)</code>
     for an if with an else.
</ul>
<li> C (and C++, and many others) specify "short-circuit"
evaluation in which operands are not evaluated once the answer to
the boolean result is known.
<ul>
<li> <b>add extra attributes</b> to keep track of code locations that are
     targets of jumps. The attributes store link lists of those instructions
     that are <em>targets to backpatch</em> once a destination label is known.
     Boolean expressions' results evaluate to jump instructions and program
     counter values (where you get to in the code implies what the boolean
     expression results were).
<li> at each level you have a .true target and a .false target.
<li> naive version may have many unnecessary goto instructions and
      extra labels. This is OK in CS 445. Optimizer can simplify.
</ul>
<li> Some ("kitchen-sink" design) languages have both
     short circuit and non-short-circuit boolean operators!
     (Can you name a language that has both?)
<li> Extra for experts: only the coolest languages utilize a
      Kobiyashi Maru solution: change the machine
      instruction semantics to implicitly route
     control from expression failure to the appropriate location.  In
     order to do this one might
     <ul>
     <li> mark boundaries of code in which failure propagates
     <li> maintain a stack of such marked "expression frames"
     </ul>
</ul>
<p>


<h4> Boolean Expression Example</h4>

<pre>
a&lt;b || c&lt;d && e&lt;f
</pre>

Compare three intermediate code solutions given below.
<ul>
<li> The left uses the intermediate code presented earlier.
<li> The middle uses some new three address instructions. Is it cheating?
<li> Both left and middle end with E.place in t<sub>5</sub> which must
     then be tested/used in some conditional branch to do control flow.
<li> The right side uses short-circuits as per C/C++
</ul>
<p>

<table border>
<tr><th> conditional branches <th> relop instructions <th> short circuit
<tr><td>
<pre>
100:	if a&lt;b goto 103
	t<sub>1</sub> = 0
	goto 104
103:	t<sub>1</sub> = 1
104:	if c&lt;d goto 107
	t<sub>2</sub> = 0
	goto 108
107:	t<sub>2</sub> = 1
108:	if e&lt;f goto 111
	t<sub>3</sub> = 0
	goto 112
111:	t<sub>3</sub> = 1
112:	t<sub>4</sub> = t<sub>2</sub> AND t<sub>3</sub>
	t<sub>5</sub> = t<sub>1</sub> OR t<sub>4</sub>
</pre>
<td>
<pre>
t<sub>1</sub> := a LT b
t<sub>2</sub> := c LT d
t<sub>3</sub> := e LT f
t<sub>4</sub> := t<sub>2</sub> AND t<sub>3</sub>
t<sub>5</sub> := t<sub>1</sub> OR t<sub>4</sub>
</pre>
<td>
<pre>
    if a&lt;b goto E.true
    if c&lt;d goto L1
    goto E.false
L1: if e&lt;f goto E.true
    goto E.false
</pre>
</table>

<P>
Short circuit semantics is short, fast, and can be used to play parlor tricks.

<p>
Q: do we know enough now to write the code generation rules for booleans?

<table border>
<tr>
<th>C syntax<th> Attribute Manipulations
<tr>
<td> E-&gt;E<sub>1</sub> &amp;&amp; E<sub>2</sub>
<td>
<pre>
 E2.first = newlabel();
 E1.true = E2.first;
 E1.false = E.false;
 E2.true = E.true;
 E2.false = E.false;
 E.code = E1.code || gen(LABEL, E2.first) || E2.code;
</pre>
<tr>
<td> E-&gt;E<sub>1</sub> || E<sub>2</sub>
<td>
<pre>
 E2.first = newlabel();
 E1.true = E.true;
 E1.false = E2.first;
 E2.true = E.true;
 E2.false = E.false;
 E.code = E1.code || gen(LABEL, E2.first) || E2.code;
</pre>
<tr>
<td> E-&gt;! E<sub>1</sub>
<td> fill in here <br> ...
</table>

Hints: parent fill's out childrens' inherited attributes...


<p>
<font size=1> <A name=39>lecture #39</A> began here</font>
<p>

<h3>Mailbag</h3>
<dl>
<dt> I can easily fix some of my HW#3 problems. Can I turn in HW#3 to try
     and grind a couple more points out of you?
<dd> BBlearn will let you resubmit.
     If you lost catastrophic points, it is definitely worth resubmitting.
     If you only missed a few, I probably will assess a late fee that makes
     the resubmit mostly moot. Fix issues anyhow so you don't lose points
     on HW#4-6.
<dt> Do we need separate intermediate code instructions for floating point
     and for integer operations?
<dd> Good question.  What do you think?
</dl>

<h3> Intermediate Code for Relational Operators </h3>

<ul>
<li> intermediate code can have either
     relational operators in conditional branch statements, or
     relationals as standalone instructions that compute a
     boolean result.
<li> operands to relationals must be valid (numeric?) type.
<li> inherited attributes get used here, not pushed down further
     to the operands
<li> You could analyze
     whether to generate gotos to E.true/E.false or instead to
     generate values that compute a boolean result. Maybe surrounding
     code only sets your E.true/E.false to non-NULL if result
     should be expressed as gotos?
<li> You might instead compute a result AND generate gotos. The gotos
     might get optimized out if they are not needed.
</ul>

<p>

<table border>
<tr><th>C syntax<th>gotos<th> bool value <th> both ?
<tr><td>E-&gt; E<sub>1</sub> &lt; E<sub>2</sub>
<td>
E.code = E<sub>1</sub>.code || E<sub>2</sub>.code ||<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
           gen(BLT, E<sub>1</sub>.place, E<sub>2</sub>.place, E.true) || <br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
           gen(GOTO, E.false)
<td>
E.place = newtemp() <br>
E.code = E<sub>1</sub>.code || E<sub>2</sub>.code ||<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
           gen(LT, E.place, E<sub>1</sub>.place, E<sub>2</sub>.place)
<td>
E.place = newtemp() <br>
E.code = E<sub>1</sub>.code || E<sub>2</sub>.code ||<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
           gen(LT, E.place, E<sub>1</sub>.place, E<sub>2</sub>.place) || <br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
           gen(BIF, E.place, E.true) || <br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
           gen(GOTO, E.false)

</table>

<h3> Intermediate Code for Loops </h3>

<h4> While Loops </h4>

A while loop has semantic attributes and rules for intermediate code that
are very similar to an if-statement. There is almost only one difference,
the goto back to the beginning. Is there anything else missing or wrong here?

<p>

<table border>
<tr><th>C syntax<th>Attribute Manipulations
<tr><td>S-&gt;while '(' E ')' S<sub>1</sub><td>E.true = newlabel();<br>
					E.first = newlabel();<br>
					E.false = S.follow;<br>
					S<sub>1</sub>.follow = E.first;</br>
					S.code = gen(LABEL, E.first) ||<br>&nbsp;&nbsp;&nbsp;E.code || gen(LABEL, E.true)||<br>
					&nbsp;&nbsp;&nbsp;S<sub>1</sub>.code || <br>
					&nbsp;&nbsp;&nbsp;gen(GOTO, E.first)
</table>

<p>
Finishing touches: what attributes and/or labels does this plan
need in order to support <code>break</code> and <code>continue</code>
statements?

<p>

<h4> For Loops </h4>

For-loops can be trivially transformed into while loops, so they pose just
about no new code generation issues.  Notice that only some expressions
need .true/.false: the ones used as conditionals.

<p>

<table border>
<tr><th>C syntax<th>equivalent<th>Attribute Manipulations
<tr><td>S-&gt;for( E<sub>1</sub>; E<sub>2</sub>; E<sub>3</sub> ) <br>
        &nbsp;&nbsp;&nbsp; S<sub>1</sub>
<td>
E<sub>1</sub>; <br>
while (E<sub>2</sub>) { <br>
   &nbsp;&nbsp;&nbsp;
   S<sub>1</sub> <br>
   &nbsp;&nbsp;&nbsp;
   E<sub>3</sub> <br>
}
<td>		E<sub>2</sub>.true = newlabel();<br>
		E<sub>2</sub>.first = newlabel();<br>
		E<sub>2</sub>.false = S.follow;<br>
		S<sub>1</sub>.follow = E<sub>3</sub>.first;</br>
		S.code = E<sub>1</sub>.code || <br> 
			&nbsp;&nbsp;&nbsp;gen(LABEL, E<sub>2</sub>.first) ||<br>
			&nbsp;&nbsp;&nbsp;E<sub>2</sub>.code || gen(LABEL, E<sub>2</sub>.true)||<br>
			&nbsp;&nbsp;&nbsp;S<sub>1</sub>.code || <br>
			&nbsp;&nbsp;&nbsp;E<sub>3</sub>.code || <br>
			&nbsp;&nbsp;&nbsp;gen(GOTO, E<sub>2</sub>.first)
</table>
<p>

Again: what attributes and/or labels does this plan
need in order to support <code>break</code> and <code>continue</code>
statements?



<!--
<h4> BASIC FOR Loops </h4>

Is the same true for a BASIC FOR loop?  If not,
So how is a FOR loop different from C while loop?
Well, for one thing, there are two separate statements (FOR and NEXT)
that are matched together only by the variable name that controls the loop.

<p>
Example BASIC FOR-loop:
<pre>
10 FOR I = 1 to 10
20 PRINT I
30 NEXT I
</pre>

One possible 3-address code equivalent for this is:
<pre>
L10:				; line 10
	asn G:24 C:1		; I = 1
L10A:				; "end of line 10" == loop test
	bgr G:24 C:10 L30A	; How did we decide to go to end of 30?
L20:				; line 20
	param G:24		; push I onto stack for print
	call  print,1		; call print
L30:				; line 30
	add G:24 G:24 C:1	; I = I + 1
	goto L10A		; go to end of line 10
L30A:
	...
</pre>

There is an obvious question, which is how do the FOR and the NEXT find
each other?  Minimally, one might be looking at writing tree traversal
code to match up FOR and NEXT statements.
-->
<!--
<p>
<h3> FOR loops, continued </h3>

Last time we considered generating code for simple FOR-loops.
In reality FOR loops are stickier than this; FOR really isn't like
a C-style for- or while-loop.
There can be several NEXT statements corresponding to a given
FOR statement.  A FOR statement cannot determine a destination
to which to branch when the loop is finished; it never fails.
If you execute the following lines, BASIC prints a "2":
<pre>
10 FOR I = 2 TO 1
20 PRINT I
30 NEXT I
</pre>

Instead, a NEXT statement must not only do the increment, but also
test the loop's exit condition, and either branch back up to the
top of the loop (if the loop is not finished) or fall through.
In order to communicate between a FOR and any of several NEXT's,
use <em>variables</em>.  As I see it, you need about two variables
to do FOR loops: one variable to store: what code region address
to goto to jump back to do the next iteration of the loop, and
one to store the upper limit of the loop (for STEP versions of FOR
you need a third variable to hold the increment).  With these two
variables, the simple FOR loop looks more like:
<p>
<pre>
L10:				; line 10
	asn G:24 C:1		; I = 1
	asn G:28 L10A
	asn G:32 C:10
	asn G:36 C:1
L10A:				; "end of line 10" == place for NEXT to go
L20:				; line 20
	param G:24		; push I onto stack for print
	call  print,1		; call print
L30:				; line 30
	add G:24 G:24 G:36	; I = I + 1
	bleq G:24 G:32 G:28	; if i <= 10 goto L10A
L30A:
	...
</pre>


<!--
<h4> Note on BASIC's INPUT statement </h4>

By the way, Color BASIC's INPUT statement
has a convenient, optional, PRINT-like prompt clause.  Instead of
<pre>
10 PRINT "Enter your Mastercard Number: "
20 INPUT M$
</pre>
you can write:
<pre>
10 INPUT "Enter your Mastercard Number: "; M$
</pre>
This is shown in Chapter 11 of the Color BASIC book.
-->

<h3> Code generation for Switch Statements </h3>

Consider the C switch statement
<pre>
switch(e) of {
   case v<sub>1</sub>:
      S<sub>1</sub>;
   case v<sub>2</sub>:
      S<sub>2</sub>;
   ...
   case v<sub>n-1</sub>:
      S<sub>n-1</sub>;
   default:
      S<sub>n</sub>;
}
</pre>

The intermediate code for this might look like:

<table><td>
<pre>
	<em>code for e, storing result in temp var t</em>
	goto Test
L<sub>1</sub>:
	<em>code for S<sub>1</sub>
L<sub>2</sub>:
	<em>code for S<sub>2</sub>
	...
L<sub>n-1</sub>:
	<em>code for S<sub>n-1</sub>
L<sub>n</sub>:
	<em>code for S<sub>n</sub>
	goto Next
Test:
	if t=v<sub>1</sub> goto L<sub>1</sub>
	if t=v<sub>2</sub> goto L<sub>2</sub>
	...
	if t=v<sub>n-1</sub> goto L<sub>n-1</sub>
	goto L<sub>n</sub>
Next:
</pre>
<td>
Note that C "break" statements<br>
are implemented in S<sub>1</sub>-S<sub>n</sub><br>
by "goto Next" instructions.
<br><br><br><br><br><br><br><br><br><br>
</table>


<!--
<h3> Brief Followup on Boolean-Integer Compatibility </h3>

Professor Soule's text <em>almost</em> cleanly separates bools and integers,
but not quite: he uses an int variable to hold a boolean value in one
example, and then uses
<pre>
   if (i) ...
</pre>
and suggests in a homework
exercise a feature that would extend it to
<pre>
if (i &amp;&amp; anotherbooleancondition...) ...
</pre>
-->

<h3> Intermediate Code Generation Examples </h3>

Consider the following small program.  It would be fair game as input
to your compiler project.  In order to show blow-by-blow what the code
generation process looks like, we need to construct the syntax tree and
do the semantic analysis steps.
<p>

<pre>
void print(int i);
void main()
{
   int i;
   i = 0;
   while (i < 20)
      i = i * i + 1;
   print(i);
}
</pre>
<p>

<p>
<font size=1> <A name=40>lecture #40</A> began here</font>
<p>


<h3> Mailbag </h3>

<dl>

<dt> Traditionally, % only works on integer arguments.
Do I need to ensure that, or do I need to worry
about modulus for other types?

<dd> % requires integer arguments.

<dt>For class <em>definitions</em>, how do we size them?
<dd>The size of the <em>instances</em> will be the sum of
the sizes of the member variables (rounding up each variable
to the next word boundary), allocated out of the heap.  The class
itself occupies no space.  Variables that hold
references to instances would by default be sized as pointers
(8 bytes) in the global or local regions.

<dt> Do I need to give them a region/offset before I create an instance?
My thought is to give them a size, but only assign a region/offset to an instance of the class.  Does this sound right?
<dd> Sure, size yes, location no.  In fact, at compile time you can only give
the region/offset of the object reference; the address of the actual object
in the heap is not known until runtime.

<dt>
Does the size of a class function include the size of the private members that are declared inside the class but used inside the function?
<dd> No. Private members are in the instances. The member functions that use
class variables must do so using byte offsets relative to the beginning of an
object reference called <code>this</code>.

<dt>
How do I designate float constants?
<dd>
CPU's generally do not have float immediate instructions.  We need an actual
constant region, we need that for string constants too.  So create a region
for them, perhaps R_FLOAT and R_STRING, with byte offsets starting at word
boundaries.  Or you can have one combined region, perhaps R_RODATA.
</dl>

<p>

<img src="codegen.png" width=900 height=600>

<p>

We proceeded with a discussion of how to build the .code fields.
One thing that got said was: .code fields get built via a post-order
traversal (synthetised attribute) but .true, .false etc. are inherited
and may require a previous pass through the tree, or a pre-order
traversal.  If you are trying to do both in one pass it might look like
the following.

<p>

<pre>
void codegen(struct tree *t)
{
   // pre-order stuff, e.g. label generation
   switch (t->prodrule) {
         ...
      case ITERATION_STMT: // inherited attributes for while loop
         // push an inherited attribute to child before visiting them
         t->child[2]->true = newlabel();
         break;
	 ...
      }
   // visit children
   for(i=0; i &lt; t-&gt;nkids; i++) codegen(t->child[0]);

   // post-order stuff, e.g. code generation
   switch (t->prodrule) {
         ...
      case CONDEXPR_2: // synthesized attribs for CondExpr: Expr &lt; Expr
         t->code = concat(
	        t->child[0]->code,
	        t->child[2]->code,
		gen(BLT, t->child[0]->place, t->child[2]->place, t->true),
		gen(GOTO, t->false)
		);
	 break;
      case ITERATION_STMT: // synthesized attributes for while loop
	 t->code = concat(
                    gen(LABEL, t->child[2]->first),
		    t->child[2]->code,
                    gen(LABEL, t->child[2]->true),
   		    t->child[4]->code,
		    gen(GOTO, t->child[2]->first));
	 break;
}
</pre>


<!--
<h3> Grammar Tweak: Casting and Implicit Type Conversion </h3>

<ul>
<li> you have been told that professor Soule's code examples do not include
      type casts, or at least, no implicit conversions.
<li> Maybe that's not quite true/correct.
<li> It is true that Soule's book uses implicit type conversion from int to
     double, <em>at least for the constant 0</em>.  He compares a double to
     0 (bad idea), and returns a 0 from a function that returns type double.
<li> Professor Soule's book also mentions implicit and explicit type
     conversion, including an example of the new-style cast syntax, int(d)
     for some double value.
<li> I had previously removed some of Sigala's grammar rules related to the
     new-style cast syntax due to reduce-reduce conflicts.
<li> I revised the reference 120gram.y to include new-style cast syntax for
     the scalar numeric built-in types.
<li> However, you are not required to do anything more with casts than is
     already stated in the 120++ Manual.
</ul>
-->


<!--
Here is an example BASIC program to compile:
<pre>
10	i = 0
20	IF i &gt;= 20 THEN 50
30	i = i * i + 1
40	GOTO 20
50	PRINT i
</pre>

This program corresponds to the following syntax tree, which a
successful homework #5 would build.  Note that it has a height of
approximately 10, and a maximum arity of approximately 4.  Also: your
exact tree might have more nodes, or slightly fewer; as long as the
information and general shape is there, such variations are not a problem.
<p>
<img src="syntree.jpg">
<em> A syntax tree, with attributes obtained from lexical and semantic
analysis, needs to be shown here.</em>
-->

<p>
<font size=1> <A name=41>lecture #41</A> began here</font>
<p>


The code for the boolean conditional expression controlling the while
loop is a list of length 1, containing the instruction t0 = i < 20,
or more formally

<table>
<tr><th> gotos <th> bool value
<tr><td>

<table border>
<tr><th>opcode<th>dest<th>src1<th>src2</tr>
<tr><td>BLT<td>i<td>20<td>E.true</tr>
<tr><td>GOTO<td>E.false<td>&Oslash;<td>&Oslash;</tr>
</table>

<td>

<table border>
<tr><th>opcode<th>dest<th>src1<th>src2</tr>
<tr><td>LT<td>t0<td>i<td>20</tr>
</table>
</table>
<p>

The actual C representation of addresses dest, src1, and src2 is a

<table border><td>region<br><hr>offset</table> pair, so the
picture of this intermediate code instruction really looks something like this:

<p>

<table>
<tr><th>gotos<th>bool value
<tr>
<td>
<table border>
<tr><th>opcode<th>dest<th>src1<th>src2</tr>
<tr><td>BLT<td>local<br><hr>i.offset<td>const<br><hr>20<td>code<br><hr>(E.true's label#)</tr>
</table>

<td>
<table border>
<tr><th>opcode<th>dest<th>src1<th>src2</tr>
<tr><td>LT<td>local<br><hr>t0.offset<td>local<br><hr>i.offset<td>const<br><hr>20</tr>
</table>
</table>

<p>

Regions are expressed with a simple integer encoding like:
global=1, local=2, const=3.
Note that address values in all regions are offsets from the start of the
region, except for region "const", which
stores the actual value of a single integer as its offset.

<p>

<table border>
<tr><th>opcode<th>dest<th>src1<th>src2</tr>
<tr><td>MUL<td>local<br><hr>t1.offset<td>local<br><hr>i.offset<td>local<br><hr>i.offset</tr>
</table>

<p>
The rest of class was spent elaborating on the linked list of instructions
for the preceding example.


<p>
<font size=1> <A name=42>lecture #42</A> began here</font>
<p>

<h3>Homework Status</h3>

<ul>
<li> As of 12:30 or so this afternoon, 14 students have turned in a HW#4;
     this will be my first HW#4 graded batch.
<li> If you aren't finished with HW#4, you are not alone, and you are graded
     relative to your peers.  But, please continue working on your project,
     and keep me updated.  Do not stay stuck for a week at a time. Do not
     choose not to get help when needed.
<Li> Peek at <A href="hw5.html">HW#5</A>
</ul>

<h3> <code>.first</code> and <code>.follow</code> for StmtList </h3>

<ul>
<li> As mentioned previously, attributes
     <code>.first</code> and <code>.follow</code>
     are an alternative to the "label sandwich" model of code generation
<li> <code>.first</code> holds a label denoting the first instruction to execute when
     control reaches a given subtree within a function body.
<li> <code>.first</code> is a synthesized attribute. Note that unlike
     FIRST(a), there is a unique and deterministic label. But worry-warts
     might want to ask if a given subtree can have epsilon code.
<li> <code>.follow</code> holds a label denoting the instruction that comes after
     a given subtree within a function body.
<li> <code>.follow</code> would be an inherited attribute, obtained from
     some ancestor's sibling.
</ul>

<p>

Suppose you have grammar rules

<pre>
FuncBody : '{' StatementList '}' ;
StatementList : StatementList Statement ;
StatementList :  ;
</pre>

What kind of <code>.first</code> and <code>.follow</code> values can we
develop and pass in to children from these rules?

<br>
<br>
<br>
<br>

<table border>
<tr><th> Syntax <th> Attribute Manipulations
<tr><td><pre>FuncBody : '{' StatementList '}'</pre>
    <td><pre>StatementList.follow = newlabel();
FuncBody.code = StatementList.code ||
                 gen(LABEL,StatementList.follow) ||
		 gen(RETURN)</pre>
<tr><td><pre>StatementList<sub>1</sub>: StatementList<sub>2</sub> Statement</pre>
    <td><pre>StatementList<sub>2</sub>.follow = Statement.first;
Statement.follow = StatementList<sub>1</sub>.follow ||
StatementList<sub>1</sub>.code = StatementList<sub>2</sub>.code || Statement.code</pre>
<tr><td><pre>StatementList : ;</pre>
    <td><pre>/* no need for a StatementList.follow */
StatementList.first = newlabel()
StatementList.code = gen(LABEL, StatementList.first) || gen(NOOP)</pre>
</table>

<!-- Using this same representation, the next instruction found by bottom-up
traversal of the tree is -->


<h3>More Code Generation Examples</h3>

You should implement your code generation one operator at a time,
simplest expressions first.

<p>

Zero operators.<p>

<pre>
if (x) S
</pre>
translates into

<pre>
if x != 0 goto L1
goto L2
label L1
...code for S
label L2
</pre>


or if you are being fancy

<pre>
if x == 0 goto L1
...code for S
label L1
</pre>
I may do this without comment in later examples, to keep them short.
<p>

One relational operator.<p>

<pre>
if (a &lt; b) S
</pre>
translates into

<pre>
if a &gt;= b goto L1
...code for S
label L1
</pre>

One boolean operator.<p>

<pre>
if (a &lt; b  &&  c &gt; d) S
</pre>
translates into

<pre>
if (a &lt; b)
   if (c &gt; d)
      ...code for S
</pre>
which if we expand it

<pre>
if a &gt;= b goto L1
if c &lt;= d goto L2
...code for S
label L2
label L1
</pre>

by mechanical means, we may wind up with lots of labels for the same
target (instruction), this is OK.<p>

Beware the following. A lazy code generator doing short-circuits might be
tempted to say that


<pre>
if (a &lt; b  ||  c &gt; d) S
</pre>
translates into

<pre>
if (a &lt; b) ...code for S
if (c &gt; d) ...code for S
</pre>
but its unacceptable to duplicate the code for S!  It might be huge!
Generate labels for boolean-true=yes-we-do-this-thing, not just for
boolean-false=we-skip-this-thing.

<pre>
if a &lt; b goto L1
if c &gt; d goto L2
goto L3
label L2
label L1
...code for S
label L3
</pre>

<h4> Object-Oriented Changes to Above Examples </h4>

The previous examples were assuming a C-like language semantics.
For an object-oriented language, the generated code for these examples
gets more interesting.  For example, the semantics of
<pre>
if (x) S
</pre>
if x is an object, may be defaulted to be equivalent to
<pre>
if (x != NULL) S
</pre>
or more generally, the different types may have (hardwired, or overrideable)
conversion rules to convert them to booleans for use in tests, such as
<pre>
tempvar := x.as_boolean()
if (tempvar) S
</pre>

<h4> CodeGen for Array subscripting!  </h4>

Consider first the subscript operator for C-like arrays. Then
consider how it ought to work in your compiler.
<p>

So far, we have only said, if we passed an array as a parameter we'd have to
pass its address.  3-address instructions have an "implicit dereferencing
semantics" which say all addresses' values are fetched / stored by default.
So when you say t1 := x + y, t1 gets values at addresses x and y, not the
addresses.  Once we recognize arrays are basically a pointer type, we need
3-address instructions to deal with pointers.  <p>

now, what about arrays?  reading an array value: x = a[i].  Draw the
picture.  Consider the machine uses byte-addressing, not word-addressing.
Unless you are an array of char, you need to multiply the subscript index
by the size of each array element...

<pre>
t0 := addr a
t1 := i * 8
t2 := plus t0 t1
t3 := deref t2
x  := t3
</pre>

What about writing an array value?

<p>

There are similar object-oriented adaptation issues for arrays: a[i]
might not be a simple array reference, it might be a call to
a method, as in
<pre>
x := a.index(i)
</pre>
or it might be implemented like:
<pre>
x := a field i
</pre>

The main issue to keep straight in both the C-like example and the
object-oriented discussion is: know when an instruction constructs an
address and stores an address in a memory location. When you want to
read or write to the address pointed to by the constructed address,
you may need to do an extra level of pointer-following. Three address
instructions have "implicit" pointer-following since all addresses are
followed when reading or writing memory, but if what is in the address
is another address, you have to be careful to keep that straight.

<p>

<!--
Consider the Ct "table" type for a moment.  We have said before now:
one could generate code for tables either by extending the three-address
instruction set with new instructions, or by generating function calls.
How might you implement

<dl>
<dt> table construction: table x
<dt> table insert: x[s] = s2
<dt> table lookup: s = x[s2]
</dl>
-->

<p>
<font size=1> <A name=43>lecture #43</A> began here</font>
<p>


<h3> Supplemental Comments on Code Generation for Arrays </h3>

In order to generalize from our example last lecture,
the 3-address instructions for
<pre>
expr [ expr ]
</pre>
ideally should generate code that computes an address that can
subsequently be read from or written to. One can certainly write
a three address instruction to compute such an address.
With arrays this is pointer arithmetic.
<p>


With tables, the main wrinkle is: what to do
if the key is not in the table?  The behavior might be different
for reading a value or writing a value:

<table border>
<tr>
<th> syntax <th> behavior
<tr>
<td> t[x] := y <td> if key is not in table, insert it
<tr>
<td> y := t[x] <td> if key is not in table, one of:
<ul>
<li> produce a default value
<li> raise an exception
<li> ??
</ul>
</table>
<p>


<!--
The remainder of class was spent working out the details of assembling the
code generation for the entire while loop from our example before: <p>

<img src="intermed.jpg">
-->
<p>


<h3> Debugging Miscellany </h3>

Prior experience suggests if you are having trouble debugging, check:

<dl>
<dt> makefile .h dependencies!
<dd> if you do not list makefile dependencies for important .h files,
     you may get coredumps!
<dt> traversing multiple times by accident?
<dd> at least in my version, I found it easy to accidentally re-traverse
     portions of the tree. this usually had a bad effect.
<dt> bad grammar?
<dd> our sample grammar was adapted from good sources, but don't assume its
     impossible that it could have a flaw or that you might have messed it up.
<dt> bad tree?
<dd> its entirely possible to build a tree and forget one of your children
<!--
<dd> cocogram.y was adapted from an old BASIC grammar and from the available
     books on color computer BASIC.  But, it is certain that it still
     has bugs (missing pieces).  Our goal is not to do the whole of Color
     BASIC, but if there is a bug in the reasonable subset we've defined,
     fix it.
-->
</dl>

<h3> A few observations from Dr. D</h3>

I went shopping for more intermediate code examples, and while I didn't find
anything as complete as I wanted, I did find updated notes from the same
Jedi Master who trained me, check it:
<p>
<A href="IntermediateCodeGeneration.pdf">Dr. Debray's Intermediate Code Generation notes</A>.


<p>

You can consider these a recommended supplemental reading material, and we
can scan through them to look and see if they add any wrinkles to our prior
discussion.


<h3> A Bit of Skeletal Assistance with Three Address Code </h3>

<ul>
<li> <A href="tac.h">tac.h</A>
<li> <A href="tac.c">tac.c</A>
<li> <A href="codegen.c">codegen.c</A>
</ul>


<h3>Intermediate Code Generation for Classes and OO </h3>

<ul>
<li> OO CodeGen varies a lot depending on the OO language semantics.
<li> Lecture notes with ideas relevant to Java, ActionScript, or Unicon
may not do things identically to what a C++ subset needs.
<li> For 120++ we are needing to invent some stuff.
<li> Maybe some new 3 address opcodes/instructions, for example.
<li> Next section is for C++ subset, 120++
<li> More general OO considerations deferred to later
</ul>
<p>

Consider the following simplest possible OO class example program:

<pre>
class pet {
     int happy
      pet() { happy = 50 }
      void play() {
        write("Woof!\n")
	happy += 5
	}
}
int main()
{
    pet pet1
    pet1.play()
    return 0
}
</pre>

What are the code generation issues?
<br><br><br><br><br><br><br><br><br><br><br><br>

Did we get:
<ul>
<li> allocation
<li> initialization via constructor
<li> method calling
<li> member variable referencing
</ul>



<h3> Object Allocation </h3>

<dl>
<dt> memory allocation of an object is similar to other types.
<dd> it can be in the global, local (stack-relative) or heap area
<dt> the # of bytes (size) of the object must be computed from the class.
<dd> each symbol table should track the size of its members
<dt> for a global or local object, add its byte-count size requirement
     to its containing symbol table / region.
<dd> effectively, no separate code generation for allocation
<dt> translate a "new" expression into a malloc() call...
<dd> plus for all types of object creation, a constructor
     function call has to happen.
</dl>

<h3> Initialization via Constructor </h3>

<ul>
<li> A major difference between objects and, say, integers, is that
     objects have constructors.
<li> Constructor, like all other member functions, takes a 0th parameter
     that is a pointer to the object instance.  Could be implemented as
     a register variable, similar to %ebp procedure frame pointer.
<li> For a local, the object variable declaration translates into a
     constructor function call that happens at that point in the code body.
     Just catenate .code into the linked list.
<li> For a "new" object, the constructor function call happens right after
     the (successful) call to allocate the object.
<li> For a global, how do we generate code for its constructor call?
     When does it execute? ... Good news, everyone!  120++ almost
     does not support globals at all, and only has integer globals.
</ul>

<h3> Method Invocation </h3>

Now let's discuss how to generate code for <p>

<code>o.f(arg1,...,argN)</code>

<ul>
<li> In 120++ it's just a method invocation.

<li>
The 120++ case: o's class C is known at compile time and methods are
non-virtual.
You can generate <code>C__f(&o, arg1, ..., argN)</code>.

<li> Note the flip side of this: when you generate code for the member
function body, you do the same name mangling, and add the same extra
one-word "this" parameter to the symbol table.

</ul>

<h3> Member variable references </h3>

<dl>
<dt> inside a member function, i.e. access member variable x.
<dd> Handle like with arrays, by allocating a new temporary variable
     in which to calculate the address of this->x.  Take the address
     in the "this" variable and add in x's offset as given in the
     symbol table for this's class.
<dt> outside an object, o.x.
<dd> Handle as above, using o's address instead of this's.
     You would also check o's class to make sure x is public.
</dl>



<h3> OOP code generation for more dynamic OO languages </h3>

<ul>
<li>
In a real OO language, for o.f(...) you'd do semantic analysis to know
whether f is a method of o's class, or a member variable that happens
to hold a function pointer
<li> Non 120++ case: What if f is a method that C inherits from some superclass S?

<li> Non 120++ case: o's class not known at compiled time and/or methods
are virtual. Calculate at runtime which method f to use for o.
What are your options???

</ul>

<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
Your brilliant suggestions should have included: insert function pointers
for all methods into the instance.<p>

Now let's consider a simple real-world
example.  Class TextField, a small, simple GUI widget. A typical
GUI application might have many textfields on each of many dialogs; many
instances of this class will be needed. <p>

The source code for TextField
is only 767 lines long, with 17 member variables and 47 member functions.
But it is a subclass of class Component, which is a subclass of three other
classes...by the time inheritance is resolved, we have 44 member variables,
and 149 member functions.  If we include function pointers for all methods
in the instance, 77% of instance variable slots will be these function
pointers, and these 77% of the slots will be identical/copied for all
instances of that class.
<p>

The logical thing to do is to share a single copy of the function pointers,
either in a "class object" that is an instance of a meta-class, or more
minimally, in a struct or array of function pointers that might be
called (by some) a <em>methods vector</em>.



<h3> Methods Vectors </h3>

Suppose you have class A with methods f(), g(), and h(), and class B
with methods e(), f(), and g().  Suppose further that you have code
that calls method f(), that is designed to work either either A or B.
This might happen due to polymorphism, interfaces, subclassing, virtual
methods, etc.  The kicker will be that in order to generate code for
o.f(), a runtime lookup will be performed to obtain
the function/method pointer associated with symbol f.

Instead a separate structure (the "methods vector") is allocated and
shared by all the instances of a given class.  In this case, o.f()
becomes o.__methods__.f(o)

<p>
<font size=1> <A name=44>lecture #44</A> began here</font>
<p>


<h3> Example of Generating <code>.first</code> and <code>.follow</code> Attributes </h3>

What nodes need these?
<ul>
<li> probably only the statement level nodes.
<li> they give way to <code>.true</code> and <code>.false</code>
     within (conditional) expressions
<li> maybe only certain statements, like loops, and
     statements that have a preceding statement that
     can jump to them instead of just falling through
<li> ok to just blindly brute force these, as many as you want
<li> but it would be good to not write them if they aren't used
</ul>
<p>

Call <code>gen_firsts(root)</code> followed by <code>gen_follows(root)</code> before generating code.
<p>

<table border>
<tr><th><code>.first</code><th><code>.follow</code>
<tr><td>
What?
<ul>
<li> synthesized attribute
<li> a label (#) to precede all executable instructions for a given chunk of
     code
</ul>
Why?
<ul>
<li> loops may go back to their <code>.first</code>.
<li> preceding statements' <code>.follow</code> may be inherited from your <code>.first</code>
</ul>


Sample code:
<pre>
void gen_firsts(nodeptr n)
{
   if (n == NULL) return;
   for(i=0; i<n->nkids; i++)
      gen_firsts(n->kids[i]);

   switch (n->prodrule) {
   case LABELED_STATEMENT:
      n->first = /* ... just use the explicit label */
      break;
   case EXPRESSION_STATEMENT:
   case COMPOUND_STATEMENT:
   case SELECTION_STATEMENT:
   case ITERATION_STATEMENT:
   case JUMP_STATEMENT:
   case DECLARATION_STATEMENT:
   case TRY_BLOCK:
      n->first = genlabel();
      break;
   default:
   }
}
</pre>

<td>
Why?
<ul>
<li> if we skip a then-part or do a then-part and have to skip an else-part
<li> if we have to break out of a loop
</ul>


What?
<ul>
<li> inherited attribute
<li> a label to go to whatever comes after the executable instructions for
     a given chunk of code.
<li> Could try to dodge, by blindly generating labels at the end of each
     statement ("label sandwich" approach). 
</ul>

<pre>
void gen_follows(nodeptr n)
{
   if (n == NULL) return;

   switch (n-&lt;prodrule) {
   case STATEMENT_SEQ + 2: /* statement_seq : statement_seq statement */
        n->child[0]->follow = n->child[1]->first;
	n->child[1]->follow = n->follow;
   	break;
   case COMPOUND_STATEMENT + 1: /* compstmt : '{' statement_seq_opt '}' */
        if (n->child[1] != NULL)
           n->child[1]->follow = n->follow;
   	break;
   case FUNCTION_DEFINITION + 1: /* funcdef : declarator ctor_init_opt body */
        n->child[2]->follow = genlabel();
        /* .code must have this label and a return at the end! */
   	break;
   /* ... other cases? ... */
   default:
   }

   for(i=0; i&lt;n-&gt;nkids; i++)
      gen_follows(n-&gt;kids[i]);
}
</pre>
</table>


<h3> Labels for <code>break</code> and <code>continue</code> Statements </h3>

<ul>
<li> As shown above, label generation of <code>.first</code> and <code>.follow</code> isn't difficult
<li> <em>propagating</em> that information <em>way down</em>
     into the subtrees where it is needed, across many nodes where it
     is not needed, and not messing up on nested loops, can be a challenge.
<li> Option #1: add inherited attributes .loopfirst and
     .loopfollow to the treenodes. Use them to pass a loop's
     <code>.first</code> and <code>.follow</code>
     down into the "break" and "continue" statements that
     need them: 
<li> Option #2: write a specialized tree traversal whose first parameter is the
     tree (node) we are traversing, and whose second and third parameters
     are pointers to the label (struct address) of the nearest enclosing
     loop.  It would be called as <code>do_break(root, NULL, NULL);</code>
<li> Option #3: implement parent pointers within all the nodes of your
     tree, and walk up the parents until you find a loop node.
</ul>
<p>

Sample code for Option #2 is given below. Implied by the BREAK case is
the notion that the .place field for this node type will hold the label
that is the target of its GOTO. How would you generalize it to
handle other loop types, and the <code>continue</code> statement?
There may be LOTS of different production rules for which
you do something interesting, so you may add a lot of cases to this
switch statement.

<pre>
void do_break(nodeptr n, address *loopfirst, address *loopfollow)
{
   switch (n->prodrule) {
   case BREAK:
      if (loopfollow != NULL)
	 n->place = *loopfollow;
      else semanticerror("break with no enclosing loop", n);
      break;
   case WHILE_LOOP:
      loopfirst = &(n-&gt;first);
      loopfollow = &(n-&gt;follow);
      break;
      ...
      }

   for(i=0; i&lt;n-&gt;nkids; i++)
      do_break(nodeptr n, loopfirst, loopfollow);
}
</pre>


<A name="tacordie">
<h3> TAC or die trying </h3>
</A>

We need a simple example, in which you see

<ul>
<li> Systematic traversal to populate explicit symbol table
<li> Systematic traversal to assign .place (populate implicit symbols)
<li> Systematic traversal to assign <code>.first</code>/<code>.follow</code>/.true/.false
<li> Finally, build linked list of TAC instructions (.code)
</ul>

It is easy to spend too much class time on
front-end stuff before getting to a too-short and still under-explored
TAC code generation phase. Our Goal:
<ul>
<li> manage a slightly larger ("interesting") example
<li> with syntax and semantic analysis already done
<li> for which we can go more blow by blow through the intermediate code
generation.
</ul>

The perfect example would include a few statements, expressions,
control flow constructs, and function calls.  Here is an such an
example. Notes for this exercise:

<Ul>
<li> We will look at a C example.  Compare this with the
     corresponding g0 example.  Qualitatively, what is the difference?
<li> We will just generate the body for function main().
     See if you can generate TAC code for the other functions,
     and ask questions.
<li>  we are again trying hard to use a syntax tree, not a
      parse tree, i.e. generally, no internal nodes with only one child.
<li>  We omit from the tree, tokens that are simply punctuation
      and reserved words needed for syntax.
<li>  Also as stated previously, in real life you
      might not want to remove <em>every</em> unary tree node, some of them
      have associated semantics or code to be generated, or may help
      provide needed context in your tree traversal.
</ul>


<table>
<tr><th>C version <th> g0 version
<tr><td>
<pre>
void printf(char *, int);
int fib(int i);
int readline(char a[]);
int atoi(char a[]);
int main() {
   char s[64];
   int i;
   while (readline(s)!=0 && s[0]!='\004') {
      i = atoi(s);
      if (i <= 0) break;
      printf("%d\n", fib(i));
      }
}
</pre>
<td>
<pre>
int fib(int i){
   if (n <= 1) { return 1 }
   else { return fib(n-1) + fib(n-2) }
}
int ctoi(string s){
   if (s == "0") {return 0}
   else if (s == "1") {return 1}
   else if (s == "2") {return 2}
   else if (s == "3") {return 3}
   else if (s == "4") {return 4}
   else if (s == "5") {return 5}
   else if (s == "6") {return 6}
   else if (s == "7") {return 7}
   else if (s == "8") {return 8}
   else if (s == "9") {return 9}
}
int atoi(string s){
   int i
   i = 0
   while (#s > 0) {
      string c = s[1]
      i = i * 10 + ctoi(c)
      s = s[2:0]
      }
   return i
}
string itoa(int i){
   string s
   int div, rem
   if (i == 0) { return "0" }
   else if (i == 1) { return "1" }
   else if (i == 2) { return "2" }
   else if (i == 3) { return "3" }
   else if (i == 4) { return "4" }
   else if (i == 5) { return "5" }
   else if (i == 6) { return "6" }
   else if (i == 7) { return "7" }
   else if (i == 8) { return "8" }
   else if (i == 9) { return "9" }
   else if (i < 0) { return "-" itoa(-i) }
   else {
     div = i / 10
     rem = i % 10
     return itoa(div) itoa(rem)
   }
}
int main() {
   string s
   int i
   while ((s = read()) != EOF) {
      i = atoi(s)
      if (i <= 0) { break }
      write(itoa(fib(i)))
      }
}
</pre>
</table>

<p>

<pre>
string ftoa(double d)
{
   if (d == 0.0) {
      return "0.0"
   }
   else if (d < 0.0) {
      return "-real"
      }
   else {
     return "real"
   }
}
</pre>


<!--
<pre>
package {
    public class fibber {
	public function fib(n : int): int {
	   if (n <= 1) return 1
	   else return fib(n-1) + fib(n-2)
	}
	public function fibber() {
            var s: String
	    var i: int
            while (s = read()) {
	       i = int(s)
	       if (i <= 0) break
	       trace(fib(i))
	       }
	}
    }
}
</pre>
-->


<p>

<p>
<font size=1> <A name=45>lecture #45</A> began here</font>
<p>

<h3> Mailbag </h3>

<dl>
<dt> Do we need to specify the RET instruction at the end of a function
 or does the END instruction imply that the function returns?
<dd> I think of END in three-address code as a non-instruction
     (pseudo instruction) that marks the end of a procedure,
but there is no reason you could not define its semantics to also do a RET.

<dt> If we have nothing to return, can we just say RET with no parameter or
must the parameter x always be there, i.e. RET x?

<dd> I would accept a RET with no operand. We are allowed to define new
opcodes in intermediate code. Native assemblers often have several variants
of a given instruction -- same mnemonic, different opcodes for a related
family of instructions.

<dt> Can you give me an example of when to use the GLOBAL and LOCAL
declaration instructions?

<dd> These are pseudo-instructions, not instructions.
Globals are listed as required; at the minimum, if your program has any
global variables you must have at least one GLOBAL declaration to give the
size of (the sum of) the global variables. You can do one big GLOBAL and
reference variables as offsets, or you can declare many GLOBAL regions,
effectively defining one named region for each variable and therefore
rendering the offsets moot.

<p>
The LOCAL pseudo-instruction is listed as optional and advisory; think of it
as debugging symbol information, or as an assist to the reader of your
generated assembler source.

<dt> What sort of type checking is needed for a constructor
     (in C++/Java it would be <code>new</code>)?
<dd> If you were implementing <code>new</code>, its
     operand can be almost any type (what would be illegal there?).
     A constructor has to have # and types of parameters checked.
     Its return type is a reference to its operand type, and that type
     is type-checked against its enclosing expression, usually an assignment.
</dl>

<p>



<img src="tac-example.png">
<p>

Using <A href="cgram.y">cgram.y</A> nonterminal names, let's focus on
code generation for the main procedure.



<h3> TAC-or-die: the First-level </h3>

<em>Potentially, this is a separate pass after labels have been generated.</em>
<p>

<table
<tr><td>
<img src="tac-example.png" width=500 height=768>
<td>

The first tree node that TAC code hits in its bottom up traversal is
IDENT<sub>readline</sub> (no .code), followed by IDENT<sub>s</sub> (no .code).
Above the IDENT<sub>s</sub>, argument_expression_list is one of those
non-terminals-with-only-one-child that matters and needs to be in the tree:
each time it churns out an actual parameter,
TAC code generates a PARAM instruction to copy the value of the parameter
into the parameter region. PARAM indicates an 8-byte (word) parameter;
you might also want to define PARAM4, PARAM2, PARAM1 (etc.) instructions.
Q: why is the ADDR instruction here?
<p>
<pre>
	ADDR   loc:72,loc:0
	PARAM  loc:72
</pre>
<p>

The postfix_expr is a function call, whose TAC codegen rule should say:
allocate a temporary variable t<sub>0</sub> (or as we called it: LOC:80)
for the return value, and generate a CALL instruction

<pre>
	CALL readline,1,loc:80
</pre>

The next leaf (ICON<sub>0</sub>) has no .code, which brings code generation
up to the <code>!=</code> operator. Here the code depends on
the .true (L5) and .false (L2) labels.  The TAC code generated is

<pre>
	BNE loc:80,const:0,lab:5
	GOTO lab:2
</pre>

After that, the postfix traversal works over to IDENT<sub>s</sub> (no .code),
ICON<sub>0</sub> (no .code), and up to the postfix expression for the subscript
operator for <code>s[0]</code>.  It needs to generate .code that will place
into a temporary variable (its .place, loc:88) what s[0] is.<p>

The basic expression for a[i] is baseaddr + index * sizeof(element).
sizeof(element) is 1 in this case, so we can
just add baseaddr + index.  And index is 0 in this case, so an optimizer
would make it all go away.  But we aren't optimizing by default, we are
trying to solve the general case.  Calling temp = newtemp() we get a new
location (loc:96) to store index * sizeof(element)
<pre>
	MUL	loc:96,const:0,const:1
</pre>
We want to then add that to the base address, but
<pre>
	ADD	loc:104,loc:0,loc:96
</pre>
would add the (word) <em>contents</em> of s[0-7].  Instead, we need
<pre>
	ADDR	loc:104,loc:0
	ADD	loc:104,loc:104,loc:96
</pre>

After all this, loc:104 contains...the address we want to use.

<pre>
	DEREF1	loc:112,loc:104
</pre>
fetches (into word at loc:112) the <em>value</em> of s[0].
<p>
A label L5 needs to be prefixed into the front of this:
<pre>
	LABEL	lab:5
</pre>

</table>

<p>
Note: an alternative to ADDR would be to define opcodes for reading and
writing arrays.  For example
<pre>
	SUBSC1   <em>dest</em>,<em>base</em>,<em>index</em>
</pre>
might be defined to read from base[index] and store the result in dest.
Similar opcodes for ASNSUB1, SUBSC8, and ASNSUB8 could be added that
assign to base[index], and to perform these operations for 8-byte elements.
Even if you do this, you may need the more general ADDR instruction for
arrays of arbitrary sized elements.

<p>
CCON<sub>^D</sub> has no .code, but the <code>!=</code> operator has
to generate code to jump to its .true (L4) or .false (L2) as in the previous
case.  Question: do we need to have a separate TAC instruction for
char compares, or sign-extend these operands, or what?  I vote: separate
opcode for byte operations.  BNEC is a "branch if not-equal characters"
instruction.

<pre>
	BNEC loc:112,const:4,lab:4
	GOTO lab:2
</pre>

The code for the entire local_and_expr is concatenated from its children:
<pre>
	ADDR   loc:72,loc:0
	PARAM  loc:72
	CALL   readline,1,loc:80
	BNE    loc:80,const:0,lab:5
	GOTO   lab:2
	LABEL  lab:5
	MUL    loc:96,const:0,const:1
	ADDR   loc:104,loc:0
	ADD    loc:104,loc:104,loc:96
	DEREF  loc:112,loc:104
	BNEC   loc:112,const:4,lab:4
	GOTO   lab:2
</pre>


Tree traversal then moves over into the body of the while loop: its statements.
<p>

IDENT<sub>i</sub> has no .code.  The code for <code>atoi(s)</code> looks
almost identical to that for readline(s). The assignment to i tacks on
one more instruction:
<pre>
	ADDR   loc:120,loc:0
	PARAM  loc:120
	CALL   atoi,1,loc:128
	ASN    loc:64,loc:128
</pre>

For the second statement in the while loop, the IF statement, there is
the usual conditional-followed-by-unconditional branch, the interesting
part is where they go.  The E.true should do the then-part (the break
statement) for which we generate a <code>.first</code> of lab:6.  The E.false should
go for whatever instruction follows the if-statement, for which lab:3
has been designated.

<pre>
	BLE    loc:64,const:0,lab:6
	GOTO   lab:3
</pre>

The then-part is a break statement. All then-parts will need to have a
label for their <code>.first</code> instruction, which in this case is a trivial GOTO,
but where does it go?

<pre>
	LABEL  lab:6
	GOTO   ??
</pre>

The <code>break</code> is a major non-local goto that even
the parent node (the if-statement) cannot know the target for, without
obtaining it from about 7 tree-nodes higher!  The iteration_statement's
<code>.follow</code> (lab:2) is the target for <code>break</code> (its
<code>.first</code> would be the target for <code>continue</code>).

<h3> Dr. J has Doubts About 64-bit Ints </h3>

<ul>
<li> Last lecture I pointed out that I had edited the example we are
     working right now, to account for ints being 64-bit instead of 32-bit.
<li> It is reasonable to ask whether this is a Bad Idea.
<li> Pros: if (almost) everything is 64-bits, does that keep things simpler?
<li> Cons: if our ints are not the same size as g++ ints, how will that
     affect us?
</ul>

<h3> Back to the TAC-or-die example </h3>

So by one of options #1-3, we find the nearest enclosing iteration_statement's
<code>.follow</code> field says LAB:2. Note that since we have here a label target that
is itself a GOTO, an optimizer would chase back to the branch instructions
that go to label 6, and have them go to label 2, allowing us to remove this
instruction.  By the way, if there were an else statement, the
code generation for the then-part would include another GOTO (to skip over
the else-part) that we'd hopefully remove in optimization.

<pre>
	LABEL  lab:6
	GOTO   lab:2
</pre>

Having completed the then part, it is time to assemble the entire
if-statement:

<pre>
	BLE    loc:64,const:0,lab:6
	GOTO   lab:3
	LABEL  lab:6
	GOTO   lab:2
	LABEL  lab:3
</pre>

The next statement is a printf statement. We need to push the parameters
onto the stack and execute a call instruction.  The code will be: code
to evaluate the parameters (which are non-empty this time), code to push
parameters (in the correct order, from their .place values),
then the call.  <em>Question: does it matter whether the evaluations
all occur before the PARAM instructions, or could they (should they) be
interleaved?</em>  Answer: in C++ evaluations must all occur before the
PARAM instructions, all PARAM instructions for a call come after the
code for evaluating those arguments, IN REVERSE ORDER, and right
before the CALL instruction.
<p>

The code for parameter 1 is empty; its string address will be
pushed onto the stack when we get to that part.
Here is the code for parameter 2,
storing the return value in a new temporary variable.

<pre>
	PARAM  loc:64
	CALL   fib,1,loc:136
</pre>

The code for the outer call is then

<pre>
	PARAM  loc:64
	CALL   fib,1,loc:136
	PARAM  loc:136
	PARAM  sconst:0
	CALL   printf,2,loc:144
</pre>

Given this, whole while-loop's code can finally be assembled.  The while
prepends a label and appends a GOTO back to the while loop's <code>.first</code> field.
The whole function's body is just this while loop, with a procedure
header and a return statement at the end:

<pre>
proc main,0,128
	LABEL  lab:1
	ADDR   loc:72,loc:0
	PARAM  loc:72
	CALL   readline,1,loc:80
	BNE    loc:80,const:0,lab:5
	GOTO   lab:2
	LABEL  lab:5
	MUL    loc:96,const:0,const:1
	ADDR   loc:104,loc:0
	ADD    loc:104,loc:104,loc:96
	DEREF  loc:112,loc:104
	BNEC   loc:112,const:4,lab:4
	GOTO   lab:2
	ADDR   loc:120,loc:0
	PARAM  loc:120
	CALL   atoi,1,loc:128
	ASN    loc:64,loc:128
	BLE    loc:64,const:0,lab:6
	GOTO   lab:3
	LABEL  lab:6
	GOTO   lab:2
	LABEL  lab:3
	PARAM  loc:64
	CALL   fib,1,loc:136
	PARAM  loc:136
	PARAM  sconst:0
	CALL   printf,2,loc:144
	GOTO   lab:1
	LABEL  lab:2
	RETURN
</pre>


<p>
<p>
<font size=1> <A name=46>lecture #46</A> began here</font>
<p>

<h3> Mailbag </h3>

<dl>
<dt> What do I have to do to get a "D"?

<dd> You are graded relative to your peers.  In previous semesters the
answer to this has been something like: pass the midterm and final, and
convince me that you really did semantic analysis.  If you did poorly on the
midterm, you might want to try and do better on the final, and you might
want to get some three address code working.  Do you really want to settle
for a "D"?  Almost everyone who was "D" material dropped the class already.

<dt> I am confused about how to access class members via the "this"
pointer.  I am unsure how to do the offsets from the "this" pointer in
three address code without creating a new symbol table for class instances.
<dd> An object instance is like its own little memory region.
The <code>this</code> pointer is a parameter; offsets relative to
what it points at are done via pointer arithmetic. Each class
should indeed have a symbol table for its member variables' offsets.

<dt> Do you have an example that uses each of the pseudo instructions
     (global, proc, local, label, and end), so we
     know how these should be formatted?
<dd> No.  The pseudo instructions should have opcodes and three address
fields; their presence in the linked list of three address codes is the
same as an instruction. Their format when you print them out is not very
important since this is just intermediate code. But:
instructions are on a single line that begins with a tab character, and
pseudo instructions are on a single line that does not begin with a tab
character.

<dt> We have const that can hold an int/(int)char/boolean, a string region
for holding a string offset, but what should we do about double const
values?

<dd> Real number constants have to be allocated space similar to other types.
They could either be allocated out of a separate "real number constant
region", or the constants of different types could all be allocated out of
the same region, with different offsets and sizes as needed. Note that
not all integer constants fit in instructions, so potentially
some of them may have to be allocated as static data also.

</dl>

<p>

<a name="finalcode">
<h3> Final Code Generation </h3>
</a>

<ul>
<li> Goal: execute the program we have been translating, somehow.
<li> Note: in real life we would execute a major optimization phase
on the intermediate code, before generating final code.
</ul>

Alternatives for Final Code:
<dl>
<dt> interpret the source code
<dd> we could build an interpreter instead of a compiler, in which the
     source code was kept in string or token form, and re-parsed every
     execution. Early BASIC's did this, but it is Really Slow.
<dt> interpret the parse tree
<dd> we could have written an interpreter that executes the program
     by walking around on the tree doing traversals of various subtrees.
     This is still slow, but successfully used by many "scripting languages".
<dt> interpret the 3-address code
<dd> we could interpret the link-list or a more compact binary representation
     of the intermediate code
<dt> translate into VM instructions
<dd> popular virtual machines such as JVM or .Net allow execution from an
     instruction set that is often higher level than hardware, may be
     independent of the underlying hardware, and may be oriented toward
     supporting the specific language features of our source language.
     For example, there are various BASIC virtual machines out there.
<dt> translate into "native" instructions
<dd> "native" generally means hardware instructions.
</dl>

In mainstream compilers,
final code generation
<ol>
<li> takes a linear sequence of 3-address intermediate
code instructions, and
<li> translates each 3-address instruction into one or
more native instructions.
</ol>
<p>

The big issues in code generation are:
<dl>
<dt> (a) instruction selection, and
<dt> (b) register allocation and assignment.
</dl>



<h3> # of Registers Clarification </h3>

<ul>
<li> numbers quoted last lecture were for "completely undesignated"
     general purpose registers
<li> 32-bit x86 really has eight (8) general purpose registers although
     some are typically used for specific purposes suggested by their name:
     (eax, ecx, edx, ebx, esp, ebp, esi, edi)
<li> 64-bit AMD64 (a.k.a. x86-64) has sixteen (16) registers:
rax, rcx, rdx, rbx, rsp, rbp, rsi, rdi, r8, r9, r10, r11, r12, r13, r14, r15
<li> DEC VAX had 32 registers
<li> ARM (hello, smartphones) has 8, or maybe 13
<li> other RISC systems often have 32 or more;
     Sun SPARC has 192 registers accessed
     via a sliding <em>register window</em>
</ul>

<p>
<font size=1> <A name=47>lecture #47</A> began here</font>
<p>

<h3>Mailbag </h3>

<dl>
<dt> in g0, can we just define a function without parameters as call, so
<code>main</code> is equivalent to <code>main()</code> if not followed
by parentheses?
<dd> It is not recommended to confuse type (reference to) FUNCTION with
the function's return type, which is the result of a call (postfix parentheses
operator).  However, g0 does not pass function pointers as parameters, so
if a supermajority of 2/3rds voted in favor of "implicit call semantics"
for function names without trailing parentheses for g0,
I would allow such semantics.
</dl>

<h3> Discussion of Code Generation for Tables and Lists </h3>

<ul>
<li> g0 has these built-in structure types that need considering.
<li> What we have said so far is that you could define new opcodes
     for such operators (raising the language level of your
     intermediate code), or implement them as function calls.
<li> Either way, we will (by final code generation) need an
     implementation of this functionality, that your code can
     link in and use.  You could write your own, or ask me to
     provide this as a set of runtime functions in C.
</ul>

<p>
Lists:
<p>

<table border>
<tr><th>operation<th> as opcode        <th> as function
<tr><td> L1 L2   <td> LCONCAT t,L1,L2  <td> t = lconcat(L1,L2)
<tr><td> L1 += L2<td> LAPPEND L1,L2    <td> lappend(L1,L2)
<tr><td> L1 += x <td> LPUT    L1,x     <td> lput(L1,x)
<tr><td> L[i]    <td> LINDEX  t,L,i    <td> t = lindex(L,i)
<tr><td> L[i:j]  <td> ???              <td> t = lslice(L,i,j)
<tr><td> #L      <td> LSIZE   t,L      <td> t = lsize(L)
<tr><td> t = list() <td> LIST t,n,m    <td> t = list(n,m)
</table>

<p>
Tables:
<p>

<table border>
<tr><th>operation<th>as opcode<th>as function
<tr><td> T[a]    <td> TINDEX  t,T,a  <td> t = tindex(T,a)
<tr><td> T[]=a   <td> TDEFAULT T,a   <td> tdefault(T,a)
<tr><td> T -= a  <td> TDELETE T,a    <td> tdelete(T,a)
<tr><td> #T      <td> TSIZE   t,T    <td> t = tsize(T)
<tr><td> t = table() <td> TABLE t,m    <td> t = table(m)
</table>




<h3> Collecting Information Necessary for Final Code Generation </h3>

<dl>
<dt> Option #A: a top-down approach to learning your native target code.
<dd>
     Study a reference work supplied by the chip manufacturer, such
     as the <A href="https://support.amd.com/TechDocs/24592.pdf">
     AMD64 Architecture Programmer's Manual</A>
      (<A href="http://developer.amd.com/wordpress/media/2012/10/24593_APM_v21.pdf">Vol. 2</A>,
      <A href="https://support.amd.com/TechDocs/24594.pdf">Vol. 3</A>).
<dt> Option #B: a bottom-up (or reverse engineering)
     approach to learning your native target code.
<dd>
     study an existing compiler's native code.  For example, run
     "g++ -S" for various toy programs
     to learn native instructions corresponding to each expression,
     particularly ones equivalent to the various 3-address instructions.
</dl>


<h4>Instruction Selection</h4>

A modern CPU usually has many different sequences of instructions
that it could use to accomplish a given task.  Instruction selection
must choose a particular sequence.
<ul>
<li> how many registers are tied to particular instructions?
<li> is a special case instruction available for a particular
     computation?
<li> what addressing mode(s) are supported for a given instruction?
</ul>

Given a choice among equivalent/alternative sequences, the decision on which
sequence of instructions to use is usually based on estimates or
measurements of which sequence executes the <em>fastest</em>.

<ul>
<li> "fastest" is often approximated by the
number of memory references incurred during execution, including the
memory references for the instructions themselves.
<li>  picking the
<em>shortest</em> sequence of instructions is often a good approximation of the
optimal result, since fewer instructions usually translates into fewer
memory references.
</ul>

<p>

A good set of examples of instruction selection are to be
found in the <A href="http://www.stanford.edu/class/cs343/resources/superoptimizer.pdf">superoptimizer</A> paper. From that paper:

<ul>
<li> a longer instruction sequence may be faster if it avoids gotos
<li> sometimes the fastest sequence exploits specific constants in the
     operands and is really, really surprising.
</ul>


<h3> Register Allocation and Assignment </h3>

<ul>
<li> reading values in registers is much much faster than accessing main memory.
<li>
<em>Register allocation</em> denotes the selection of which variables
will go into registers.
<li>
<em>Register assignment</em> is the determination of exactly
which register to place a given variable.
<li> goal: minimize the total number of memory accesses required
by the program.
</ul>
<p>

<h4> The (register allocation) job changes as CPUs change </h4>

<ul>
<li>In the age of dinosaurs, Load-Store architectures featured
only one (accumulator) register.
Register allocation and assignment was moot.
<li>In the age of minis and micros, it was usually "easy", e.g.
traditional x86 had 4 registers instead of 1.
<li>Recent History features CPU's with 32 or more general purpose
registers.  On such systems,
high quality compiler register allocation and assignment makes a huge
difference in program execution speed.
<li> :-( btw, optimal register
allocation and assignment is NP-complete! Compilers must settle for
doing a "good" job.

<li>usually the # of variables at many given time exceeds the number
of registers available (the common case)
<li> variables may be used (slowly)
     directly from memory IF the instruction set supports
     memory-based operations.
<li>
When an instruction set does not support memory-based operations, all
variables must be loaded into a register in order to perform arithmetic
or logic using them.
</ul>
<p>

Even if an instruction set does support memory-based operations, most
compilers should load a value into a register while it is
being used, and then spill it back out to main memory when the register
is needed for another purpose.  The task of minimizing memory accesses
becomes the task of minimizing register loads and spills.

<p>
<p>
<font size=1> <A name=48>lecture #48</A> began here</font>
<p>
<h3> Mailbag </h3>

<dl>
<dt>
I'm having trouble figuring out what TAC I need to generate for a function
definition.  For example, given the function 
<pre>int foo(int x){
   ...somecode
}</pre>

I'm having trouble understanding what code needs to be generated at this
level.  I understand that there needs to be (at least) 1 label, at the very
start (to be able to call the function).

<dd><font color=red>In final code, the procedure entry point
will indeed include a label. In three address code, a function header
should result in a PROC pseudo-instruction for which you create a link
list element, just like everything else.
</font>

<dt>

I'm having trouble understanding what code I would create for the int
return, or to define the space available for parameters.

<dd>
<font color=red>
The "return type" at the top of a function generates no code, but it may
affect what you generate when you hit a "return" statement in the function
body.

The proc pseudoinstruction includes a declaration of how many
(words of parameters) it requires/assumes has been passed in to a function,
from which space required may be calculated. It most native code the caller
really allocates this space via PARAM instructions; the called function
just decides the amount of
local/temp variable space on the stack that the procedure requires.
So the pseudoinstructions in intermediate code that you use is
something like:
<pre>
proc foo,1,<em>nbytes_localspace</em>
</pre></font>

<dt>

If I understand the return properly, I don't actually generate code at this
(the procedure header return type) node for the return.  It gets generated
at the 'return' line in the body.

<dd>

<font color=red>Yes. There and at the end of any function
that falls off the end.  In final code the return statement will put a
return value in %eax and then jump
down to the end of the function to use its proper function-return assembler
instruction(s).
</font>

<dt>

I guess the .place of <code>int x</code> is what is really getting me.
Do I really
need to worry about it too much in TAC, because it is just 'local 0' (or
whatever number gets generated)?

<dd>

<font color=red>I recommend you consider it (in TAC) to be region
PARAM offset 0.  That could be handled almost identically to locals in final
code, unless you use the fact that parameters are passed in registers...
</font>

<dt>

Then I really end up worrying about it during final code since local 0 might
actually be something like %rbp -1 or wherever the location on the stack
parameters end up being located.

<dd>

<font color=red>By saying it is PARAM offset 0, the TAC code for
parameters is distinct enough from locals that they can be found to be at
a different location relative to the %rbp (positive instead of negative)
or passed in registers.</font>

</dl>



<h3> Code Generation Examples </h3>

<h4> Reusing a Register </h4>

Consider the statement:
<pre>
   a = a+b+c+d+e+f+g+a+c+e;
</pre>
A naive three address code generator would generate a
lot of temporary variables here, when really one big number is being added.
How many registers does the expression need?  Some variables
are referenced once, some twice.  GCC (32-bit) generates:
<p>

<pre>
	movl	b, %eax
	addl	a, %eax
	addl	c, %eax
	addl	d, %eax
	addl	e, %eax
	addl	f, %eax
	addl	g, %eax
	addl	a, %eax
	addl	c, %eax
	addl	e, %eax
	movl	%eax, a
</pre>

<p>

Now consider
<pre>
   a = (a+b)*(c+d)*(e+f)*(g+a)*(c+e);
</pre>
How many registers are needed here?
<pre>
	movl	b, %eax
	movl	a, %edx
	addl	%eax, %edx
	movl	d, %eax
	addl	c, %eax
	imull	%eax, %edx
	movl	f, %eax
	addl	e, %eax
	imull	%eax, %edx
	movl	a, %eax
	addl	g, %eax
	imull	%eax, %edx
	movl	e, %eax
	addl	c, %eax
	imull	%edx, %eax
	movl	%eax, a
</pre>

And now this:
<pre>
   a = ((a+b)*(c+d))+((e+f)*(g+a))+(c*e);
</pre>
which compiles to
<pre>
	movl	b, %eax
	movl	a, %edx
	addl	%eax, %edx
	movl	d, %eax
	addl	c, %eax
	movl	%edx, %ecx
	imull	%eax, %ecx
	movl	f, %eax
	movl	e, %edx
	addl	%eax, %edx
	movl	a, %eax
	addl	g, %eax
	imull	%edx, %eax
	leal	(%eax,%ecx), %edx
	movl	c, %eax
	imull	e, %eax
	leal	(%eax,%edx), %eax
	movl	%eax, a
</pre>


<h3> Brief Comparison of 32-bit and 64-bit x86 code </h3>

What can be gleaned from this side-by-side of 32-bit and 64-bit assembler
for a=a+b+c+d+e+f+g+a+c+e.
Note that the actual variable names are in the assembler because the variables
in question are globals.
<p>

<table border>
<tr>
<th> x86 32-bit
<th> x86_64
<tr>
<td>
<pre>
	movl	b, %eax
	addl	a, %eax
	addl	c, %eax
	addl	d, %eax
	addl	e, %eax
	addl	f, %eax
	addl	g, %eax
	addl	a, %eax
	addl	c, %eax
	addl	e, %eax
	movl	%eax, a
</pre>
<td>
<pre>
	movq	a(%rip), %rdx
	movq	b(%rip), %rax
	addq	%rax, %rdx
	movq	c(%rip), %rax
	addq	%rax, %rdx
	movq	d(%rip), %rax
	addq	%rax, %rdx
	movq	e(%rip), %rax
	addq	%rax, %rdx
	movq	f(%rip), %rax
	addq	%rax, %rdx
	movq	g(%rip), %rax
	addq	%rax, %rdx
	movq	a(%rip), %rax
	addq	%rax, %rdx
	movq	c(%rip), %rax
	addq	%rax, %rdx
	movq	e(%rip), %rax
	leaq	(%rdx,%rax), %rax
	movq	%rax, a(%rip)
</pre>
</table>

<p>

Q: Should we be disappointed that the 64-bit code looks a lot longer?
<P>
A: Maybe instead we should be <em>fascinated</em>.
<ul>
<li> Looks can be deceiving; x86_64 tends to run a lot faster than x86
<li> Instruction prefetch on x86_64 is extensive; instructions that use
     register operands are short and many may be prefetched together.
<li> Superscalar architectures can execute multiple instructions in parallel
<li> The instructions selected here may be specifically maximizing the
     superscalar behavior
</ul>


<p>

The globals are declared something like the following.
<ul>
<LI><CODE>.comm</code> stands for data in a "common" (a.k.a. global data) section.
<li><code>.globl</code> and <code>.type</code> are used for functions, and are really part of
the function header before the function code starts.
</ul>

If you allocated your globals as a region, you might have one .comm of 56
bytes named globals (or whatever) and give the addresses of your globals as
numbers such as <code>globals+32</code>.  Names are nicer but having to
treat globals and locals very differently is not.

<p>
<pre>
	.comm	a,8,8
	.comm	b,8,8
	.comm	c,8,8
	.comm	d,8,8
	.comm	e,8,8
	.comm	f,8,8
	.comm	g,8,8
	.text
.globl main
	.type	main, @function
</pre>


<h3> Brief Comparison of x86-64 globals vs. locals </h3>

How does this difference inform, and affect, what we might want in
our three-address code?
<p>

<table border>
<tr>
<th> x86_64 local vars
<th> x86_64 globals (as per last example)
<tr>
<td>
<pre>
	movq	-48(%rbp), %rax
	movq	-56(%rbp), %rdx
	leaq	(%rdx,%rax), %rax
	addq	-40(%rbp), %rax
	addq	-32(%rbp), %rax
	addq	-24(%rbp), %rax
	addq	-16(%rbp), %rax
	addq	-8(%rbp), %rax
	addq	-56(%rbp), %rax
	addq	-40(%rbp), %rax
	addq	-24(%rbp), %rax
	movq	%rax, -56(%rbp)
</pre>
<td>
<pre>
	movq	a(%rip), %rdx
	movq	b(%rip), %rax
	addq	%rax, %rdx
	movq	c(%rip), %rax
	addq	%rax, %rdx
	movq	d(%rip), %rax
	addq	%rax, %rdx
	movq	e(%rip), %rax
	addq	%rax, %rdx
	movq	f(%rip), %rax
	addq	%rax, %rdx
	movq	g(%rip), %rax
	addq	%rax, %rdx
	movq	a(%rip), %rax
	addq	%rax, %rdx
	movq	c(%rip), %rax
	addq	%rax, %rdx
	movq	e(%rip), %rax
	leaq	(%rdx,%rax), %rax
	movq	%rax, a(%rip)
</pre>
</table>

<p>
<font size=1> <A name=49>lecture #49</A> began here</font>
<p>


<h3>Parameters</h3>

In final code, do parameters look like locals?
<p>

Consider the following example. Note that "long" is used to more closely
resemble the g0 "everything is a 64-bit value" mind-set.

<pre>
#include &lt;stdio.h&gt;

long f(long,long,long);

int main()
{
   long rv = f(1, 2, 3);
   printf("rv is %d\n", rv);
}

long f(long a, long b, long c)
{
   long d, e, f, g;
   d = 4; e = 5; f = 6; g = 7;
   a = ((a+b)*(c+d))+(((e+f)*(g+a))/(c*e));
   return a;
}
</pre>

for which the generated code was

<pre>
	.file	"expr.c"
	.section	.rodata
.LC0:
	.string	"rv is %d\n"
	.text
.globl main
	.type	main, @function
main:
.LFB0:
	.cfi_startproc
	pushq	%rbp
	.cfi_def_cfa_offset 16
	.cfi_offset 6, -16
	movq	%rsp, %rbp
	.cfi_def_cfa_register 6
	subq	$16, %rsp
	movl	$3, %edx
	movl	$2, %esi
	movl	$1, %edi
	call	f
	movq	%rax, -8(%rbp)
	movl	$.LC0, %eax
	movq	-8(%rbp), %rdx
	movq	%rdx, %rsi
	movq	%rax, %rdi
	movl	$0, %eax
	call	printf
	leave
	.cfi_def_cfa 7, 8
	ret
	.cfi_endproc
.LFE0:
	.size	main, .-main
.globl f
	.type	f, @function
f:
.LFB1:
	.cfi_startproc
	pushq	%rbp
	.cfi_def_cfa_offset 16
	.cfi_offset 6, -16
	movq	%rsp, %rbp
	.cfi_def_cfa_register 6
	pushq	%rbx
	movq	%rdi, -48(%rbp)
	movq	%rsi, -56(%rbp)
	movq	%rdx, -64(%rbp)
	movq	$4, -40(%rbp)
	movq	$5, -32(%rbp)
	movq	$6, -24(%rbp)
	movq	$7, -16(%rbp)
	movq	-56(%rbp), %rax
	movq	-48(%rbp), %rdx
	leaq	(%rdx,%rax), %rcx
	movq	-40(%rbp), %rax
	movq	-64(%rbp), %rdx
	leaq	(%rdx,%rax), %rax
	imulq	%rax, %rcx
	movq	-24(%rbp), %rax
	movq	-32(%rbp), %rdx
	leaq	(%rdx,%rax), %rbx
	.cfi_offset 3, -24
	movq	-48(%rbp), %rax
	movq	-16(%rbp), %rdx
	leaq	(%rdx,%rax), %rax
	imulq	%rbx, %rax
	movq	-64(%rbp), %rdx
	movq	%rdx, %rbx
	imulq	-32(%rbp), %rbx
	movq	%rbx, -72(%rbp)
	movq	%rax, %rdx
	sarq	$63, %rdx
	idivq	-72(%rbp)
	leaq	(%rcx,%rax), %rax
	movq	%rax, -48(%rbp)
	movq	-48(%rbp), %rax
	popq	%rbx
	leave
	.cfi_def_cfa 7, 8
	ret
	.cfi_endproc
.LFE1:
	.size	f, .-f
	.ident	"GCC: (GNU) 4.4.7 20120313 (Red Hat 4.4.7-3)"
	.section	.note.GNU-stack,"",@progbits
</pre>

We learned that (the first 6+) parameters are passed in registers, but
you can allocate local variable space for them, and copy them into
their local space, after which they can be treated exactly like other
locals.

<p>
<font size=1> <A name=50>lecture #50</A> began here</font>
<p>

<h3> Mailbag </h3>

<blockquote>
I saw your in your three address code examples of calling a function that
pass array variables that before PARAM, you always put the array
address into a temporary variable.

like:
<pre>
char s[64];
readline(s)

	ADDR   loc:68,loc:0
	PARAM8 loc:68
	CALL   readline,1,loc:68
</pre>

and  printf("%d\n", 10+2);

<pre>
     addr	    loc:0,string:0
     parm	    loc:0
     add	    loc:8,im:10,im:2
     parm	    loc:8
     call	    printf,16,loc:16
</pre>

So, before passing the variables to the function, do you have to copy
the variables to the temporary variables? And then PARAM the temporay
variables. Or it is only true for passing array address?

<p>

I know the PARAM will copy the passing arguments into the called function's
activation record's parameter region. So there is no need copy the parameter
variables into temporary variables then PARAM the temporary variables.

</blockquote>

Answer: 

The three-address instructions use addresses, but they normally operate by
implicitly fetching and storing values pointed to by those addresses.

<p>

The ADDR instruction does not copy the variable into a temporary variable,
it copies the address given, without fetching its contents, into its
destination.  This is needed in order to pass an reference parameter.
In Pascal, by default we would have to allocate (on the stack) an entire
physical copy of the whole array in order to pass it as a parameter. This is
potentially very expensive, which is why C-based languages don't do it.
<p>

(Q: if you wanted a physical copy of an array to be passed, do you know
some ways to get one?)



<h3> Aside on .cfi* assembler directives </h3>

<ul>
<li> Explanation of
     <A href="http://www.logix.cz/michal/devel/gas-cfi/">CFI directives</A>
     (CFI stands for Call Frame Information)
<li> Summary: the .cfi* statements are used for
exception handling and you can get rid of them using the gcc flag
-fno-asynchronous-unwind-tables
</ul>


<h3> Creating an object via <code>new</code></h3>

Consider the following C++ example of final code for an object
constructor. Executing the reserved word <code>new</code> from 
function <code>main()</code> calls two functions to
create an object in the heap (via <code>new</code>):

<dl>
<dt> _Znwm
<dd>  similar to a <code>malloc()</code>; it takes an integer parameter
(constant 16, the # of bytes to allocate) and returns a pointer
<dt> _ZN1CC1Ev
<dd> a call to a C++ constructor function, with an implicit/added first
parameter for <code>this</code>, the object instance that the member
function is working on.
</dl>

<h3> "new" in final code FYI </h3>

<pre>
class C {
  private: long x, y;
  public:  C() { x=3; y=4; }
};

int main()
{
   C *a = new C;
}
</pre>

generates

<pre>
	.file	"new.cpp"
	.section	.text._ZN1CC2Ev,"axG",@progbits,_ZN1CC5Ev,comdat
	.align 2
	.weak	_ZN1CC2Ev
	.type	_ZN1CC2Ev, @function
_ZN1CC2Ev:
.LFB1:
	.cfi_startproc
	.cfi_personality 0x3,__gxx_personality_v0
	pushq	%rbp
	.cfi_def_cfa_offset 16
	.cfi_offset 6, -16
	movq	%rsp, %rbp
	.cfi_def_cfa_register 6
	movq	%rdi, -8(%rbp)
	movq	-8(%rbp), %rax
	movq	$3, (%rax)
	movq	-8(%rbp), %rax
	movq	$4, 8(%rax)
	leave
	.cfi_def_cfa 7, 8
	ret
	.cfi_endproc
.LFE1:
	.size	_ZN1CC2Ev, .-_ZN1CC2Ev
	.weak	_ZN1CC1Ev
	.set	_ZN1CC1Ev,_ZN1CC2Ev
	.text
.globl main
	.type	main, @function
main:
.LFB3:
	.cfi_startproc
	.cfi_personality 0x3,__gxx_personality_v0
	pushq	%rbp
	.cfi_def_cfa_offset 16
	.cfi_offset 6, -16
	movq	%rsp, %rbp
	.cfi_def_cfa_register 6
	pushq	%rbx
	subq	$24, %rsp
	movl	$16, %edi
	.cfi_offset 3, -24
	call	_Znwm
	movq	%rax, %rbx
	movq	%rbx, %rax
	movq	%rax, %rdi
	call	_ZN1CC1Ev
.L5:
	movq	%rbx, -24(%rbp)
	movl	$0, %eax
	addq	$24, %rsp
	popq	%rbx
	leave
	.cfi_def_cfa 7, 8
	ret
	.cfi_endproc
.LFE3:
	.size	main, .-main
	.ident	"GCC: (GNU) 4.4.7 20120313 (Red Hat 4.4.7-3)"
	.section	.note.GNU-stack,"",@progbits
</pre>

As you may observe: the final code for a <code>new</code> calls a memory
allocator (nwm) whose return value (%rax) gets copied in as a parameter
(%rdi) to the constructor (N1CC1Ev), with an interesting side trip to %rbx.

<h3> On C/C++ Calling Convention and Order of Passed Parameters </h3>

In compilers, the calling conventions are the set of rules by which parameters
and return values are communicated between caller and callee. The calling
conventions also cover things like whether the caller or the callee has to
save and restore specific registers as part of the process of call/return.

<UL>
<li> a good <A href="https://en.wikipedia.org/wiki/X86_calling_conventions">general discussion</A> is available on Wikipedia
<li> Each C compiler makes its own rules. We could do what we want unless we
need to be compatible with another compiler to call their library functions,
in which case we have to follow their calling conventions
<li> In C/C++, parameters are passed in reverse order
<li> (as we have seen,) in gcc/g++, several parameters are passed in
     registers, but generally get allocated local region space and saved there
     by callee
<li> in gcc/g++ the callee explicitly restores stack and old call frame,
     the RET instruction doesn't do that magically, it just manages to
     restore the program counter register back to the caller.
<li> In (newer versions of) G++, the parameter section is 16-byte aligned
</UL>

<h3> How <code>this</code> looks and is used inside member functions </h3>

<ul>
<li> it is the first parameter, so it is passed in %rdi
<li> g++ seems to reserve local memory space and copy/save the registers
     into that local memory space for ALL parameters passed in registers, so
     it does that for <code>this</code>
<li> it may make it more likely that you run out of registers to pass all your
     parameters in, and are passing later regular paramters on the stack.
<li> references (through <code>this</code>) to member variables are done using
     the "usual" indirect addressing mode, which takes an optional small
     constant as a byte offset when reading/writing using a pointer.  If the
     <code>this</code> pointer is in %rax and our byte offset for a member
     variable is 8, then <code>8(%rax)</code> is the assembler syntax to
     read or write to that variable.
</ul>


<h3> About name mangling in C++ vs. your compiler </h3>

<ul>
<li> C++ has to name mangle because it does function overloading.
<li> your compiler doesn't have to use the C++ _Znwm, it can call
     <code>malloc()</code> for all I care
<li> your compiler almost doesn't have to name mangle at all, what
     is the exception?
</ul>


<h3>More about LEAL</h4>

In a previous example, complicated arithmetic drove GCC to start
"leal'ing".
<ul>
<li>leal (load effective address) is a complex instruction usually used for
pointer arithmetic, i.e. its output is usually a pointer.
<li> due to x86 CISC addressing modes, leal can actually add two registers,
multiplying one of those registers by 1, 2, 4, or 8, and then adding
a constant offset in as well.  It is a "more than 3 address instruction".
<li> the instruction selection module of gcc knows it can be used for
addition.
<li>Unlike "add" instruction, it does not set the condition flag,
<li>This property might allow it to execute in parallel with some
other arithmetic operation that <em>does</em> use the condition flag.
So sure enough: it (potentially) improves superscalar execution, and
gcc/g++ are smart enough to use it instead of ADD sometimes.
</ul>
<p>

Lastly (for now) consider:
<pre>
   a = ((a+b)*(c+d))+(((e+f)*(g+a))/(c*e));
</pre>
The division instruction adds new wrinkles.  It operates on an implicit
register accumulator which is twice as many bits as the number you divide
by, meaning 64 bits (two registers) to divide by a 32-bit number.  Note
in this code that gcc would rather spill than use %ebx.  %ebx is
reserved by the compiler for some good reason such as to remember the
current procedure frame.  %edi and %esi are similarly ignored/not used.
<table border>
<tr>
<th> 32-bit <th> 64-bit
<tr>
<td>
<pre>
	movl	b, %eax
	movl	a, %edx
	addl	%eax, %edx
	movl	d, %eax
	addl	c, %eax
	movl	%edx, %ecx
	imull	%eax, %ecx
	movl	f, %eax
	movl	e, %edx
	addl	%eax, %edx
	movl	a, %eax
	addl	g, %eax
	imull	%eax, %edx
	movl	c, %eax
	imull	e, %eax
	movl	%eax, -4(%ebp)
	movl	%edx, %eax
	cltd
	idivl	-4(%ebp)
	movl	%eax, -4(%ebp)
	movl	-4(%ebp), %edx
	leal	(%edx,%ecx), %eax
	movl	%eax, a
</pre>
<td>
<pre>
	pushq	%rbx
	subq	$88, %rsp
	movq	$1, -72(%rbp)
	movq	$2, -64(%rbp)
	movq	$3, -56(%rbp)
	movq	$4, -48(%rbp)
	movq	$5, -40(%rbp)
	movq	$6, -32(%rbp)
	movq	$7, -24(%rbp)
	movq	-64(%rbp), %rax
	movq	-72(%rbp), %rdx
	leaq	(%rdx,%rax), %rcx
	movq	-48(%rbp), %rax
	movq	-56(%rbp), %rdx
	leaq	(%rdx,%rax), %rax
	imulq	%rax, %rcx
	movq	-32(%rbp), %rax
	movq	-40(%rbp), %rdx
	leaq	(%rdx,%rax), %rbx
	.cfi_offset 3, -24
	movq	-72(%rbp), %rax
	movq	-24(%rbp), %rdx
	leaq	(%rdx,%rax), %rax
	imulq	%rbx, %rax
	movq	-56(%rbp), %rdx
	movq	%rdx, %rbx
	imulq	-40(%rbp), %rbx
	movq	%rbx, -88(%rbp)
	movq	%rax, %rdx
	sarq	$63, %rdx
	idivq	-88(%rbp)
	leaq	(%rcx,%rax), %rax
	movq	%rax, -72(%rbp)
	movl	$.LC0, %eax
	movq	-72(%rbp), %rdx
	movq	%rdx, %rsi
	movq	%rax, %rdi
	movl	$0, %eax
	call	printf
	addq	$88, %rsp
	popq	%rbx
</pre>
</table>

In the 32-bit version, you finally see some register spilling.
In the 64-bit version, there is
<ul>
<li> saving a register so you can use it (%rbx)
<li> allocating a whole local region of 88 bytes
<li> storing immediate values into main memory
<li> addition by leaq'ing registers
</ul>

<p>
<font size=1> <A name=51>lecture #51</A> began here</font>
<p>


<h3> <code>LEAVE</code> instruction </h3>

In our example of using <code>new</code> we saw a LEAVE instruction before
the function returned.  LEAVE restores the frame pointer
to the caller's value, something like

<pre>
movq rsp, rbp ; set top of stack back to where caller had it
popq rbp      ; set base pointer back to saved value at (%rsp)
</pre>

Interestingly, there is a corresponding ENTER instruction, but g++ does not
tend to use it because it is slower than corresponding lower-level operations
like <code>subq $nbytes, %rsp</code>.

<h3> <A href="https://www3.nd.edu/~dthain/courses/cse40243/fall2015/intel-intro.html">Useful Link</A> from Doug Thain</h3>

For what its worth, this looks like a good overview, although professor
Thain points you at the upstart Intel's licensed version of the AMD64
reference manuals, instead of the originals.



<h3> Brief Comment on HW Resubmissions </h3>

At various points in this course you have a choice between completing/fixing
a previous homework, or working on the next homework.  But sometimes you
have to complete/fix an old homework for the next one to be implementable.
<!--
In addition to your HW#4/#5, I will accept up to 2 old/late homework
resubmissions from you from now up until the end of dead week.  I will award
full credit for such late submissions. -->
I have been accepting resubmissions this semester, to make corrections,
restoring points up to a "C" grade for a given assignment.
Please test your work prior to each resubmission; I won't be able to
just keep regrading it until it passes.


<h3> More on DIV instruction </h3>

When I looked for more, I found this
<A href="http://www.cs.uaf.edu/2009/fall/cs301/support/x86_64/index.html">
Cheat Sheet</A>, which pointed at the big books
(<A href="instructionsAM.pdf">A-M</A><A href="instructionsNZ.pdf">N-Z</A>).

<uL>
<li> The cheat sheet says div divides reg. ax by [src], ratio in ax, remainder in
dx.
<li> It also says dx must be 0 to start or you get a SIGFPE.
<li>  The big book
says your basic full-size divide instruction divides a big value stored in
a pair of registers (32 bit: EDX:EAX or 64 bit: RDX:RAX), by which point I
am thinking I have to give the general introduction to X86_64 before this
should be remotely understandable.
</ul>

<h3> Helper Function for Managing Registers </h3>

Define a <code>getreg()</code> function that returns a location L
to hold the value of x for the assignment <br>  <code>x := y op z</code>

<ol>
<li> if y is in a register R that holds the value of no other names,
AND y is not live after the execution of this instruction, THEN
return register R as your location L
<li> ELSE return an empty register for L if there is one
<li> ELSE if x has a next use in the block or op is an operator
     that requires a register (e.g. indexing), find an occupied
     register R. Store R into the proper memory location(s), update
     the address descriptor for that location, and return R
<li> if x is not used in the block, or no suitable occupied register
can be found in (3), return the memory location of x as L.
</ol>



<h3> Putting It All Together: A Simple Code Generator </h3>

<ul>
<li> Register allocation will be done only within a basic block.
     All variables that are live at the end of the block are stored
     in memory if not already there.
<li> Data structures needed:
<dl>
<dt> Register Descriptor
<dd> Keeps track of what is in each register. Consulted when a new register
is needed. All registers assumed empty at entry to a block.
<dt> Address Descriptors
<dd> Keep track of the location(s) where the current value of a name can be
found at runtime. Locations can be registers, memory addresses, or stack
displacements. (can be kept in the symbol table).
</dl>
</ul>
<p>

Example
<p>
<pre>
// make an array (12?) of these:
struct regdescrip {
   char name[12]; // name to use in codegen, e.g. "%rbx"
   int status;    // 0=empty, 1=loaded, 2=dirty, 4=live, ...
   struct address addr;
   };
// upgrade symbol table entry to use these instead of struct address
struct addr_descrip {
   int status;    // 0=empty, 1=in memory, 2=in register, 3=both
   struct reg_descrip *r; // point at an elem in reg array. could use index.
   struct address a;
   };
</pre>

<h3> Code Generation Algorithm </h3>

For each three-address statement of the form <br>
<code>x := y op z</code>:

<ol>
<li> Use <code>getreg()</code> to determine location L where the
     result of the computation <code>y op z</code> should be stored.
<li> Use the address descriptor for y to determine y', a current location for
y. If y is currently in a register, use the register as y'. If y is not already
in L, generate the instruction <code>MOV y',L</code> to put a copy of y in L.
<li> Generate the instruction <code>OP z',L</code> where z' is a current location for z.
Again, prefer a register location if z is currently in a register.
<p> Update the descriptor of x to indicate that it is in L. If L is a register,
update its descriptor to indicate that it contains x. Remove x from all other
register descriptors.
<li> If y and/or z have no next uses and are in registers, update the register
descriptors to reflect that they no longer contain y and/or z respectively.
</ol>


<h3> Register Allocation </h3>

Need to decide:
<ul>
<li> which values should be kept in registers (register allocation)
<li> which register each value should be in (register assignment)
</ul>

<h4> Approaches to Register Allocation </h4>

<ol>
<li> Partition the register set into groups that are use for different kinds
of values. E.g. assign base addrs to one group, pointers to the stack to
another, etc. <p>
Advantage: simple<br>
Disadvantage: register use may be inefficient
<li> Keep frequently used values in registers, across block boundaries. E.g.
assign some fixed number of registers to hold the most active values in each
inner loop.<p>
Advantage: simple to implement<br>
Disadvantage: sensitive to # of registers assigned for loop variables.
</ol>

<p>
<font size=1> <A name=52>lecture #52</A> began here</font>
<p>

<h3> Mailbag </h3>

<dl>
<dt>

If we have a variable that is inside of a function that is inside of a
class, would that variable address be part of the LOCAL memory region or
CLASS memory region?

<dd>

Local variables declared inside a function inside a class, are just LOCAL
region variables.  CLASS region is only for variables that are not local to
any function, the memory that is allocated per-instance (a.k.a. per-object),
not per-function-call. CLASS region variables are accessed as offsets from
a "this" pointer instead of from a base pointer register.

</dl>

<h3> End of Semester Planning </h3>

<ul>
<li> Final Exam Review: Thursday December 6
<li> Homework #6 due: Monday December 10, 9:00am
<li> Final Exam: Thursday December 13, 12:45-2:45pm
<li> Compiler Demos: by appointment, Dec 10-14
</ul>

<h3> Challenge Question we Ended with Last Time </h3>

So, how can you know what are the frequently used variables in a function?

<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>

<ul>
<li> Count the number of occurrences in source code?  (easy static analysis,
     but bad results)
<li> Do math proofs of the frequency relationships between variables
     (hard static analysis)
<li> Run the program on representative inputs, and count all uses
     of variables in that function. (dynamic analysis)
<li> Make a crude approximation or estimate (easy static analysis)
</ul>

<h3> x86_64 Floating Point </h3>

<h4> Float Operations </h4>

There is <A href="http://web.cecs.pdx.edu/~apt/cs322/x86-64.pdf">
a useful set of notes</A> from Portland State University.
Arithmetic operations on floats
have different opcodes, and results have to be stored in
floating point registers, not integer registers.

<pre>
	movsd	-56(%rbp), %xmm0
	movapd	%xmm0, %xmm1
	addsd	-48(%rbp), %xmm1
</pre>

<h4> Float Constants </h4>

Doubles are the same 64-bit size as longs.  They can be loaded into memory
or registers using the normal instructions like movq.  A spectacular x86_64
opcode named movabsq takes an entire floating point constant as an immediate
(bit pattern given as a decimal integer!) and stores it in a register.
(Q: What C code (or library function) would take your double and
produce the equivalent decimal integer string?)

<pre>
	movabsq	$4620355447710076109, %rax
	movq	%rax, -8(%rbp)
</pre>



<h3> Simple Machine Model </h3>

This model is probably relevant for selecting between equivalent sequences
of instructions but is presented here as food for thought regarding which
variables deserve to stay in registers.

<dl>
<dt> Instruction Costs
<dd> for an instruction I, cost(I) = 1 + sum(cost(operands(I))) <p>
operand costs:
<ul>
<li> if operand is a register, cost = 0
<li> if operand is memory, cost = 1
</ul>
<br>
<dt> Usage Counts
<dd> In this model, each reference to a variable x accrues a savings of
1 if x is in a register.

<ul>
<li> For each use of x in a block that is <b>not preceded by an assignment</b>
in that block, savings = 1 if x is in a register.
<li> If x is live on exit from a block in which it is assigned a value,
and is allocated a register, then we can avoid a store instruction (cost = 2)
at the end of the block. <p>

Total savings for x ~ sum(use(x,B) + 2 * live(x,B) for all blocks B)
<p>

This is very approximate, e.g. loop frequencies are ignored.
</ul>
</dl>
<p>

<h4>Cost savings flow graph example</h4>

For the following flow graph, how much savings would be earned by leaving
variables (a-f) in a register across basic blocks?
<p>
<img src="liveness.png">

<table>
<tr><th> Savings <th> B1 <th> B2 <th> B3 <th> B4 <th> Total
<tr><td>    a	 <td> 2	 <td> 1	 <td> 1	 <td> 0	 <td> 4
<tr><td>    b	 <td> 2	 <td> 0	 <td> 2	 <td> 2	 <td> 6
<tr><td>    c	 <td> 1	 <td> 0	 <td> 1	 <td> 1	 <td> 3
<tr><td>    d	 <td> 3	 <td> 1	 <td> 1	 <td> 1	 <td> 6
<tr><td>    e	 <td> 2	 <td> 0	 <td> 2	 <td> 0	 <td> 4
<tr><td>    f	 <td> 1	 <td> 2	 <td> 1	 <td> 0	 <td> 4
</table>





<h3> x86_64 Discussion </h3>

<ul>
<li> <A href="http://www.cs.cmu.edu/~fp/courses/15213-s07/misc/asm64-handout.pdf">machine level programming</A> as taught at CMU
<li> 
<A href="code.html"> Dr. J's TAC-to-x86_64 templates </A> (not finished yet)
<li>
<A href="http://www.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html">Intel Developer Manuals</A>
</ul>


<h3> For what its worth on Windows 64 </h3>

Warning: the Mingw64 compiler (and possibly other Windows 64-bit c
compilers) do not use the same memory sizes as Linux x86_64!  Beware.
If you were compatible with gcc on Linux you might not be on Windows
and vice versa.


<h3> Three Kinds of Dependence </h3>

In all three of these examples, a dependence relationship implies that
in the program semantics, the second instruction depends on the first
one in some way.
<p>

<ul>
<li>  How are they different?
<li>How do these affect, e.g., decisions about which registers are in use?
<li>What about concurrency/superscalar CPU's ?
</ul>
<p>

<table border>
<td>
<pre>
a = b + c;
...
d = a + e;
</pre>
<td>
<pre>
a = b + c;
...
b = d + e;
</pre>
<td>
<pre>
a = b + c;
...
a = d + e;
</pre>
</table>



<!--
<h3> Register Allocation and Graph Coloring </h3>

<ul>
<li> A <em>vertex coloring</em> is an assignment of labels or colors
     to each vertex of a graph such that no edge connects two identically
     colored vertices. 
<li>
A <em>k-coloring</em> of a graph G is a vertex coloring that is an assignment of one of k possible colors to each vertex of G (i.e., a vertex coloring) such that no two adjacent vertices receive the same color. 
<li>
The classic "high-powered" way to do register allocation is by
k-coloring a special kind of dependence/liveness graph of variables.
To do that, one must do a bunch of analysis to
tell which variables are live at the same time.
</ul>

<h3> Register Allocation by Graph Coloring </h3>

When a register is needed but all registers are in use, a register 
has to be freed by storing its contents in memory ("spilling"). <p>

Graph coloring is a systematic way of register allocation and managing
spills. <p>

Graph coloring uses two passes:

<dl>
<dt> Pass 1</ht>
<dd> Target machine instructions are selected as though there are an
infinite number of symbolic registers.
<dt> Pass 2
<dd> Physical registers assigned to symbolic ones in a manner that minimises
the cost of spills. This is done by constructing a <em> register-interference
graph</em> for each procedure, then k-coloring this graph (k = # of registers).
</dl>

<p>


<h3> Register Interference Graphs </h3>

<ul>
<li> nodes: "symbolic registers"
<li> there is an edge connecting two nodes if one is live when the other is
defined
<li> if there are k assignable registers, then we have to try and k-color
the interference graph.
<li> k-colorability is NP-complete in general, but the following heuristic
is efficient in practice:
<ul>
<li> if a node n has less than k neighbors, remove n and its edges from the
graph to get a new graph G': a k-coloring of G' can easily be extended to a
k-coloring of the original graph.
<li> By repeating this process, we either get the empty graph (in which case
we can work backwards to produce a k-coloring of the original graph), or we
get a graph where each node has &gt;= k neighbors: in this case we need to
spill a node, modify the interference graph, and proceed as before.<p>

General rule for spills: avoid introducing code into inner loops.
</ul>
</ul>

<h3> Register Allocation Coloring Example </h3>

Courtesy of those fine folks at
<A href="http://pages.cs.wisc.edu/~cs701-1/NOTES/5.REGISTER-ALLOCATION.html#coloring">University of Wisconsin</A>.
<p>

Their way of thinking about register interference is to define
<em>live ranges</em> === set of all nodes (in a control flow graph)
between definitions and uses.
Actually, feels more like it works back from uses to their definitions,
and merges all overlaps on any given variable.
<p>

OK, so what live ranges occur in the following graph? <p>

<img src="ralloc.gif"><p>

Each live range is one node in a register interference graph, and edges
(denoting interference) connect nodes whose underlying CFG nodesets overlap.
-->

<h3> Review of x86_64 Calling Conventions </h3>

64-bit x86 was first done by AMD and licensed afterwards by Intel, so it
is sometimes referred to as AMD64.  Warning: Linux and Windows do things
a lot different!

<ul>
<li> <A href="http://en.wikipedia.org/wiki/Calling_convention">Calling conventions</A> in general
</ul>

<p>
<font size=1> <A name=53>lecture #53</A> began here</font>
<p>

<h3> Final Code Generation Example </h3>

<ul>
<li> <A href="finalcg.icn">finalcg.icn</A>, a program that generates
     <A href="tac.s">native code</A>
<li> Assemble output with command line such as <code>as -o demo1.o demo1.s</code>
<li> needs streamlining, removal of exception directive code per
earlier discussion.
<!--
<li> compare previous with
     <A href="final-tac.icn">TAC-C</A>, whose output looks like
     <A href="final-tac-out.c">this</A>
-->
</ul>

<p>

<h3> Lessons From the Final Code Generation Example </h3>

<ul>
<li> TAC-to-native-code not that hard; 110 lines netted about half
     the TAC instruction set in procedure final(); many other opcodes very
     similar.
<li> Most complexity centers around calls / returns
<li> Although you pass parameters in registers, IF YOU CALL ANYTHING, and
     IF YOU USE YOUR PARAMETERS AFTERWARDS, you will
     have to allocate space on the stack for your incoming parameters,
     and save their values to memory before reusing that register.
<li> How hard would it be, for each function body, to determine whether it
     calls anything, or is a "leaf" function that does not?  How common are
     such leaf functions?
<li> Interesting special case: does a function ever turn around and call
     another function with the same parameters?  How often?  Under what
     circumstances might a compiler exploit this?
</ul>

<h3> Reverse Engineering, gcc -S, and Optimization </h3>

I decided to fill in a missing piece of the
<a href="code.html">x86_64 final code generation template page</a>
that I am providing you, and chose a real easy one: <code>if !x goto L</code>.
I figured it would be a two-instruction analogue of <code>if x goto L</code>.
So I constructed a simple program to try and produce the desired code.

<pre>
#include <stdio.h>
int fac(long y)
{
   long x;
   if (!y) goto L;
   printf("hello");
 L:
   return 1;
}
</pre>

<p>
I was frustrated to find seemingly idiotic code as gcc's default: it was
generating an extra jump and an extra label. Eventually, I tried it with -O
just to see what we would get.

<p>

The corresponding gcc -S output is as follows:

<p>

<table border>
<tr><th>gcc -S<th>gcc -O -S
<tr><td>
<pre>
	.file	"foo.c"
	.section	.rodata
.LC0:
	.string	"hello"
	.text
	.globl	fac
	.type	fac, @function
fac:
.LFB0:
	.cfi_startproc
	pushq	%rbp
	.cfi_def_cfa_offset 16
	.cfi_offset 6, -16
	movq	%rsp, %rbp
	.cfi_def_cfa_register 6
	subq	$16, %rsp
	movq	%rdi, -8(%rbp)
	cmpq	$0, -8(%rbp)
	jne	.L2
	jmp	.L3
.L2:
	movl	$.LC0, %edi
	movl	$0, %eax     # num of float args, for vararg funcs
	call	printf
.L3:
	movl	$1, %eax
	leave
	.cfi_def_cfa 7, 8
	ret
	.cfi_endproc
.LFE0:
	.size	fac, .-fac
	.ident	"GCC: (GNU) 4.8.5 20150623 (Red Hat 4.8.5-28)"
	.section	.note.GNU-stack,"",@progbits
</pre>
<td>
<pre>
	.file	"foo.c"
	.section	.rodata.str1.1,"aMS",@progbits,1
.LC0:
	.string	"hello"
	.text
	.globl	fac
	.type	fac, @function
fac:
.LFB11:
	.cfi_startproc
	testq	%rdi, %rdi
	je	.L4
	subq	$8, %rsp
	.cfi_def_cfa_offset 16
	movl	$.LC0, %edi
	movl	$0, %eax     # num of float args, for vararg funcs
	call	printf
.L2:
	movl	$1, %eax
	addq	$8, %rsp
	.cfi_def_cfa_offset 8
	ret
.L4:
	movl	$1, %eax
	ret
	.cfi_endproc
.LFE11:
	.size	fac, .-fac
	.ident	"GCC: (GNU) 4.8.5 20150623 (Red Hat 4.8.5-28)"
	.section	.note.GNU-stack,"",@progbits
</pre>
</table>


<h3> Flow Graphs </h3>

In preparation for lectures discussing code optimization, a more detailed
discussion of flow graphs is needed.

<ul>
<li>  A flow graph is a graph in which vertexes are basic blocks
<li> There is a distinguished <em>initial</em> node, the basic block
whose leader is the first instruction.
<li> There is a directed edge from block B<sub>1</sub> to B<sub>2</sub> if:
<ol>
<li> There is a conditional or unconditional jump from the last statement
     of B<sub>1</sub> to the first statement of B<sub>2</sub>
<li> B<sub>2</sub> immediately follows B<sub>1</sub> in the order of the
     program, and B<sub>1</sub> does not end in an unconditional jump.
</ol>
</ul>

<h3> Flow Graph Example </h3>

<pre>
if (x + y &lt;= 10 &amp;&amp; x - y &gt;= 0) x = x + 1;
</pre>

Construct the flow graph from the basic blocks

<p>

<table border>
<tr><td><pre>

t<sub>1</sub> := x + y
if t<sub>1</sub> &gt; 10 goto L1

</pre>
<tr><td><pre>

t<sub>2</sub> := x - y
if t<sub>2</sub> &lt; 0 goto L1

</pre>
<tr><td><pre>

t<sub>3</sub> := x + 1
x := t<sub>3</sub>

</pre>
<tr><td><pre>

L1:

</pre>
</table>

<h3> Next-Use Information </h3>

<dl>
<dt> use of a name
<dd> consider two statements
<pre>
I1: x := ... /* assigns to x */
...
I2: ... := ... x ... /* has x as an operand */
</pre>
such that control <em>can</em> flow from I1 to I2 along some path that has no
intervening assignments to x.  Then, I2 <em>uses</em> the value of x
computed at I1. I2 may use several assignments to x via different paths.

<dt> live variables
<dd> a variable x is <em>live</em> at a point in a flow graph if the
value of x at that point is <em>used</em> at a later point.

</dl>

<h3> Computing Next-Use Information (within a block only)</h3>

<ul>
<li> assume we know which names are live on exit from the block
 (needs dataflow analysis; else assume all nontemporary variables
  are live on exit)
<li> scan backwards from the end of the basic block. For each statement
<pre>
 i:  x := y <em>op</em> z
</pre>
do:
<ol>
<li> attach to stmt. i the current information (from symbol table) about
next use and liveness of x, y, and z
<li> in the symbol table, set x to "not live", "no next use"
<li> in the symbol table, set y and z to "live", set next use of y,z to i
<li> treatment of <code>x := y</code> or <code>x := op y</code> is similar
</ol>
Note: order of (2) and (3) matters, x may be on RHS as well
</ul>

<h3> Storage for Temporaries </h3>

<ul>
<li> size of activation records grows with the number of temporaries, so
compiler should try to allocate temporaries carefully
<li> in general, two temporaries can use the same memory location if they
are not live simultaneously
<li> allocate temporaries by examining each in turn and assigning it the
first location in the field for temporaries that does not contain a live
temporary. If a temporary cannot be assigned to a previously created
location, use a new location.
</ul>

<p>
<font size=1> <A name=54>lecture #54</A> began here</font>
<p>

<h3> Storage for Temporaries Example </h3>

Consider the following (a dot-product code) example. This is a single basic
block, subdivided using the liveness of some non-overlapping temporary
variables.  <p>

<table border>
<tr><td>
t1 live<td>
<pre>
	prod := 0
	i := 1
L3:	t1 := 4 * i
	t2 := a[t1]
</pre>
<tr><td>t3 live<td>
<pre>
	t3 := 4 * i
	t4 := b[t3]
</pre>
<tr><td>t5 live<td>
<pre>
	t5 := t2 + t4
	t6 := prod + t5
</pre>
<tr><td>t7 live<td>
<pre>
	prod := t6
	t7 := i + 1
	i := t7
</pre>
<tr><td><td>
<pre>
	if i &lt;= 20 goto L3
</pre>
</table>

<p>
t1, t3, t5, t7 can share the same location.
What about t2, t4, and t6?
<p>

Notes:
<ul>
<li> the "reusing temporary variables" problem is pretty much the
     same as the register allocation problem
<li> optimal allocation is NP-complete in general
</ul>





<!--
<h3> Peek at <a href="libctab.h">libctab.h</A> and <A href="libctab.c">libctab.c</A></h3>

<ul>
<li> Did you know that when you invoke the C compiler, you get a
library (-lc) linked in by default even when you did not ask for it?
<li> Similarly, ct can invoke the linker including libctab.o automatically
<li> By the way, in real life a libtab would need to have weirder variable
     names, such as all beginning with __ct__
<li> Using C++ for libctab would make certain aspects better
     (package to protect namespace, destructors to free local tables...)
     but beyond the scope of this class.
</ul>
-->



<h3> <A name="dag">DAG</A> representation of basic blocks </h3>

This concept is useful in code optimization.  Although we are not doing a
homework on optimization, you should understand it to be essential in real
life and have heard and seen a bit of the terminology.


<ul>
<li> Each <em>node</em> of a flow graph (i.e. basic block)
can be represented by a directed acyclic graph (DAG).
<li> Why do it?  May enable optimizations...
</ul>
<p>

A DAG for a basic block is one with the following labels on nodes:

<ol>
<li> leaves are labelled by unique identifiers, either variable names or
constants.
<li> interior nodes are labelled by operator symbols
<li> nodes are optionally given a sequence of identifiers as labels
(these identifiers are deemed to have the value computed at that node).
</ol>

<p>

<h4>Example</h4>

For the three-address code

<pre>
L:	t1 := 4 * i
	t2 := a[t1]
	t3 := 4 * i
	t4 := b[t3]
	t5 := t2 * t4
	t6 := prod + t5
	t7 := i + 1
	i := t7
	if i &lt;= 20 goto L
</pre>

What should the corresponding DAG look like?

<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>


<ul>
<li> Chapter 6 of the text presents DAGs constructed from syntax
     trees immediately before, rather than after, three address code.
<li> We presented it later than that, because it enables common optimizations.
</ul>

<h3> Constructing a DAG </h3>

<u>Input</u>: A basic block.
<p>

<u>Output</u>: A DAG for the block, containing:
<ul>
<li> a label for each node, and
<li> for each node, a (possibly empty) list of attached identifiers
</ul>
<p>

<u>Method</u>: Consider an instruction x := y op z.
<ol>
<li> If node(y), the node in the DAG that represents the value of y at that
point, is undefined, then create a leaf labelled y. Let node(y) be this node.
Similar for z.

<li> determine if there is a node labelled <u>op</u> with left child node(y)
and right child node(z).  if not, create such a node. let this node be <u>n</u>

<li> <ul>
     <li> a) delete x from the list of attached identifiers for node(x) [if defined]
     <li> b) append x to the list of attached identifiers for node n (from 2).
     <li> c) set node(x) to n
     </ul>
</ol>

<h3> Applications of DAGs </h3>

<ol>
<li> automatically detects common subexpressions
<li> can determine which identifiers have their value used in the block --
these are identifiers for which a leaf is created in step (1) at some  point.
<li> Can determine which statements compute values that could be used outside
the block -- these are statements s whose node n constructed in step (2)
still has node(x)=n at the end of the DAG construction, where x is the
identifier defined by S.
<li> Can reconstruct a simplified list of 3-addr instructions, taking advantage
of common subexpressions, and not performing copyin assignments of the form
x := y unless really necessary.
</ol>

<h3> Evaluating the nodes of a DAG </h3>

<ul>
<li> The evaluation order of the interior nodes of a DAG must be consistent
with a topological sort of the DAG, so that operands are evaluated before an
operator is applied.
<li> In the presence of pointer or array assignments, or procedure calls, not
every topological sort may be permissible.
<th> Example: given a basic block
<pre>
x := a[i]
a[j] := y
z := a[i]
</pre>
</ul>

The "optimized" basic block after DAG construction and common subexpression
elimination equates x and z, but this behaves incorrectly when i = j.



<h3> Code Optimization </h3>

There are major classes of optimization that can significantly speedup
a compiler's generated code.  Usually you speed up code by doing the
work with fewer instructions and by avoiding unnecessary memory reads
and writes. You can also speed up code by rewriting it with fewer gotos.


<h4> Constant Folding </h4>

Constant folding is performing arithmetic at compile-time when the values
are known.  This includes simple expressions such as 2+3, but with more
analysis
some variables' values may be known constants for some of their uses.
<pre>
     x = 7;
     ...
     y = x+5;
</pre>

<h4> Common Subexpression Elimination </h4>

Code that redundantly computes the same value occurs fairly frequently,
both explicitly because programmers wrote the code that way, and implicitly
in the implementation of certain language features.
<p>

Explicit:
<pre>
    (a+b)*i + (a+b)/j;
</pre>

The (a+b) is a common subexpression that you should not have to compute twice.
<p>

Implicit:
<pre>
    x = a[i]; a[i] = a[j]; a[j] = x;
</pre>

Every array subscript requires an addition operation to compute the memory
address; but do we have to compute the location for a[i] and a[j] twice in
this code?


<h4> Loop Unrolling </h4>

Gotos are expensive (do you know why?).  If you know a loop will
     execute at least (or exactly) 3 times, it may be faster to copy the
     loop body those three times than to do a goto.  Removing gotos
     simplifies code, allowing other optimizations.

<p>

<table border>
<tr><th>original<th>unrolled<th>after subsequent constant folding
<tr>
<td>
<pre>
for(i=0; i<3; i++) {
   x += i * i;
   y += x * x;
   }
</pre>
<td>
<pre>
   x += 0 * 0;
   y += x * x;
   x += 1 * 1;
   y += x * x;
   x += 2 * 2;
   y += x * x;
</pre>
<td>
<pre>
   y += x * x;
   x += 1;
   y += x * x;
   x += 4;
   y += x * x;
</pre>
</table>


<h3> Optimization Techniques, cont'd</h3>



<h4> Algebraic Properties </h4>

Implicit in the previous example of loop unrolling was the notion that
certain computations can be simplified by basic math properties.

<p>

<table border>
<tr>
<th> name
<th> sample
<th> optimized as
<tr>
<td> identities
<td>
<pre>
x = x * 1;
x = x + 0;
</pre>
<td>
<tr>
<td> simplification
<td>
<pre>
y = (5 * x) + (7 * x);
</pre>
<td>
<pre>
y = 12 * x;
</pre>
<tr>
<td> commutativity
<td>
<pre>
y = (5 * x) + (x * 7);
</pre>
<td>
<pre>
y = (5 * x) + (7 * x);
</pre>
<tr>
<td> strength reduction
<td>
<pre>
x = y * 16;
</pre>
<td>
<pre>
x = y << 4;
</pre>
</table>

This open-ended category might also include exploits of associativity,
distributive properties, etc.

<p>
<font size=1> <A name=55>lecture #55</A> began here</font>
<p>

<h3>Mailbag</h3>

<dl>

<dt>Could we cover assembly stack allocation/management?
<dd>
Sure. I've pointed you at a lot of resources; here is another, on
<A href="https://eli.thegreenplace.net/2011/09/06/stack-frame-layout-on-x86-64/">Eli Bendersky's site</A>.

<p>
<ul>
<li> In the general case, calling arbitrary other code,
ALL registers that hold live values across a call will have to be saved,
and restored after the call.  This sounds incredibly expensive, and is
only getting more expensive as CPUs add more and more registers. In
x86_64, the registers are partitioned into those the caller is
responsible for protecting, and those the callee is responsible for.
<li> Good compilers, then, are all about taking shortcuts and doing
the minimum needed for each specific case. A compiler can save costs
on the caller side and on the callee side.
<li> Stack registers.  As a reminder, there is an rsp
that is the true top of the stack, and a rbp that is the base pointer
register for the current function call.  The stack grows down.
</ul>

<p>


<dt>When and what do we have to push and pop from the stack
when we call a function?
<dd>
We (that mens you) should probably look at a bunch of examples, probably by
reverse engineering them with gcc -S, to get a feel for this.  A summary on
which we can expand/correct is:

<ul>
<li> caller pushes parameters.   By default the
first six parameters go into designated registers instead of main memory.
BTW, if you had anything in those registers, you have to save those values
(i.e. push them) before sticking parameters in registers for a new call.
<li> caller saves r10/r11 if it us using them.
<li> caller executes CALL instruction.
<li> CALL instruction pushes return address (IPC) and does a GOTO.
<li> Callee pushes (saves) rbp
<li> Callee sets rbp to the top of the stack
<li> Callee saves other "callee-save" registers if it uses them (rbx,r12-r15)
<li> Callee pushes/creates local region, by subtracting N bytes from rsp.
<li> Callee by default copies parameters from registers into local space.
<li> Callee executes function body.
<li> Callee stores return value in rax, if there is one
<li> Callee frees local region by adding N bytes to rsp
<li> Callee restores rbx, r12-r15 if it uses them
<li> Callee restores rsp and rbp for caller via LEAVE, or its equivalent.
<li> Callee executes RET, which pops saved IPC and does a GOTO to it.
</ul>

<dt>Can we use the stack exclusively for all of our parameters and local
variables?

<dd>
Your compiler can ignore register parameters entirely when you generate code
that calls to and returns from your own functions.  IFF your code needs to call
C library code (such as printf, reads, etc.) you would have to use the
standard calling conventions (including registers) to call those functions
successfully.


</dl>

<h4> Hoisting Loop Invariants </h4>

This one requires knowledge, perhaps too much knowledge. I know the following
optimization is safe, but does the compiler know? What would you have
to know/prove in order for this example to be "safe" for a compiler to do?
<p>

<table border>
<td>
<pre>
for (i=0; i&lt;strlen(s); i++)
   s[i] = tolower(s[i]);
</pre>
<td>
<pre>
t_0 = strlen(s);
for (i=0; i&lt;t_0; i++)
   s[i] = tolower(s[i]);
</pre>
</table>

<p>
<font size=1> <A name=56>lecture #56</A> began here</font>
<p>

<h4> Peephole Optimization </h4>

Peephole optimizations look at the native code through a small, moving
window for specific patterns that can be simplified.  These are some of the
easiest optimizations because they potentially don't require any analysis
of other parts of the program in order to tell when they may be applied.
Although some of these are stupid and you wouldn't think they'd come up,
the simple code generation algorithm we presented earlier is quite stupid
and does all sorts of obvious bad things that we can avoid.
<p>

<table border>
<tr>
<th> name
<th> sample
<th> optimized as
<tr>
<td> redundant load or store
<td>
<pre>
MOVE R0,a
MOVE a,R0
</pre>
<td>
<pre>
MOVE R0,a
</pre>
<tr>
<td> dead code
<td>
<pre>
#define debug 0
...
if (debug) printf("ugh");
</pre>
<tr>
<td> control flow simplification
<td>
<pre>
if a &lt; b goto L1
...
L1: goto L2
</pre>
<td>
<pre>
if a &lt; b goto L2
...
L1: goto L2
</pre>
</table>



<h3> Peephole Optimization Examples </h3>

It would be nice if we had time to develop a working demo program for
peephole optimization, but let's start with the obvious.

<p>

<table border>
<tr><th>as generated<th>replace with<th>comment
<tr>
<td>
<pre>
	movq	%rdi, -56(%rbp)
	cmpq	$1, -56(%rbp)
</pre>
<td>
<pre>
	movq	%rdi, -56(%rbp)
	cmpq	$1, %rdi
</pre>
<td> reuse n that's already in a register
<tr>
<td>
<pre>
	cmpq	$1, %rdi
	setle	%al
	movzbl	%al,%eax
	movq	%rax, -8(%rbp)
	cmpq	$0, -8(%rbp)
	jne	.L0
</pre>
<td>
<pre>
	cmpq	$1, %rdi
	jle	.L0
</pre>
<td> 
boolean variables are for wimps.<br>
setle sets a byte register (%al) to contain a boolean <br>
movzbl zero-extends a byte to a long (movsbl sign-extends)
<tr>
<td>
<pre>
	cmpq	$1, %rdi
	jle	.L0
	jmp	.L1
.L0:
</pre>
<td>
<pre>
	cmpq	$1, %rdi
	jg	.L1
.L0:
</pre>
<td> 
Use fall throughs when possible; avoid jumps.

<tr>
<td>
<pre>
	movq	%rax, -16(%rbp)
	movq	-16(%rbp), %rdi
</pre>
<td>
<pre>
	movq	%rax, %rdi
</pre>
<td> 
TAC code optimization might catch this sooner
<tr>
<td>
<pre>
	movq	-56(%rbp), %rax
	subq	$1, %rax
	movq	%rax, %rdi
</pre>
<td>
<pre>
	movq	-56(%rbp), %rdi
	subq	$1, %rdi
</pre>
<td> 
What was so special about %rax again?
<tr>
<td>
<pre>
	movq	%rax, -40(%rbp)
	movq	-24(%rbp), %rax
	addq	-40(%rbp), %rax
</pre>
<td>
<pre>
	addq	-24(%rbp), %rax
</pre>
<td> 
Addition is commutative.
</table>




<h4> Interprocedural Optimization </h4>

Considering memory references across procedure call boundaries;
     for example, one might pass a parameter in a register if both
     the caller and callee generated code knows about it.
<h4> argument culling </h4>
 when the value of a specific parameter is a constant, a custom version
     of a called procedure can be generated, in which the parameter is
     eliminated, and the constant is used directly (may allow additional
     constant folding).

<table border>
<td>
<pre>
f(x,r,s,1);

int f(int x, float y, char *z, int n)
{
  switch (n) {
  case 1:
     do_A; break;
  case 2:
     do_B; break;
     ...
     }
}
</pre>
<td>
<pre>
f_1(x,r,s);

int f_1(int x, float y, char *z)
{
   do_A;
}
int f_2(int x, float y, char *z)
{
   do_B;
}
...
</pre>

</table>


<h3> Code Generation for Input/Output </h3>

This section is on how to generate code for basic
C input/output constructs.

<dl>
<dt> getchar()
<dd> Basic appearance of a call to getchar() in final code:
<pre>
	call	getchar
	movl	%eax, <em>destination</em>
</pre>
     Of course, g0 does not have a getchar() function, it reads a line at
     a time.
     A built-in function for reading a line at a time might be built on
     top of this in g0 or in C, but it might be better to call a different
     input function.
<dt> <code>gets()</code> is part of the C standard that permanently encodes
a buffer overrun attack in the language for all time.  However, we could use
<code>fgets(char*,int,FILE*)</code> to implement g0's <code>read()</code> function.
<pre>
char *g0read()
{
   int i;
   char *buf = malloc(4096);
   if (buf == NULL) return NULL; // should do more
   i = fgets(buf, 4095, stdin);
   // should do more
   return buf;
}
</pre>
What-all is wrong with this picture?
<dd>
<dt> printf(s...)
<dd> First parameter is passed in %rdi. There is an "interesting"
section in the AMD64 reference manuals about how 32-bit operands are
automatically sign-extended in 64-bit registers, but 8- and 16-bit operands
are not automatically signed extended in 32-bit registers.
If string s has label .LC0
<pre>
	movl	$.LC0, %eax	; load 32-bit addr
				; magically sign-extended to 64-bits
	movq	%rax, %rdi	; place 64-bit edition in param #1 reg.
	call	printf		; call printf
</pre>

<dt> printf(s, i)
<dd> Printf'ing an int ought to be the simplest printf.
The second parameter is passed in %rsi.  If you placed a 32-bit
int in %esi you would still be OK.
<pre>
	movq	<em>source</em>, %rsi	; what we would do
	movl	<em>source</em>, %esi	; "real" C int: 32, 64, same diff
</pre>

<dt> printf(s, c)
<dd> Printf'ing a character involves passing that char as a parameter.
Generally when passing
a "char" parameter one would pass it in a (long word, aligned) slot, and
it is prudent to (basically) promote it to "int" in this slot.
<pre>
	movsbl	<em>source</em>, %esi
</pre>

<dt> printf(s, s)
<dd> Printf'ing a string involves passing that string as a parameter.
For <A href="x64/printf-s.c">local variable string constant data</A>,
gcc does
some <A href="x64/printf-s.s">pretty weird stuff</A>.
I'd kind of rather allocate the string constant out of the string
constant region and then copy it into the local region, but perhaps
calculating the contents of a string constant as a sequence of
32-bit long immediate values is an interesting exercise.

</dl>

<!--
<h3> C++ Output </h3>

Now, how about C++?  After some thought, we concluded that each output
(send) operator could be implemented by generating code for one call to
printf, with an appropriate format string for the type of the right operand.
This output is a side effect.
The expression result of the output operator is its left operand.


Potential optimizations of the preceding method for C++ output operations
include:
<ul>
<li> bundling a string of output operators into a single call to printf, or
     almost the opposite,
<li> using more direct output functions than printf, which is not famous for
     speed.  C++ may have dumped C stdio specifically because they believed
     printf's "mini-intepreter" of format strings was suboptimal.
     For example, fputc(c,stdout) is faster than printf("%c",c).
     Q: what is the fastest way to write out an integer?  What about a double?
</ul>

<h3> C++ Input Operator </h3>

Consider for a moment how to input an integer.  This is pretty fundamental;
even toy programs usually let a user enter a number.  The C program for it
might use scanf("%d", &amp;i), but in C++ one says cin &gt;&gt; i.

<table border>
<tr>
<th> "Real" <th> C-like, for 120++
<tr>
<td>
<pre>
	leaq	-8(%rbp), %rax
	movq	%rax, %rsi
	movl	$_ZSt3cin, %edi
	call	_ZNSirsERi
</pre>
<td>
<pre>
	leaq	-8(%rbp), %rax
	movq	%rax, %rsi
	movl	$.LC0, %edi
	movl	$0, %eax
	call	scanf
</pre>
</table>
-->

<!--
<h3> Implementing 120++ subset cin, cout, &lt;&lt; and &gt;&gt; </h3>

This topic is by student request. Our starting point is the goal of
providing minimal functionality necessary to produce output, so you
can tell whether generated code did anything.  In fact, let's start
with "hello world".  Consider the following sample hello.cpp program:

<pre>
#include &lt;iostream&gt;
using namespace std;

int main()
{
cout << "Hello, world\n";
}
</pre>

One of your basic design decisions is whether to use the real cin/cout,
or to write your own (toy subset) versions.

<h4> libstdc++ </h4>

If you follow g++ calling
conventions you can potentially link to and use their library, which
might save you some work.  But, g++ calling conventions are no picnic.
For the preceding "hello, world" program, the most juicy bits of the
generated assembler are:

<pre>
	.section	.rodata
.LC0:
	.string	"Hello, world\n"
	.text
.globl main
	.type	main, @function
main:
	...
	movl	$.LC0, %esi
	movl	$_ZSt4cout, %edi
	call	_ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc
</pre>

Personally, I can stomach the reference to <code>$_ZSt4cout</code>
but I am not superkeen about generating calls to functions with names
like the one in the <code>call</code> instruction here.

<h4> Homemade 120++ cout emulation </h4>

How about writing your own <code>lib120++.so</code>
and linking it in when you generate code?  Suppose that

<pre>cout &lt;&lt; s;</pre> resulted in the generated code equivalent to:

<pre>cout.out_str(s);</pre>

where <code>cout</code> in 120++ is an instance of a toy
<code>ofstream</code> class that looks like (_120ofstream.h):

<pre>
#include &lt;stdio.h&gt;
class _120_ofstream {
private:
   FILE *f;
public:
   _120_ofstream(int i);
   void out_str(char *s);
   void out_long(long l);
   void out_double(double d);
};
</pre>

The constructor parameter specifies cout (1) or cerr(2).
You would write your own implementation of this "library class",
compile with g++ and link it in and call it from your generated code.

<p>

If your compiler doesn't implement classes at all,
you might instead translate

<pre>cout &lt;&lt; s;</pre> to

<pre>_120out_str(cout, s);</pre>

where <code>cout</code> is a global variable (int, value == 1)
and the function is

<pre>
void _120out_str(int f, char *s)
{
   FILE *fp;
   if (f == 1) fp = stdout;
   else if (f == 2) fp = stderr;
   else { fprintf(stderr, "unknown output stream %d\n", f); exit(1); }
   fprintf(fp, "%s", s);
}
</pre>

You might need more output functions for other types.
g0 considers short and int to be the same as long, and float
to be the same as double.  Does it ever output char?
-->

<H3> Another Word on Interprocedural Optimization </h3>

The optimization unit of this course mentions only the
biggest categories of compiler optimization and gives very brief
examples.  That "argument culling" example of interprocedural
optimization deserves at least a little more context:

<ul>
<li> Interprocedural optimization (IPO) includes any optimizations that
     apply across function call boundaries, not just culling
<li> Because function call boundaries are what is being optimized, this
     will often focus on analysis of information known about parameters
     and return type
<li> Includes function inlining, if the compiler decides when to do that,
     rather than leave the decision up to the programmer.
<li> Can only do interprocedural optimization on procedures the compiler
     knows about; limited value unless compiling whole program together,
     or embedding in linker
<li> Modern production compilers have extra command-line options for IPO
</ul>


<h3> Comments on Debugging Assembler </h3>

The compiler writer that generates bad assembler code may need to debug
it in order to understand why it is wrong.
<ul>
<li> See <A href="http://dbp-consulting.com/tutorials/debugging/basicAsmDebuggingGDB.html">this tutorial from DBP Consulting</A> for some good ideas
<li> You almost only need to learn gdb's si and ni commands.
<li> You also need to know "as --gstabs+"
<li> You also need to know "info registers", or "i r" (e.g. "i r eax")
<li> In plain assembler debugging s and n work in lieu of si and ni
</ul>

<h3> Dominators and Loops </h3>

Raison d'etre: many/various Loop Optimizations require that loops be
specially identified within a general flow graph context.  If code is
properly structured (e.g. no "goto" statements) these loop optimizations are
safe to do, but in the general case for C you would have to check...

<dl>
<dt> dominator
<dd> node d in a flow graph <em>dominates</em> node n (written as "d dom n")
if every path from the initial node of the flow graph to n goes through d
<dt> dominator tree
<dd> tree formed from nodes in the flow graph whose root is the initial node,
and node n is an ancestor of node m only if n dominates m. Each node in a
flow graph has a unique "immediate dominator" (nearest dominator), hence a
dominator tree can be formed.
</dl>

<img src="domtree.png" width=500>

<h3> Loops in Flow Graphs </h3>

<ul>
<li> Must have a single entry point (the header) that dominates all nodes
<li> Must be a way to iterate; at least one path back to the header
<li> To find loops: look for edges a-&gt;b where b dominates a (back edges)
<li> Given a back edge n-&gt;d, the <em>natural loop</em> of this edge is
d plus the set of nodes that can reach n without going through d.
<li> every back edge has a natural loop...
</ul>



<h3> Algorithm to construct the natural loop of a back edge </h3>

Input: a flow graph <code>G</code> and a back edge <code>n -&gt; d</code> <br>
Output: the set (named <em>loop</em>) consisting of all nodes in the
natural loop of <code>n -&gt; d</code>.
<p>
Method: depth-first search on the reverse flow graph <code>G'</code>.
Start with loop containing only node <code>n</code> and <code>d</code>.
Consider each node <code>m | m != d</code> that is in
<em>loop</em>, and insert <code>m</code>'s predecessors in
<code>G</code> into <em>loop</em>. Each
node is placed once on a stack, so its predecessors will be examined.
Since <code>d</code> is put in <em>loop</em> initially, its predecessors
are not examined.

<pre>
procedure insert(m)
   if not member(loop, m) then {
      loop := loop ++ { m }
      push m onto stack
   }
end

main:
   stack := []
   loop := { d }
   insert(n)
   while stack not empty do {
      pop m off stack
      for each predecessor p of m do insert(p)
      }
</pre>

<h3> Inner Loops </h3>

<ul>
<li> If only natural loops are considered then unless two loops have the same
header, they are either disjoint or one is nested within the other.  The ones
that are nested inside other loops may be of more interest e.g. for
optimization.
<br>
<img src="innerloops0001.png" width=400>

<li> If two loops share the same header, neither is inner to the other,
instead they are treated as one loop.
<br>
<img src="innerloops0002.png" width=200>
</ul>









<h3> Code Generation for Virtual Machines </h3>

A virtual machine architecture such as the JVM changes the "final" code
generation somewhat.  We have seen several changes, some of which
simplify final code generation and some of which complicate things.

<dl>
<dt> no registers, simplified addressing
<dd> a virtual machine may omit a register model and avoid complex
     addressing modes for different types of variables
<dt> uni-size or descriptor-based values
<dd> if all variables are "the same size", some of the details of
     memory management are simplified.  In Java most values occupy
     a standard "slot" size, although some values occupy two slots.
     In Icon and Unicon, all values are stored using a same-size descriptor.
<dt> runtime type system
<dd> requiring type information at runtime may complicate the
     code generation task since type information must be present
     in generated code.  For example in Java method invocation and
     field access instructions must encode class information.
</dl>

Just for fun, let's compare the generated code for java with that X86
native code we looked at earlier when we were talking about how to make
variables spill out of registers:
<pre>
	iload_1
	iload_2
	iadd
	iload_3
	iload 4
	iadd
	imul
	iload 5
	iload 6
	iadd
	iload 7
	iload_1
	iadd
	imul
	iload_3
	iload 5
	imul
	idiv
	iadd
	istore_1
</pre>

What do you see?
<br><br><br><br><br><br>
<ul>
<li> Stack-machine model. Most instructions implicitly use the stack.
<li> Difference between "iload_3" and "iload 4": Java VM has special
     opcodes that run faster for first 3 locals/temporaries.
</ul>

thanks here to T. Mowry.

<h3> Preheaders </h3>

Loop optimizations often require code to be executed once before the loop.
Example: loop hoisting.

Solution: introduce a new (possibly empty) basic block for every loop.
It had to have a header anyhow; give it a preheader.

<h3> What was all that Loops/Dominators Stuff For?</h3>

<ul>
<li>You can't do the loop optimizations on malformed loops!
<li> To be safe, one must identify proper optimization-eligible "loops"
from their shape in the flow graph, not
from syntax keywords like "while" or "for".
<li> The whole flow graph for a function, then, will contain zero or more
    (usually one or more) inner, natural loops that can be worked on by
    storing in an auxiliary data structure the set of nodes (from the flow
    graph) that belong under a given header.
</ul>
<p>

Given that you find such a natural loop, you can do:

<h4> Loop Hoisting </h4>

<ul>
<li> identify loop invariant. Invariant wrt loop iff operands are defined
     outside loop or constant OR definition inside loop was itself invariant.
<li> move invariant to preheader
</ul>

Hoisting Conditions
thank you to Peter Lee

Hoisting conditions
For a loop-invariant definition
d: t = x op y
we can hoist instruction d into the loop’s pre-header if:
1. d’s block dominates all loop exits at which t is
live-out, and
2. there is only one definition of t in the loop, and
3. t is not live-out of the pre-header

<h4> Finding Loop Invariants </h4>

OK, what can you do with this:
<p>
<img src="hoisting.png">
<p>
Did you get:
<p>
<img src="hoisted.png">
<p>

Exercise: run it a few billion times; see whether hoisting a couple
operations out of the loop makes a measurable difference.  It might
not, after all... gotos are expensive.

Exercise: what is wrong with this example?

Another example (from Wikipedia loop-invariant code motion):

<pre>
for (int i = 0; i &lt; n; i++) {
    x = y + z;
    a[i] = 6 * i + x * x;
}
</pre>

One can hoise not just x = y + z; because it establishes x as invariant,
subexpression x*x (into a temp variable) can also be hoisted.


<h3> More on Runtime Systems </h3>

Every compiler (including yours) needs a runtime system.  A runtime system
is the set of library functions and possibly global variables maintained by
the language on behalf of a running program.  You use one all the time; in C
it functions like printf(), plus perhaps internal compiler-generated calls
to do things the processor doesn't do in hardware.<p>

So you need a runtime system; potentially, this might be as big or bigger a
job than writing the compiler.  Languages vary from assembler (no runtime
system) and C (small runtime system, mostly C with some assembler) on up to
Java (large runtime system, mostly Java with some C) and in even higher level
languages the compiler may evaporate and the runtime system become gigantic.
The Unicon language has a relatively trivial compiler and gigantic virtual
machine and runtime system.  Other scripting languages might have no compiler
at all, doing everything (even lexing and parsing) in the runtime system.
<p>

<!--
For your project: whatever type of output code you generate, you need a plan
for what to do about a runtime system.  And, in principle, I am not opposed
to helping with this part.  But the compiler and runtime system have to fit
together; if I write part of the BASIC runtime system for you, or we write
it together, we have to agree on things such as: what the types of
parameters and return values must look like.<p>

So, what belongs in a Color BASIC runtime system?  Anything not covered
by a three address instruction.  Looking at cocogram.y:
<ul>
<li> INPUT/PRINT
<li> READ/DATA
<li> CLEAR
<li> CLOAD/CSAVE/SKIPF
<li> CLS
<li> SET/RESET
<li> SOUND
<li> CHR$, LEFT$, MID$, RIGHT$, INKEY$
<li> ASC, INT, JOYSTK, LEN, PEEK, RND, VAL
<li> DIM
<li> string +, string compares
</ul>
<p>

What would a runtime system function look like?  It would take in and
pass out BASIC values, represented as C structs.  You would then link
this code in to your generated C or assembler code (if you generated
Java code, you would have to deal with the Java Native Interface or
else write these functions in Java).
<pre>
void PRINT(struct descrip *d)
{
   switch (d->type) {
   case INTEGER: printf("%d",d->value.ival); break;
   case REAL: printf("%f",d->value.rval); break;
   case STRING: printf("%*s",d->size,d->value.string); break;
   case ARRAY: printf("cannot print arrays"); break; /* can't get here */
   default: printf("PRINT: internal error, type %d\n", d->type);
   }
}
</pre>

Now, let's look at the "whole" runtime system:

<ul>
<li> <A href="libb.c">libb.c</A>
</ul>

<h3> More on Memory Management in the BASIC Runtime System </h3>

Arrays are interesting.  They can be used without being declared or DIM'ed.
They can only be DIM'ed once.  If you use them before they are DIM'ed, they
are implicitly DIM'ed to size 11 and can't be re-DIM'ed.
<p>
What do variables A, A(), A$, and A$() look like in memory?  How does our
runtime system make it so?
<p>
Let's take a look at DIM, in libc.c.  This DIM is for arrays of numbers.
How would you handle arrays of strings?
<p>
Can you implement STRCAT for your BASIC runtime system?
<p>
What other BASIC statements, operators, or functions allocate memory?
<p>
How would we avoid memory "leaks"?

<h3> STRCAT </h3>

So, what does your STRCAT look like?  <A href="libb.c#strcat">Here's one.</A>

<h3> GOSUBs </h3>

Our 3-address instruction set has call and return instructions, but basic
is less structured than regular procedural languages; you can GOSUB to any
line number you want.  You can't use a variable to GOSUB to line number X,
but in principle every line number could be the target of a procedure call.
<p>
If you use the "call" (3-address) instruction to do GOSUB, your native code
will have to make a clear distinction between BASIC call's and calls to
runtime system (built-in) functions.  Perhaps it is best to implement BASIC
GOSUB by pushing a "param" (the next instruction following the GOSUB) and
a "goto".  The BASIC RETURN is then a "pop" followed by a "goto".  What,
we don't have a "pop" 3-address instruction?  We do now...  the name of
"param" should probably be "push" anyhow.
<p>

Come to think of it, we've been talking about doing a call to a built-in
function such as PRINT, but that PRINT function we wrote is C code; it
doesn't do a 3-address "ret" instruction, hmmm.  How are we going to
generate the native code for the 3-address "call" instruction?
It may include an assembler call instruction, but it may also involve
instructions to handle the interface between BASIC and C.
-->
<!--
<h3> Flex SDK Comments </h3>

Adobe's Flex SDK web pages point you only at Windows binary downloads,
but if you dig further, it appears to be some big Java open source project.
<ul>
<li><A href="http://opensource.adobe.com/wiki/display/flexsdk/Setup+on+Linux">build instructions</A>
<li> You have to have a good Java and Ant (wormulon didn't, Larry seems
     to have put it on for me
<li> Warning: the SVN checkout can take HOURS on a cable modem.  Literally
     filled my laptop hard drive over several hours without completing.
     It occurs to me this might be their way of making their "open source"
     project as not-open as possible.
     Suggest you append "/trunk" to the name they say to checkout.
     Long checkout seems to be worsened by an idiotic policy of putting open
     sandbox end-user junk in the SVN repository! But also, it is big.
<li> Tried with /trunk on eternium, ran 46 minutes and then died with an
     error prior to completion
<li> Instructions say to "source setup.sh", but this did not go so well for
     me on wormulon (must be running bash, not csh). When I switched over to
     bash, complained about many missing or renamed files and died.
<li>Conclusions:
    (a) easier to just get this on a Windows machine if you have one.
    (b) example of an "open source" project that isn't really open.
</ul>
-->

<h3> Quick Look at the Implementation of Unicon </h3>

<ul>
<li> Language much higher level than C, C++, or Java, closer to Python
<li> Descended from Icon, whose Big Research Contribution was:
     integrating goal-directed evaluation into imperative programming
<li> Unicon came into existence because a tiny office in The Government
     wanted to use Icon, but needed it to be relevent to their real world
     problems: big data, analysis of large unstructured text stored in
     SQL databases.
<li> Unicon's Little Research Contributions are:
<ul>
<li> scaling Icon to large real-world problems
<li> adding OOP, concurrency, pattern type, rich high-level I/O subsystems
<li> native execution monitoring
</ul>
<li> At least Three implementations:
<ul>
<li> Virtual machine, no registers, yes built-in backtracking
<li> Optimizing compiler, generates C, backtracking turns into continuation passing
<li> Transformer, generates Java, backtracking turns into iterators
</ul>
<li> In all cases, the runtime system is far larger than the compiler!
<li> Compared with a traditional language:
<ul>
<li> no type checking in the compiler!
<li> runtime type checks (opt. compiler: type inferencing)
</ul>
</ul>

The remainder of this quick look will focus on OO features, as implementing
object-oriented language features is of broad interest.


<h3> On Double Constants in Assembler </h3>

For what its worth, I was Wrong. I claimed to one or more of you that
immediate mode instructions didn't include full 64-bit immediate constants,
but see the end of lecture #48! Earlier this semester we already noted
that x86_64 does in fact have immediate mode for 64-bits...for at least
one instruction/opcode (movabsq).  Proof by contradiction.  I note that the
double 3.1415 was represented in <A href="x64/dbl.s">output assembler</A>
by $4614256447914709615.
Just for fun, I checked my earlier cast-to-long strategy:
<pre>
#include <iostream>
using namespace std;
int main()
{
   double d;
   d = 3.1415;
   long l = *(long *)(&d);
   cout << "$" << l << endl;
}
</pre>
outputs:
<pre>
$4614256447914709615
</pre>
We win.


<h3> Tips on Invoking the Assembler and Linker from your Compiler </h3>

HW#6 calls for your compiler to produce an executable
that I can run.  But we have mainly discussed a compiler that writes out code
suitable for input to an assembler. A student requested that I give you some
tips on getting the rest of the way.

<ul>
<li> You could write a 120++ shell script that ran your compiler (named
     something else) and them ran the assembler and linker.
<li> Probably better to call assembler and linker from within your main().
<li> Probably this means invoking an external program/process from your
     program.
<li> Most standard way to do this is via system(s).  Could use popen() or
     fork()/exec()/wait() but system() is probably best.
<li> Return integer is a "status" consisting of an exit code PLUS STUFF.
     You have to use WEXITSTATUS(i) to get the process return code of 
     command s.
<li> The assembler is named as, and as mentioned you may want to use
as --gstabs+, as in
<pre>
as --gstabs+ -o foo.o foo.s
</pre>
<li> The linker is named ld, and you typically would invoke it with not
     just your own code, but also startup code to call your main(), and
     a runtime library. If your library were named lib120++.a that might
     look like:
<pre>
ld -o foo /usr/lib64/crt1.o foo.o -l120++
</pre>
<li> If you were invoking the linker ld on a "real" g++ standard library the
ld command invocation is more complex. For example in December 2017 on
wormulon (Centos) it looked like:
<pre>
ld -dynamic-linker /lib64/ld-linux-x86-64.so.2 /usr/lib64/crt1.o /usr/lib64/crti.o /usr/lib/gcc/x86_64-redhat-linux/4.4.7/crtbegin.o dbl.o /usr/lib64/libstdc++.so.6 -lc /usr/lib/gcc/x86_64-redhat-linux/4.4.7/crtend.o /usr/lib64/crtn.o
</pre>
Since this is version-specific, the "portable" way would be to use g++ as
your linker, if you are going to link in its standard C++ libraries:
<pre>
g++ dbl.o
</pre>

<li> Runtime libraries like lib120++.a are built from .o files by running
the archiver program ar, as in
<pre>
ar cr lib120++.a mylib1.o mylib2.o ...
</pre>
<li> You can expect to have to read the man pages for as, ld, ar, and system
in order to figure out options.
<li> There is a potential problem with where your
compiler should find lib120++.a, how shall we solve that?
</ul>


<h3> Imports and Inheritance in Unicon </h3>

Unicon is different from mainstream languages, and this section is not intended
to tell you what you are supposed to do, it is intended to provide a basis for
comparison.

<h4> Syntax Tree Overview </h4>

Unicon uses "iyacc", a variant of Berkeley yacc, which is a cousin of Bison.
The <A href="unigram.y">unigram.y</A> grammar has around 234 shift reduce
conflicts.  The semantic action at the import statement is illustrative of
tree construction as well as what little semantic analysis Unicon does.

<pre>
import: IMPORT implist {
   $$ := node("import", $1,$2," ")
   import_class($2)
   } ;
</pre>

For what its worth, the tree type in Unicon is very challenging and
sophisticated:
<pre>
record treenode(label, children)
procedure node(label, kids[])
   return treenode(label, kids)
end
</pre>

Actually, Unicon syntax trees are incredibly simple, except that
they are actually heterogeneous trees with a mixture
of treenode, string, token, and various class objects.

<h4> Idol.icn </h4>

Despite the generic tree, various class objects
from <A href="idol.icn">idol.icn</A> store all the
interesting stuff in the syntax tree.  It is almost
really one class per non-terminal type, and those
non-terminals that have symbol tables have a field
in the class that contains the symbol (hash) table object.
<p>

class Package (one of the only parts of idol.icn I didn't write)
tells a real interesting story.  There is both an in-memory
representation of what we know about the world, and a persistent
on-disk representation (in order to support separate compilation).

<pre>
#
# a package is a virtual syntax construct; it does not appear in source
# code, but is stored in the database.  The "fields" in a package are
# the list of global symbols defined within that package.  The filelist
# is the list of source files that are linked in when that package is
# imported.
#
class Package : declaration(files, dir, classes)
   #
   # Add to the two global tables of imported symbols from this package's
   # set of symbols.  If sym is non-null, we are importing an individual
   # symbol (import "pack.symbol").
   #
   method add_imported(sym)
      local s, f

      if /dir then return
      
      f := open(dir || "/uniclass", "dr") |
	 stop("Couldn't re-open uniclass db in " || dir)
      every s := (if \sym then sym else fields.foreach()) do {
         if member(imported, s) then
             put(imported[s], self.name)
          else {
             imported[s] := [self.name]
          }

         if fetch(f, self.name || "__" || s) then {
            if member(imported_classes, s) then
               put(imported_classes[s], self.name)
            else {
               imported_classes[s] := [self.name]
            }
         }
      }
      close(f)
   end
   method Read(line)
      self$declaration.Read(line)
      self.files := idTaque(":")
      self.files$parse(line[find(":",line)+1:find("(",line)] | "")
   end
   method size()
      return fields$size()
   end
   method insertfname(filename)
      /files := idTaque(":")
      if files.insert(filename) then {
         write(filename, " is added to package ", name)
         writespec()
         }
      else write(filename, " is already in Package ", name)
   end
   method insertsym(sym, filename)
      if fields.insert(sym) then {
         write(sym, " added to package ", name)
         writespec()
         }
      else write(sym, " is already in Package ", name)
   end
   method containssym(sym)
       return \fields.lookup(sym)
   end
   method String()
      s := self$declaration.String()
      fs := files.String()
      if *fs > 0 then fs := " : " || fs
      s := s[1: (*tag + *name + 2)] || fs || s[*tag+*name+2:0]
      return s
   end
   method writespec()
   if \name & (f := open(env,"d")) then {
      insert(f, name, String())
      close(f)
      return
      }
   stop("can't write package spec for ", image(name))
   end
initially(name)
   if name[1] == name[-1] == "\"" then {
      name := name[2:-1]
      self.name := ""
      name ? {
	 if upto('/\\') then {
	    while self.name ||:= tab(upto('/\\')) do self.name ||:= move(1)
	    }
	 self.name ||:= tab(find(".")|0)
	 }
      }
   else {
      self.name := name
      }
   if dbe := fetchspec(self.name) then {
      Read(dbe.entry)
      self.dir := dbe.dir
      }
   /tag := "package"
   /fields := classFields()
end
</pre>

<h4> fetching a specification </h4>

Given a class name, how do we find it?  It must live in a GDBM database
(uniclass) somewhere along the IPATH. A bunch of tedious string parsing
concluding with a GDBM fetch.

<pre>
#
# find a class specification, along the IPATH if necessary
#
procedure fetchspec(name)
   static white, nonwhite
   local basedir := "."
$ifdef _MS_WINDOWS_NT
   white := ' \t;'
   nonwhite := &cset -- ' \t;'
$else
   white := ' \t'
   nonwhite := &cset -- ' \t'
$endif
   name ? {
      while basedir ||:= tab(upto('\\/')) do {
	 basedir ||:= move(1)
	 }
      name := tab(0)
      # throw away initial "." and trailing "/"
      if basedir[-1] == ("\\"|"/") then basedir := basedir[2:-1]
      }
   if f := open(basedir || "/" || env,"dr") then {
      if s := fetch(f, name) then {
	 close(f)
	 return db_entry(basedir, s)
	 }
      close(f)
      }

   if basedir ~== "." then fail # if it gave a path, don't search IPATH

   ipath := ipaths()

   if \ipath then {
      ipath ? {
         dir := ""
	 tab(many(white))
	 while dir ||:= tab(many(nonwhite)) do {
	    if *dir>0 & dir[1]=="\"" & dir[-1] ~== "\"" then {
		dir ||:= tab(many(white)) | { fail }
	       }
	    else {
		if dir[1]==dir[-1]=="\"" then dir := dir[2:-1]
		if f := open(dir || "/" || env, "dr") then {
		    if s := fetch(f, name) then {
			close(f); return db_entry(dir, s) }
		    close(f)
		}
		tab(many(white))
		dir := ""
	    }
	}
     }
  }
end
</pre>

<h3> Closure-Based Inheritance </h3>

Unicon not only allows multiple inheritance, it is the only language that I
know of that can handle cycles in the inheritance graph.  It does this by
having each child be completely self-centered. When they inherit, they rifle
through their parents looking for spare change. This is a depth-first method
that completely/perfectly inherits from the first superclass (including all
its parents) and only then considers later step-parents.
<p>

Inside class Class, supers is an object that maintains an ordered list of a
class' superclasses (i.e. parents).  Variable classes is effectively a
global object that knows all the classes in the current package and let's
you look them up by name.  Variable added tracks classes already visited,
and prevents repeating any classes already on the list.

<pre>
  method transitive_closure()
    count := supers.size()
    while count > 0 do {
	added := taque()
	every sc := supers.foreach() do {
	  if /(super := classes.lookup(sc)) then
	    halt("class/transitive_closure: couldn't find superclass ",sc)
	  every supersuper := super.foreachsuper() do {
	    if / self.supers.lookup(supersuper) &
		 /added.lookup(supersuper) then {
	      added.insert(supersuper)
	    }
	  }
	}
	count := added.size()
	every self.supers.insert(added$foreach())
    }
  end
</pre>

Given that all the superclasses have been ordered, the actual inheritance
in class Class is done by a method resolve():

<pre>
  method resolve()
    #
    # these are lists of [class , ident] records
    #
    self.imethods := []
    self.ifields := []
    ipublics := []
    addedfields := table()
    addedmethods := table()
    every sc := supers.foreach() do {
	if /(superclass := classes.lookup(sc)) then
	    halt("class/resolve: couldn't find superclass ",sc)
	every superclassfield := superclass.foreachfield() do {
	    if /self.fields.lookup(superclassfield) &
	       /addedfields[superclassfield] then {
		addedfields[superclassfield] := superclassfield
		put ( self.ifields , classident(sc,superclassfield) )
		if superclass.ispublic(superclassfield) then
		    put( ipublics, classident(sc,superclassfield) )
	    } else if \strict then {
		warn("class/resolve: '",sc,"' field '",superclassfield,
		     "' is redeclared in subclass ",self.name)
	    }
	}
	every superclassmethod := (superclass.foreachmethod()).name() do {
	    if /self.methods.lookup(superclassmethod) &
	       /addedmethods[superclassmethod] then {
		addedmethods[superclassmethod] := superclassmethod
		put ( self.imethods, classident(sc,superclassmethod) )
	    }
	}
	every public := (!ipublics) do {
	    if public.Class == sc then
		put (self.imethods, classident(sc,public.ident))
	}
    }
  end
</pre>


<h3> Unicon Methods Vectors </h3>

Unicon resolves each class' inheritance information at compile time, and
generates a <em>field table</em> for runtime calculations that map field
names to slot#/offsets.  Methods vectors are just structs,
shared by objects by means of a pointer (__m) added to class instances.



<p>
<font size=1> <A name=57>lecture #57</A> began here</font>
<p>



<h3> Final Exam Review </h3>

The final exam is comprehensive, but with a strong emphasis on "back end"
compiler issues: symbol tables, semantic analysis, and code generation.


<ul>
<li>  Review your lexical analysis, regular expressions, and finite automata.
<li>  Review your syntax analysis, CFG's, and parsing.
<li>  If a parser discovers a syntax error, how can it report what line
      number that error occurs on?  If semantic analysis discovers a
      semantic error (or probable semantic error), how can it report what
      line number that error occurs on?
<li>  What are symbol tables?  How are they used?
      What information is stored there?
<li>  How does information get into a symbol table?
<li>  How many symbol tables does a compiler need?
<li>  What is "semantic analysis"?
<li>  What does "semantic analysis" accomplish? What are its side effects?
<li>  What are the primary activities of a compiler's semantic analyzer?
<li>  What are memory regions, and why does a compiler care?
<li>  What memory regions are there, and how do they affect code generation?
<li>  What does code generation do, anyhow?
<li>  What kinds of code generation are there?
<li>  Why do (almost all) compilers use an "intermediate code"?  What does
      intermediate code look like?  How is it different from final code?
</ul>

<H4><A href="sample-final.pdf">Sample Final Exam</A></h4>

This final is from a previous year and has questions specific to that
year's project.  But it gives you an idea of the kinds of questions
that appear on the final.
