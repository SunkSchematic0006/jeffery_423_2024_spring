<h2> CSE 423 Lab #11: Linked Lists of Intermediate Code </h2>

Turnin: a .zip on Canvas
<p>

This week's lab will consist of practice writing out some linked lists of
intermediate code.

<h3> Checkout this <A href="tac.h">tac.h</A> 3-address code representation</h3>

Here is a starting point. What is it missing?

<pre>
/*
 * Three Address Code - skeleton for CSE 423
 */
#ifndef TAC_H
#define TAC_H

struct addr {
  int region, offset;
};

/* Regions: */
#define R_GLOBAL 2001 /* can assemble as relative to the pc */
#define R_LOCAL  2002 /* can assemble as relative to the ebp */
#define R_CLASS  2003 /* can assemble as relative to the 'this' register */
#define R_LABEL  2004 /* pseudo-region for labels in the code region */
#define R_CONST  2005 /* pseudo-region for immediate mode constants */

struct instr {
   int opcode;
   struct addr dest, src1, src2;
   struct instr *next;
};
/* Opcodes, per lecture notes */
#define O_ADD   3001
#define O_SUB   3002
#define O_MUL   3003
#define O_DIV   3004
#define O_NEG   3005
#define O_ASN   3006
#define O_ADDR  3007
#define O_LCONT 3008
#define O_SCONT 3009
#define O_GOTO  3010
#define O_BLT   3011
#define O_BLE   3012
#define O_BGT   3013
#define O_BGE   3014
#define O_BEQ   3015
#define O_BNE   3016
#define O_BIF   3017
#define O_BNIF  3018
#define O_PARM  3019
#define O_CALL  3020
#define O_RET   3021
/* declarations/pseudo instructions */
#define D_GLOB  3051
#define D_PROC  3052
#define D_LOCAL 3053
#define D_LABEL 3054
#define D_END   3055

struct instr *gen(int, struct addr, struct addr, struct addr);
struct instr *concat(struct instr *, struct instr *);

#endif
</pre>

<h3> The Corresponding <A href="tac.c">tac.c</A> C code</h3>

<pre>
/*
 * Three Address Code - skeleton for CS 423
 */
#include <stdio.h>
#include <stdlib.h>
#include "tac.h"

struct instr *gen(int op, struct addr a1, struct addr a2, struct addr a3)
{
  struct instr *rv = malloc(sizeof (struct instr));
  if (rv == NULL) {
     fprintf(stderr, "out of memory\n");
     exit(4);
     }
  rv->opcode = op;
  rv->dest = a1;
  rv->src1 = a2;
  rv->src2 = a3;
  rv->next = NULL;
  return rv;
}

struct instr *copylist(struct instr *l)
{
   if (l == NULL) return NULL;
   struct instr *lcopy = gen(l->opcode, l->dest, l->src1, l->src2);
   lcopy->next = copylist(l->next);
   return lcopy;
}

struct instr *append(struct instr *l1, struct instr *l2)
{
   if (l1 == NULL) return l2;
   struct instr *ltmp = l1;
   while(ltmp->next != NULL) ltmp = ltmp->next;
   ltmp->next = l2;
   return l1;
}

struct instr *concat(struct instr *l1, struct instr *l2)
{
   return append(copylist(l1), l2);
}
</pre>

<h3> Lab Exercise: Hello, 3-address Code </h3>

For this lab you should write a toy 3-address program, build a linked list
of three address instructions in a hardwired dummy main() program, and
print it out.

<pre>
void write();
void main()
{
   int i;
   i = 5;
   i = i * i + 1;
   write(i);
}
</pre>

Write a main procedure that builds the linked list for something like:

<pre>
prot write
proc main,0,32
	ASN	loc:0,const:5
	MUL	loc:8,loc:0,loc:0
	ADD	loc:16,loc:8,const:1
	ASN	loc:0,loc:16
	PARAM	loc:0
	CALL	write,1,loc:24
	RETURN
</pre>

Write a tacprint() function that prints out a linked list of three-address
instructions to standard out.
