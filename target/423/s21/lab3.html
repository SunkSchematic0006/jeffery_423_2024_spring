<h2> CSE 423 Lab #3: Bison </h2>

Turnin: on Canvas in a .zip file.

<p>

<h4> 0. Preliminaries </h4>

If you haven't already, read the required Bison reading (sections 1 and 3-6
of the <A href="https://www.gnu.org/software/bison/manual/">GNU Bison Manual</A>). If that's not enough, read the Bison chapters
of the optional text (Flex and Bison) or the other optional text
(Build Your Own Programming Language).

<h4>1. Bison Basics </h4>

Download (or copy paste) the following toy Flex and Bison specifications.

<p>

<table border><tr><th>Flex <A href="nnws.l">nnws.l</A> <th>Bison <A href="ns.y">ns.y</A>
<tr><td>
<pre>
<!--#include "ns.tab.h"
-->%%
[a-zA-Z]+ { return NAME; }
[0-9]+ { return NUMBER; }
[ \t\n]+ { }
. { fprintf(stderr, "bad char\n"); }
</pre>
<td>
<pre>
%token NAME NUMBER
%%
sequence : pair sequence | ;
pair : NAME NUMBER { printf("got a name-number pair\n"); } ;
</pre>
</table>

<ol>
<li> When you run <code>flex nnws.l</code>, what output file
      does flex write?
<li> When you run <code>gcc -c lex.yy.c</code>, what do you get?
<li> When you run <code>bison ns.y</code>, what output file
      does Bison write?
<li> Devise a command line for compiling the bison output to a .o file.
     Fix warnings by added extern prototypes for yylex() and yyerror().
<li> When you run <code>bison -d ns.y</code>, what header file does Bison
     generate?
<li> Add <code>#include "ns.tab.h"</code> as a new first line to nnws.l.
     Re-run flex nnws.l and rerun gcc -c lex.yy.c
<li> Write a third module, main.c, that initializes <code>yyin</code>
     by opening whatever filename is given in argv[1]
     and then calls <code>yyparse()</code> and prints out the yyparse()
     return value to standard output with a message such as
     <code>yyparse returns 0</code>.
<li> Add a yyerror() function to main.c:
     <pre>
int yyerror(char *s) {
   fprintf(stderr, "%s\n", s); exit(1);
}</pre>
<li> Compile your main.c to main.o with <code>gcc -c main.c</code>
<li> Devise a command line for linking the lex and bison output .o files
     with main.o to make
     an executable named <code>ns</code> (short for "name sequence")
<li> Run your program on itself with <code>./ns nnws.l</code>. What does
     it write out?
<li> Run your program on an input file
     (you can name this file whatever you want) containing
<pre>
DrJ 1 Evil 0
</pre>

What does it write out?
</ol>

<h4>2. YACC (well, Bison) your HW Away</h4>

Well, you can save the "build a syntax tree"
part for later, but if you complete this lab, you should have your Flex
homework wired up to a C grammar. When it is running, you have a syntax
checker for the c113c language.

<ol>
<li> Download <A href="cgram.y">cgram.y</A>, a C grammar based on Appendix A in
    "The C Programming Language"
<li> Copy your HW2 flex specification to a file named c113c.l
<li> Modify c113c.l and cgram.y until they have the same set of TERMINAL
     symbol names.  Maybe this means renaming everything in one or the other.
     Note: cgram.y has around 80 terminal symbols. It might be missing some
     or you might be missing some. This <A href="cgramtokens.html">guide to
     interpreting cgram.y terminal symbols</A> will help you.
<li> Run bison -d on cgram.y to make a cgram.tab.h.
<li> Modify your c113c.l to #include cgram.tab.h instead of whatever previous
     terminal symbol definitions it used in HW#2.
<li> Modify your HW2 main() function to call yyparse() one time
     in place of the while
     loop that called yylex() over and over again.
<li> Test your program (now a syntax checker) on both valid c113c inputs
     like a "hello world" program, as well as on some inputs with syntax errors.
</ol>
