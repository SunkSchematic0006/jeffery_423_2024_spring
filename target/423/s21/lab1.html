<h2> CSE 423 Lab #1: Basics of C on Linux </h2>

Turnin: by literally just copying/pasting your solutions for each numbered
problem into Canvas as if you are writing one big plain ASCII document.


<h4> 1. Reading Named Files in C using <code>stdio</code> </h4>

In this class you are opening and reading files in C on Linux.  For the vast
majority this is review; if not, you will need to learn it quickly.  To do
any "standard I/O" file processing, you start by including the header:

<pre>
#include &lt;stdio.h&gt;
</pre>
This defines a data type <code>(FILE *)</code> and gives prototypes for
relevant functions.  The following code opens a file using a string filename,
reads the first character (into an int variable, not a char, so that it can
detect end-of-file; EOF is not a legal char value).
<pre>
   FILE *f = fopen(filename, "r");
   int i = fgetc(f);
   if (i == EOF) /* empty file... */
</pre>

Lab exercise: write a C program to read in a file named <code>foo.baz</code>
and print its contents to the screen. Put your solution in a file
<code>lab1_1.c</code>
<p>

What happens to your program if no file named <code>foo.baz</code> exists?
Modify your program so that it detects this situation and exits gracefully
with the message <code>foo.baz not found</code>.


<h4> 2. Command Line Argument Handling and File Processing in C </h4>

The following example is from Kernighan & Ritchie's "The C Programming
Language", page 162.  It is not necessarily considered good coding style,
but if the language inventors wrote it, we had better tolerate it.
Save this program in a file <code>lab1_2.c</code>.

<p>
<A name="sample.c">
<pre>
#include &lt;stdio.h&gt;

/* cat: concatenate files, version 1 */
int main(int argc, char *argv[])
{
   FILE *fp;
   void filecopy(FILE *, FILE *);

   if (argc == 1)
      filecopy(stdin, stdout);
   else
      while (--argc > 0)
         if ((fp = fopen(*++argv, "r")) == NULL) {
            printf("cat: can't open %s\n", *argv);
            return 1;
            }
         else {
            filecopy(fp, stdout);
            fclose(fp);
            }
   return 0;
}

void filecopy(FILE *ifp, FILE *ofp)
{
   int c;

   while ((c = getc(ifp)) != EOF)
      putc(c, ofp);
}
</pre>

Laboratory exercise: modify function <code>filecopy()</code>
so that it calls a flex-compatible
function <code>yylex()</code> (<b>which you write</b>)
to obtain characters,
in place of <code>getc()</code>. Your <code>yylex()</code> should take no
parameters, read a character from a global named <code>yyin</code> and
return it to <code>filecopy()</code>, which should print it.

<pre>
#include &lt;stdio.h&gt;
FILE *yyin;
int yylex()
{
   /* insert your code here */
}
</pre>


<h4> 3. A Brief Introduction to Make </h4>

It is not good to write a large program like a compiler as a single
source file.  For one thing, every time you make a small change, you would
need to recompile the whole program, which will end up being many thousands
of lines.  For another thing, parts of your compiler are generated by
"compiler construction tools" which will write separate files.  In any case,
this course requires you to use multiple source files, compiled
separately, and linked together to form your executable program. This
would be a pain, except we have the <code>make</code> program that
takes care of it for us.

Make uses an input file named <code>makefile</code>,
which stores in ASCII text form
a collection of rules for how to build a program from its pieces.  Each
rule shows how to build a file from its source files, or dependencies.
For example, to compile a file under C:
<pre>
foo.o : foo.c
	gcc -c foo.c
</pre>
The first line says to build <code>foo.o</code> you need <code>foo.c</code>,
and the second line,
which <em><b>must</b></em> being with a tab, gave a command-line to
execute whenever <code>foo.o</code> should be rebuilt, i.e. when it
is missing or when <code>foo.c</code> has been changed and need to
be recompiled.
<p>
The first rule in the <code>makefile</code> is what <code>make</code>
builds by default, but
note that make dependencies are recursive: before it checks whether
it needs to rebuild <code>foo.o</code> from <code>foo.c</code>
it will check whether <code>foo.c</code> needs
to be rebuilt using some other rule.  Because of this post-order
traversal of the "dependency graph", the first rule in your makefile
is usually the last one that executes when you type "make".  For a
C program, the first rule in your makefile would usually be the
"link" step that assembles objects files into an executable as in:
<pre>
compiler: foo.o bar.o baz.o
	gcc -o compiler foo.o bar.o baz.o
</pre>

There is a lot more to "make" but we will take it one step at a time.
<p>

You can read or skim the
<A href="https://www.gnu.org/software/make/manual/make.pdf">GNU make
manual</A>, particularly section 2, to learn more about make.

<!--
This
<A href="http://developers.sun.com/solaris/articles/make_utility.html">
article on Make</A>
may be useful to you.
-->
You can find useful on-line documentation
on "make" (manual page, Internet reference guides, etc) if you look.

<p>

Laboratory exercise: Copy your <code>lab1_2.c</code> program from the last
problem into a file <code>lab1_3.c</code>.
Then move your <code>yylex()</code> function into a file
<code>yylex.c</code> and create a makefile that compiles
<code>lab1_3.c</code> and <code>yylex.c</code>
separately and links them together to form an executable named
<code>lab1_3</code>. Verify that your makefile works and
that your separately-compiled program still runs as intended.


<h4> 4. Grouping Characters and Returning Categories </h4>

In real life, instead of returning characters ASCII codes
from <code>yylex()</code>, the lexical analyzer will return categories
for found groups of adjacent characters.

Laboratory exercise:
modify your <code>yylex()</code>
to return categories for groups of 1+ adjacent characters as follows:

<table>
<tr><th>category<th>return code<th>description
<tr><td>vowels     <td> 1 <td> vowels
                               a, e, i, o, or u, lower or upper case.
<tr><td>consonants <td> 2 <td> non-vowel letters
<tr><td>digits     <td> 3 <td> digits 0 through 9
<tr><td>punctuation<td> 4 <td> non-letter, non-digit, non-whitespace characters
<tr><td>whitespace <td> 5 <td> space, tab or new line chars
</table>

Turnin your modified yylex() function.  Return EOF (-1) when you get to the
end of the file.

