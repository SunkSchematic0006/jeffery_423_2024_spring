<HTML>
<HEAD>
<TITLE>Irony - Language Reference </TITLE>
</HEAD>
<BODY LINK="#0000ff" VLINK="#800080">

<br><br><br>
<br><br>
<br>

<CENTER>
<H3>
<font size=7>Irony</font><br><br>
<em> a not-very-Rusty Programming Language</em>
</H3>
<A href="http://www.cs.nmt.edu/~jeffery/">Clinton Jeffery</A>
<code><a href="mailto:clinton.jeffery@nmt.edu">clinton.jeffery@nmt.edu</A></code><br>
with input from CSE 423 students
<br><br>
<em> Draft Version 0.11, January 24, 2024. </em><br> <br>
<ul>
<li> Note: this document is posted to Canvas and replicated various places,
but as of 1/24/24 the current version is at
<A href="http://www.cs.nmt.edu/~jeffery/courses/423/ironyref.html">
  www.cs.nmt.edu/~jeffery/courses/423/ironyref.html</A> and you should
check there periodically for updates.<br>
<li> Also Note: this document is at present literally just being updated from
last year's Puny Python subset to a Rust subset, so it cannot yet be taken
  seriously.
  </ul>

<p>
<br><br>
<h2> Language Reference Manual </h2>
<br>
<strong>Abstract</strong>
</CENTER>
<p>

<blockquote>

<b>Irony</b> is a subset of the Rust Programming Language.
<b>Irony</b> is a tiny
language intended to be implemented in a compiler construction class.
This document is very much work-in-progress and we will update it as
frequently as changes require and time allows.  Check time stamps at
least weekly to see if yours is current.

</blockquote>

<br>
<br>
<br>
<br>
<br>
<center>
<A href="http://www.nmt.edu"> New Mexico Institute of Mining and Technology</A><br>
<A href="http://www.cs.nmt.edu">Department of Computer Science and Engineering</A><br>
Socorro, NM 87801 USA
</center>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>

<H3>Contents </h3>

<OL>

<LI><A HREF="#Introduction">Introduction</A></LI>
<LI><A HREF="#Lexical">Lexical Rules</A></LI>
	<UL>
	<LI> <A HREF="#Comments">Whitespace and Comments</A>
	<LI> <A HREF="#Reserved">Reserved words</A>
	<LI> <A HREF="#Operators">Operators</A>
	<li> <A HREF="#Literals">Literals</A>
	<li> <A HREF="#Punctuation">Punctuation</A>
	<LI><A HREF="#SemiColons">Semi-colons</A></LI>
	<LI><A HREF="#Identifiers">Identifiers (Names)</A></LI>
	</UL>
<LI><A HREF="#Syntax">Syntax</A></LI>
	<UL>
	<LI><A HREF="#FunctionSyntax">Function Syntax</A></LI>
	<LI><A HREF="#ControlStructures">Control Structures</A></LI>
	<LI><A HREF="#DeclarationSyntax">Variable Declaration Syntax</A></LI>
	</UL>
<LI><A HREF="#Types">Data Types and Semantics</A></LI>
	<UL>
	<LI><A HREF="#Numbers">Numbers</A></LI>
	<LI><A HREF="#Arrays">Arrays</A></LI>
	<LI><A HREF="#Strings">Strings</A></LI>
	</UL>

<LI><A HREF="#Runtime">Runtime System</A></LI>
	<UL>
	<LI><A HREF="#Functions">Built-in Functions</A></LI>
	<LI><A HREF="#Imports">Standard Modules</A></LI>
	</UL>

<LI><A HREF="#Summary">Summary</A>
</OL>
<p>
<HR>

<h2><A NAME="Introduction">1. Introduction</A></h2>

The name of the language is Irony but we will accept Irony and irony as synonyms.
The name of the Irony compiler will be <code>fec</code>,
which is short for "Irony compiler".
Broadly, <code>irony</code> will correspond roughly to
the subset of Rust that would be covered in an intro class.
The facilities that <code>irony</code> supports are interesting
enough to write some non-trivial computations in it.

<p>
<code>irony</code> programs are legal Rust programs with a .rs file extension.
A program consists of a call to a function main().
A "Hello world" program looks like:

<pre>
fn main() {
   println!("Hello, world!");
}
</pre>

<!--
The Rust import facility is severely restricted to a set of built-in system
imports used in CSE 107, which are faked in irony. -->

<p>

Rust features many basic types.
Irony supports arrays, as well as:

<pre>
i64
f64
char
bool
</pre>

<p>
We will see if we can live without tuples, but no promises yet.
<p>
  
Irony has <code>while</code> and <code>for</code> loops.  Irony's for loops are
a small subset of Rust's more general capabilities.

<pre>
   while <em>expr</em> {
      <em>statement(s)</em>
   }
   for <em>var</em> in x..y {
      <em>statement(s)</em>
   }
   for <em>var</em> in x..=y {
      <em>statement(s)</em>
   }
</pre>

<p>

Conditionals in irony consist of if statements.
An <code>else</code> branch is optional.

<pre>
if <em>expr</em> {
   <em>statement(s)</em>
   }
</pre>

Notice that there are not the usual mandatory parentheses around the
conditional expression. Irony will require the curly brackets around
the statements, except for the chained if-statements in else-if chains.
Each then-part still has to be a compound statement with curly brackets.


<code>else</code> branches are optional, indented at the same level as a
preceding if line.

<pre>
if x &lt; 0 {
   ...
  }
else {
   ...
}
</pre>

<p>

<p>

Ideally, Irony would have no pointers or references. In fact, I am not
so sure you can survive even toy Rust without some references.  So maybe
Irony has references.

<p>

When in doubt about Irony features, refer to the Rust language reference.
I will add notes below as needed.  The easiest way to get out of
having to implement something is to ask about it and negotiate.



<h3> 2. <A NAME="Lexical">Lexical Rules</A> </h3>

The lexical rules of Irony start with: the lexical rules of Rust.
<code>irony</code>
may simplify and reduce the lexical rules of Rust a bit.
<p>


<p>
<A NAME="Comments"></A><B><FONT SIZE=3>2.1 Whitespace and Comments</B></FONT>
<p>

Of the Rust whitespace characters, irony must support and implement
space, tab, carriage return, and newline.


<p>

In .rs files,
Irony should accept either a newline (UNIX style) or a
carriage return followed by a newline (MS-DOS style) as a NEWLINE.

<p>

  Irony supports Rust comments.
  Comments use // to comment from that point to the end of a line.
  Examples:
  <pre> x = 1; // single line comment
    //multiple line
    //comments
    // are just multiple separate comments</pre>
  
<p>
<A NAME="Reserved"></A><B><FONT SIZE=3>2.2 Reserved Words (Keywords)</B></FONT>
<p>

  Rust has approximately 35+3=38 regular keywords, called "strict
  keywords". Then there like 13 "reserved keywords", which might see use
  in future. Then there are like four "weak keywords".
  See <A href="https://doc.rust-lang.org/stable/reference/keywords.html">
  keywords</A> in the Rust Reference.
  The reserved words in all of Rust are shown below.
  Those not in irony have strikethrough and
  should result in a fatal error ("this Rust feature is not in irony").

<p>

  <table border>
<tr><th> Strict <th> Strict <th> Reserved <th> Weak
    <tr><td>
<pre>
<font color=red>as</font>
<font color=green>break</font>
const
<font color=red>continue</font>
<font color=red>crate</font>
<font color=green>else</font>
<font color=red>enum</font>
<font color=red>extern</font>
<font color=green>false</font>
<font color=green> fn</font>
<font color=green> for</font>
<font color=green> if</font>
<font color=red> impl</font>
<font color=green> in</font>
<font color=green> let</font>
<font color=red> loop</font>
<font color=red> match</font>
<font color=red> mod</font>
<font color=red> move</font>
<font color=green> mut</font>
</pre>
<td>
  <pre>
<font color=red> pub</font>
<font color=ref> ref</font>
<font color=green> return</font>
<font color=red> self</font>
<font color=red> Self</font>
<font color=green> static</font>
<font color=red> struct</font>
<font color=red> super</font>
<font color=red> trait</font>
<font color=green> true</font>
<font color=red> type</font>
<font color=red> unsafe</font>
<font color=red> use</font>
<font color=red> where</font>
<font color=green> while</font>
<font color=red><s> async</s></font>
<font color=red><s> await</s></font>
<font color=red><s> dyn</s></font>
</pre>

<td>
<pre>
<font color=red><s> abstract</s></font>
<font color=red><s> become</s></font>
<font color=red><s> box</s></font>
<font color=red><s> do</s></font>
<font color=red><s> final</s></font>
<font color=red><s> macro</s></font>
<font color=red><s> override</s></font>
<font color=red><s> priv</s></font>
<font color=red><s> typeof</s></font>
<font color=red><s> unsized</s></font>
<font color=red><s> virtual</s></font>
<font color=red><s> yield</s></font>
<font color=red><s>try</s></font>






<pre>

<td>
<pre>
<font color=red><s>macro_rules</s></font>
<font color=red><s>union</s></font>
<font color=red><s>dyn</s></font>














<font color=green>Green</font> = in Irony
<font color=red>Red</font> = not in Irony
<font color=black>Black</font> = not sure yet
</pre>
</table>



<p>
<A NAME="Operators"></A><B><FONT SIZE=3>2.3 Operators</B></FONT>
<p>

irony supports the following operators<p>
  
<table border>
  <tr> <td> = += -= <td> assignment. and augmented add and subtract assignments </tr>
  <tr> <td> + - * / ** // <td> binary arithmetic, int and float</tr>
  <tr> <td> % <td> binary arithmetic, int</tr>
  <tr> <td> - <td> unary negation, prefix</tr>
  <tr> <td> == != &gt; &lt; &gt;= &lt;= <td> binary comparison</tr>
  <tr> <td> &amp;&amp; || ! <td> logical AND, OR, and NOT </tr>
<!--  <tr> <td> in <td> <code>in</code> is in irony, only in restricted context
             of for-loops</tr>-->
  <tr> <td> [ ] . <td> Binary subscript and dot? Do we need any other
      operators in Irony?

</table>

<p>

Irony reports an error for operators in Rust but not in irony:
<ul>
  <li> bitwise or shift operators
    ~, &lt;&lt;, &gt;&gt; &amp;=, |=, ^=, &gt;&gt;=, &lt;&lt;=, &amp;, |, ^
<li> other augmented assignment operators, besides += and -=
</ul>



<p>
<A NAME="Literals"></A><B><FONT SIZE=3>2.4 Literals</B></FONT>
<p>

<h4>Integers</h4>
<ul>
  <li> Irony will just do decimal integer literals
  <li> unsupported formats (binary, octal, and hex) must be recognized
    and reported as lexical errors
</ul>

   <h4>Reals</h4>

   <ul>
<li> Irony can require digits on both sides of the (required) decimal
    <li> unsupported formats are recognized and reported as lexical errors
   </ul>

   <h4>Boolean</h4>

   <ul>
     <li> Rust and Irony have true and false, or was that True and False?
       Check if they are case-sensitive.
   </ul>

   <h4>Some kinda null</h4>

   <ul>
     <li> Rust has no null, but it has some lame Option&lt;T&gt; thing.
          Irony will not have that, unless we discover that we gotta have it.
   </ul>

   <h4> Strings </h4>

<ul>
  <li> Rust does default-Unicode and lets you stick a b in front of a
    string to make it a bytestring. Irony will just do bytestrings
    for everything that Rust would use strings for.
  <li> Rust uses types str and String!  str is not heap allocated; Str is.
  <li> irony allows simple string literals consisting of zero or more
       characters enclosed in double quotes
  <li> characters may be a printable character from the keyboard, or an
    escape character, see below
  <li> Rust allows multi-line strings, both plain and with leading whitespace
    on subsequent line omitted (if previous line ends with \).  Irony does
    not (need to) allow multi-line strings.
</ul>
 

<h4>Escape Sequences (Character and String Literals)</h4>

Irony supports \n, \r, \t, \', \" <br>
Irony does not support other escapes, e.g. hexadecimal (\x prefix) <br>
<font color=red>
Unsupported escapes should be recognized and report a lexical error</font>.
<p>

<!--
   <table><tr>
       <th>
Escape sequence<th>Hex value in ASCII<th>	Character represented
<tr><td>\a<td>	07<td>	Alert (Beep, Bell)
<tr><td>\b<td>	08<td>	Backspace
<tr><td>\f<td>	0C<td>	Formfeed Page Break
<tr><td>\n<td>	0A<td>	Newline (Line Feed); see notes below
<tr><td>\newline<td>	0A<td>	ignore/drop this sequence if encountered
<tr><td>\r<td>	0D<td>	Carriage Return
<tr><td>\t<td>	09<td>	Horizontal Tab
<tr><td>\v<td>	0B<td>	Vertical Tab
<tr><td>\\<td>	5C<td>	Backslash
<tr><td>\'<td>	27<td>	Apostrophe or single quotation mark
<tr><td>\"<td>	22<td>	Double quotation mark
<tr><td>\?<td>	3F<td>	Question mark (used to avoid trigraphs)
<tr><td>\ooo<td>any<td>	octal escapes
<tr><td>\xhh<td>any<td> hexadecimal escapes, not in Irony, produce lexical error
<tr><td>\uxxxx<td>any<td> Unicode, not in Irony, produce lexical error
<tr><td>\Uxxxxxxxx<td>any<td> Unicode, not in Irony, produce lexical error
<tr><td>\N{name}<td>any<td> Unicode, not in Irony, produce lexical error
</table>
-->
   
<p>
<A NAME="Punctuation"></A><B><FONT SIZE=3>2.5 Punctuation</B></FONT>
<p>

  Punctuation characters are lexemes that are supported in irony that are
  not part of other lexemes (not operators, not identifiers, not literals).

  <pre>
(  )  ,  ;  {  }  , :
  </pre>

<p>

We are doing typechecking in our irony compilers, but we aren't doing any
type inferencing. Generally, we will require type information to be present
for variables, parameters, return values, etc.

<p>

Other punctuation characters generally should be reported as generic
lexical errors. Perhaps for example the dollar sign is illegal.



<p>
<A NAME="Identifiers"></A><B><FONT SIZE=3>2.6 Identifiers</B></FONT>
<p>

Identifiers in irony are as per the C language, not Rust: a letter followed by
zero or more additional letters or ASCII digits. We will not mess with Unicode,
sorry. Irony identifiers are case-sensitive. Note that
like in C, an underscore character is a letter.

<h3> 3. <A NAME="Syntax">Syntax</A> </h3>

A good fraction of standard Rust syntax will denote constructs that are not
supported in Irony.
The easiest thing is probably to start from the whole Rust language grammar,
less the parts that have been ruled out via lexical errors, and then define
portions of it that will be unsupported and trigger an error in HW#3.

<p>
<A NAME="FunctionSyntax"></A><B><FONT SIZE=3>3.1 Function Syntax</B></FONT>
<p>

Function definitions in irony consist of an <code>fn</code> followed by
a function name, a pair of parenthesis containing an optional parameter
list, an optional return value and then a sequence of statements surrounded
by curly braces.  The parameters are comma-separated lists of zero or more
entries in the format <code><em>name</em> : <em>type</em></code>. The
function return value syntax, if present is <code>-&gt; <em>type</em></code>.
For example:

<pre>
  fn fib(n : i64) -&gt; i64 {
    if n &lt; 2 { return  1; }
    return fib(n-2) + fib(n-1);
  }
</pre>

<!--
<pre>
<em>return type</em> identifier ( <em>parameter_list</em> ) { <em>function body</em> }
</pre>
-->
  
<p>
<A NAME="ControlStructures"></A><B><FONT SIZE=3>3.2 Control Structures</B></FONT>
<p>

<pre>
if condition { }
if condition {} else {}
if condition {} else if condition {} else {}
while condition {}
for var in x..y {}
for var in x..=y {}
</pre>

  
<p>
<A NAME="Classes"></A><B><FONT SIZE=3>3.3 Structs</B></FONT>
<p>

Rust has structs, but irony does not.

<p>
<A NAME="DeclarationSyntax"></A><B><FONT SIZE=3>3.4 Declaration Syntax</B></FONT>
<p>

Rust often allows omission of types that can be inferred; Irony
requires explicit type information.
<p>


<pre>
// example of declaring a variable of a particular type
identifier : type
// example of declaring parameters and return types from functions
fn f(s : &str, age:i64) -> String {
   return format!("{} number {}", s, i);
}
</pre>


<h3><A NAME="Types">4. Data Types</A></h3>

Syntax and semantics of this document will be updated as the semester
progresses.

<p>

<A NAME="Numbers"></A><B><FONT SIZE=3>4.1 Numbers</B></FONT>
<p>

As mentioned previously Irony has int and float types.

<p>

Irony will follow Rust's rules for type promotion and/or demotion.


<p>
<A NAME="Strings"></A><B><FONT SIZE=3>4.2 Strings</B></FONT> <BR>
<p>

These are sequences of characters.
<p>

<p>
<A NAME="Lists"></A><B><FONT SIZE=3>4.3 Arrays</B></FONT> <BR>
<p>

Irony has a subset of Rust's array capabilities.
  
<p>
  

<h3><A NAME="Runtime">5. Runtime System</A></h3>

<h4><A NAME="Functions">5.1 Built-in Functions</A></h3>

irony supports a small subset of the functionality of a small subset of
Rust's standard libraries. These will include basic file I/O.

<p>

<!--
  <tr><td><td><td> random number?
  <tr><td><td><td> string stuff?
  <tr><td><td><td> ...
-->


We need to look up
the complete list of functions in Rust. Ones that
are not in Irony should be predefined to emit an error message
("Rust function X is not in Irony") and halt.

<!--
<table>
<tr><th>abs() <td> absolute value
<tr><th><s>aiter()</s> <td>
<tr><th><s>all()</s> <td>
<tr><th><s>any()</s> <td>
<tr><th><s>anext()</s> <td>
<tr><th><s>ascii()</s> <td> escaped string representation of an object
<tr><th><s>bin()</s> <td> binary string
<tr><th>bool() <td> convert x to a True or False
<tr><th><s>breakpoint()</s> <td>
<tr><th><s>bytearray()</s> <td>
<tr><th><s>bytes()</s> <td>
<tr><th><s>callable()</s> <td>
<tr><th>chr(i) <td> string character corresponding to int i.
	    In Irony i is restricted to the values 0-255, for now.
<tr><th><s>classmethod()</s> <td>
<tr><th><s>compile()</s> <td>
<tr><th><s>complex()</s> <td>
<tr><th><s>delattr()</s> <td>
<tr><th>dict() <td> create a dictionary.
<tr><th><s>dir()</s> <td>
<tr><th><s>divmod()</s> <td>
<tr><th><s>enumerate()</s> <td>
<tr><th><s>eval()</s> <td>
<tr><th><s>exec()</s> <td>
<tr><th><s>filter()</s> <td>
<tr><th>float(x) <td> convert x to a float
<tr><th><s>format()</s> <td>
<tr><th><s>frozenset()</s> <td>
<tr><th><s>getattr()</s> <td>
<tr><th><s>globals()</s> <td>
<tr><th><s>hasattr()</s> <td>
<tr><th><s>hash()</s> <td>
<tr><th><s>help()</s> <td>
<tr><th><s>hex()</s> <td>
<tr><th><s>id()</s> <td>
<tr><th>input() <td>reads a line from stdin, returns it as a string
<tr><th>int(s) <td>converts a string to an integer
<tr><th><s>isinstance()</s> <td>
<tr><th><s>issubclass()</s> <td>
<tr><th><s>iter()</s> <td>
<tr><th>len(x) <td> # of items of string, list, or dictionary x
<tr><th>list() <td> Irony might want to support a subset of list()
<tr><th><s>locals()</s> <td>
<tr><th><s>map()</s> <td>
<tr><th>max(x1,x2,...) <td> Irony supports the obvious version of max()
<tr><th><s>memoryview()</s> <td>
<tr><th>min() <td> Irony supports the obvious version of min()
<tr><th><s>next()</s> <td>
<tr><th><s>object()</s> <td>
<tr><th><s>oct()</s> <td>
<tr><th>open() <td> Irony supports a subset of open()
<tr><th>ord(c) <td> return integer code for c
<tr><th>pow(base,exp,mod) <td> raise base to the exp power
<tr><th>print() <td> Irony supports a subset of print(), including
	    print(s), print(i), print(L), which print to stdout
<tr><th><s>property()</s> <td>
      <tr><th>range(start,stop,step) <td>Irony supports a subset of range()
	      in a limited context to control for-loops only.
<tr><th><s>repr(x)</s> <td> string representation of x
<tr><th><s>reversed()</s> <td>
<tr><th>round() <td> Irony might want to support rounding of numbers.
<tr><th><s>set()</s> <td>
<tr><th><s>setattr()</s> <td>
<tr><th><s>slice()</s> <td>
<tr><th><s>sorted()</s> <td>
<tr><th><s>staticmethod()</s> <td>
<tr><th>str(x) <td> return a string version of x
<tr><th><s>sum()</s> <td>
<tr><th><s>super()</s> <td>
<tr><th><s>tuple()</s> <td>
<tr><th>type(x) <td> Irony supports a subset of type()
<tr><th><s>vars()</s> <td>
<tr><th><s>zip()</s> <td>
<tr><th><s>__import__()</s> <td>
</table>
-->

<!--
<pre>
array .get() and .set()
String.charAt(n)
String.equals(s)
String.compareTo(s)  // ? do we need both this and equals()?
String.length()
String.toString(i) vs. String.valueOf()  ??
InputStream.read()   // ? is there a better input?
System.in.read() ?
  </pre>

At Jzero Level 2, add:

<pre>
String.substring(x,y)
java.util.Random.nextInt()
java.lang.Math.abs()
java.lang.Math.max()
java.lang.Math.min()
java.lang.Math.pow()
</pre>

At Jzero Level 3, add:

<pre>
String.indexOf()
String.split()
java.lang.Math.cos()
java.lang.Math.sin()
java.lang.Math.tan()
</pre>
-->


<A name="Summary">
<H3>Summary</H3>
</A>

Sure, irony may be a toy language designed for a compiler class.
Even with only this much, it may provide a convenient notation for a
lot of simple programming tasks such as those faced by students in
introductory programming courses.

</BODY>
</HTML>
