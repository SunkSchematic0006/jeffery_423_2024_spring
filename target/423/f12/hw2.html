<h3>CS 445 Assignment 2: A Lexical Analyzer</h3>

Due: Wednesday September 12, 11:30pm<p>

In this assignment you will write a lexical analyzer in flex(1), for
the "C11" language.  For this homework, you should
attempt to do a lexical analyzer for the whole of C11, the latest
definition of the ANSI C language.  Later phases will carve out a
targeted subset as needed.

<p>

Your program executable should be named "ct".  We will explain this name
later. Your program should read in any number
of source files named on the command line and write output with one line
for each token, described below.  Compilers and related tools tend to
get used by programs such as "make" that read the process exit status
to tell whether all is well. Your program's exit status should return 0
if there are no errors, and a negative number to indicate errors. For
lexical errors, return -1.


<h3> Language Details</h3>

C11 is a modern ANSI standard descended from C99 and before that from
ANSI C and thence from K&amp;R C.  You may use as a starting point
<A href="clex.l">this lex file</A> and corresponding header
<A href="ytab.h">ytab.h</A> that I happen to have lying about
from an old research project. It probably recognizes classic ANSI C.  You
should (a) figure out how to make
this thing compile and run OK for you, (b) fix any bugs, (c) extend
with additions in C99 and C11, and (d) modify with any changes needed
to comply with the rest of this homework specification.  This document
supercedes anything you happen to see there in the code.



<h3> Lexical Attributes </h3>

In your yylex(), compute attributes for each token, and store them in a
global variable named yytoken. Note that this is not part of the lex/yacc
public interface, although it is named so as to be a recognizable extension
of said interface.  You should use the following token type, or a compatible
extension of it.
<p>
<pre>
struct token {
   int category;   /* the integer code returned by yylex */
   char *text;     /* the actual string (lexeme) matched */
   int lineno;     /* the line number on which the token occurs */
   char *filename; /* the source file in which the token occurs */
   int ival;       /* if you had an integer constant, store its value here */
   int *sval;      /* if you had a string constant, malloc space and store */
   }               /*    the string (less quotes and after escapes) here */
</pre>

<p>

In this homework your main() procedure should 
build a LINK LIST of all the token structs, each of which is created by
yylex().  In the next assignment, we will
insert all these tokens in a giant (syntax) tree.<p>

Example linked list structure:

<pre>
   struct tokenlist {
      struct token *t;
      struct tokenlist *next;
      }
</pre>

Use the malloc() function to allocate chunks of memory for structs
token and tokenlist.

<h3> yylex() and main() </h3>

Your yylex() should return a different unique integer &gt; 257 for each
reserved word, and for each other token category (identifier, integer
literal constant, string literal constant, addition operator, etc).
Numbers > 257 are required for the sake of compatibility with the
YACC parser generator tool.  For each such number, you must #define
a symbol, as in
<pre>
#define IDENTIFIER 260
</pre>
This is required for the sake of readability.
Your yylex() should return -1 when it hits end of file.
<p>

In this assignment, your program should be organized the same as in
the last assignment.  There should be (at least) two separately-compiled
.c files and a makefile. The yylex() function will be called by a main()
procedure in a loop, similar to the last assignment.  The main() 
procedure should for each token, write out a line containing the token
category (an integer &gt; 257) and lexical attributes.

<h3> Turn in... </h3>

Both a paper copy to Dr. J in class, and an electronic copy
via <pre>
cscheckin -f hw2.tar -c cs445
</pre>

If you add any new source files,
be sure you add it to the set of files that you turn in.

<h3> Example </h3>

<p>

For the input file
<p>
<table border>
<tr><td>
<pre>
int main()
{
   printf("Hello, world\n");
   return 0;
}
</pre>
</table>
<p>

your output should look something like:
<p>

<table border>
<tr><td>
<pre>
Category	Text		Lineno		Filename	Ival/Sval
-------------------------------------------------------------------------
262		int		1		hello.c
271		main		1		hello.c
290		(		1		hello.c
291		)		1		hello.c
292		{		2		hello.c
271		printf		3		hello.c
290		(		3		hello.c
271		"Hello, world\n"3		hello.c		Hello, world

291		)		3		hello.c
263		;		3		hello.c
264		return		4		hello.c
271		0		4		hello.c		0
263		;		4		hello.c
293		}		5		hello.c
</pre>
</table>


<H3> Preprocessed Input </h3>

By the way, your homework will be tested on preprocessed input, which has
been generated by the C preprocessor.  You do not have #include or #define
to deal with, you have only to do the right thing with lines like

<pre>
# 736 "/usr/include/stdio.h:" blah blah ...
</pre>

which should be treated similarly to a comment, but should set your lexical
analyzer's line number and filename appropriately for subsequent tokens.
clex.l has an example of handling these, which you may want to modify.

<h3> Wide (Multibyte) Characters </h3>

Test input is not likely to test these, but in any case, you do not have to
construct correct sval binary representations for wide characters.  They are
great but a lot of work on a subject orthogonal to our main goals.


