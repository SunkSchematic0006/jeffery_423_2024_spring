<h2> CSE 423 Lab #3: Bison </h2>

Turnin: part 1 on Canvas in a single .zip file. This includes your answers to
questions 1-12 along with your
makefile and .l/.y/.c files except not the files generated by flex and bison.

<p>

<ul>
<li> You should work individually on parts [01] and turn in
     distinct answers to part 1 questions 1-12.
<li> You may work together in teams on lab part #2.
</ul>

<h4> 0. Preliminaries </h4>

Read the required Bison reading (sections 1 and 3-6
of the <A href="https://www.gnu.org/software/bison/manual/">GNU Bison
Manual</A>). If that's not enough, read the Bison chapters of the optional
text (Flex and Bison) or the other optional text (Build Your Own Programming
Language). There are other free internet websites on YACC and Bison that
may be useful.

<h4>1. Bison Basics </h4>

Download (or copy paste) the following toy Flex and Bison specifications.

<p>

<table border><tr><th>Flex <A href="nnws.l">nnws.l</A> <th>Bison <A href="ns.y">ns.y</A>
<tr><td>
<pre>
%option noyywrap
<!--#include "ns.tab.h"
-->%%
[a-zA-Z]+ { return NAME; }
[0-9]+ { return NUMBER; }
[ \t\n]+ { }
. { fprintf(stderr, "bad char\n"); }
</pre>
<td>
<pre>
%token NAME NUMBER
%%
sequence : pair sequence | ;
pair : NAME NUMBER { printf("got a name-number pair\n"); } ;
</pre>
</table>

<ol>
<li> When you run <code>flex nnws.l</code>, what output file
      does flex write?
<li> When you run <code>gcc -c lex.yy.c</code>, what do you get?
<li> When you run <code>bison ns.y</code>, what output file
      does Bison write?
<li> Devise a command line for compiling the bison output to a .o file.
     Fix warnings by added extern prototypes for yylex() and yyerror().
<li> When you run <code>bison -d ns.y</code>, what header file does Bison
     generate?
<li> Add <code>#include "ns.tab.h"</code> to the header section of nnws.l.
     Such C code goes inside %{ ... %} marks.
     Re-run flex nnws.l and rerun gcc -c lex.yy.c
<li> Write a third module, main.c, that initializes <code>yyin</code>
     by opening whatever filename is given in argv[1]
     and then calls <code>yyparse()</code> and prints out the yyparse()
     return value to standard output with a message such as
     <code>yyparse returns 0</code>.
<li> Add a yyerror() function to main.c:
     <pre>
int yyerror(char *s) {
   fprintf(stderr, "%s\n", s); exit(1);
}</pre>
<li> Compile your main.c to main.o with <code>gcc -c main.c</code>
<li> Devise a command line for linking the lex and bison output .o files
     with main.o to make
     an executable named <code>ns</code> (short for "name sequence")
<li> Run your program on itself with <code>./ns nnws.l</code>. What does
     it write out?
<li> Run your program on an input file
     (you can name this file whatever you want) containing
<pre>
DrJ 1 Evil 0
</pre>

What does it write out?
</ol>

<h4>2. Prep for HW#3</h4>

If you complete this lab, you should have your Flex
homework wired up to a Rust-subset grammar. When it is running, you have
a syntax checker for the Irony language.

<ol>
<li> Create a new lab3/ subdirectory.
<li> Download
<A href="http://www.cs.nmt.edu/~jeffery/courses/423/rustgram.y.html">rustgram.y</A> (raw <A href="http://www.cs.nmt.edu/~jeffery/courses/423/rustgram.y">.y</A>),
 an adaptation of a Rust Grammar. You may want to commented out the whole
 grammar and then add a bit at a time in.
 The start symbol for your
 Bison grammar should probably be non-terminal <code>crate</code>.

<li> Edit rustgram.y as needed!  Figure it is highly probable that you'll
     have to hack on rustgram.y to get anything to parse correctly.  If you
     have to, you may write your own new rustgram.y from scratch!

<li> Copy in your rustlex.l flex specification from HW#2.
<li> Modify rustlex.l and rustgram.y until they have the same set of TERMINAL
     symbol names.  Maybe this means renaming everything in one or the other.
     Note: rustgram.y has a lot of terminal symbols. It might be missing some
     of yours or you might be missing some from it.
     Note that single-character operators and punctuation use their ASCII
     code as their terminal symbol code.  You are not required to adhere
     to this convention.
<li> Run bison -d on rustgram.y to make a rustgram.tab.h.
<li> Modify your rustlex.l to #include rustgram.tab.h instead of whatever
     previous terminal symbol definitions it used in HW#2.
<li> Modify your HW2 <code>main()</code> function to call
     <code>yyparse()</code> one time in place of the while
     loop that called <code>yylex()</code> over and over again.
<li> Test your program (now a syntax checker) on both valid Irony inputs
     like a "hello world" program, as well as on some inputs with syntax errors.
</ol>
