%********** Chapter 2 **********

\chapter{NIM}\label{ch:NIM}\index{NIM}\index{projects!NIM}

\section{Introduction}

This chapter introduces a program that lets the user play   NIM\index{NIM} against the computer.  NIM is an ancient and fairly simple game.  In our first version of NIM  the game starts with a set of 23 ``objects,'' players take turns removing 1, 2, or 3 of the objects.  The player forced to remove the last object loses.\footnote{This form of NIM is also known as ``poisoned cookie'' or the ``subtraction game.''  A version starting with 21 was used as an immunity challenge in the TV show \emph{Survivor: Thailand}.}    There are many variants of NIM, some of which are much more challenging than the initial version presented here.   
This is an easy game to play anytime: all it takes is a pile of small objects such as pennies, chips, stones, pencil and paper, or just a good memory.  The initial program plays poorly, but over the course of the chapter, we'll examine ways to both improve the computer's ability and to create harder variants of the game.

The NIM program reinforces the concepts introduced in the previous chapter and introduces the following new elements of programming:
\begin{tight_itemize}
   \item Conditionals: \cf{if-else}\index{conditionals}
   \item Loops: \cf{while} and \cf{do-while}\index{loops}
   \item Random numbers
\end{tight_itemize}

The \cf{if else} conditional is a slightly more sophisticated version of the basic \cf{if} conditional from the previous chapter.  \emph{Loops} are specialized commands that allow a program to do the same thing repeatedly.   Random numbers generated by a computer are actually pseudorandom numbers, a sequence of numbers that appear random, but are actually generated by a deterministic function.   Random numbers are useful for adding unpredictability to a program, such as random moves in a game or random fortunes.

%\begin{figure}
\begin{minipage}{\textwidth}
\begin{lstlisting}[language=C++,numbers = left, xleftmargin=4.0ex, basicstyle=\small,emph={num_objects,move,current_player},emphstyle = \color{\mycolor},
showstringspaces=false,
caption = {The code for NIM.  When entering this program, do not enter the line numbers.  Keywords are in bold, comments are in italics, and variables are colored maroon.}]
     /*  The game of NIM */
 #include<iostream>     // include two libraries
 #include<cstdlib>
 using namespace std;
 int main()             // main() starts the actual program 
 {
    // ---------------- Variable declarations ---------------------
    int num_objects = 23; 
    int current_player = 1; 
    int move;
    // ----------- Beginning of the main game loop ----------------
    do {                                      
       if (current_player == 1) {    // conditional: if
            cout << "Player 1 enter your move (1-3): ";  // output
            cin >> move;                 // input
            while (move < 1 || move > 3 || move > num_objects){
               cout << "Illegal move. \nEnter a new move: ";
               cin >> move;
            }
       } else {                          // else part of conditional
            do {                         // make sure move is legal
               move = 1 + rand() % 3;    // random computer move
            } while (move < 1 || move > 3 || move > num_objects);
            cout << "Computer removed " << move << endl;
       }
       num_objects = num_objects - move;  // implement the move
       cout << num_objects << " objects remaining.\n";
       current_player = (current_player + 1) % 2;  // switch players
   } while (num_objects > 0);                    
   // ------------  end of the game loop --------------------------
   cout << "Player " << current_player << " wins!!!\n";
   cin.ignore();
   cout << "\nPress enter to quit.\n";
   cin.ignore();
   return 0;
}
\end{lstlisting}\label{listing:NIM1}
\end{minipage}
%\caption{The code for NIM.  When entering this program, do not enter the line numbers.}
%\end{figure}\label{fig:NIM1}

\section{The Program}

Listing~\ref{listing:NIM1} presents the code for NIM.  Notice that the program is actually fairly short -- only 36 lines long -- and some of the lines are comments.  Enter the code into your C++ compiler.  (Note: do \emph{not} enter the line numbers along the left side of the program.  Those are just for reference.)  As the program is entered, try to figure out what the commands do.  Many of them will be familiar from the proceeding chapter.  Try to figure out how the familiar commands are being used as well as how the unfamiliar ones work.

Once the entire program has been entered, compile it.  As usual, depending on how carefully the program was entered, the compiler may generate some error messages.  Try to fix them and compile the program again.  Try applying the suggestions for fixing program errors from Interlude 1.
Once the program does compile, run it and play NIM a few times.  While playing NIM compare the program's output to the program's code.  It should be possible to recognize what many of the program statements do by watching how the program runs.  

Playing the game will also reveal that the program has some shortcomings.  It doesn't tell the player how to play.  The output messages are not always clear.  There's no sense of excitement.  A more subtle problem is that it contains \emph{magic numbers}\index{magic numbers}.  These will be explained, and fixed, later in the chapter.  These are shortcomings that will eventually be fixed.  But before modifying the program it is necessary to discuss its important elements and to analyze how it all works.


\subsection{Conditionals: \cf{if-else}}\index{conditionals}

  The \emph{if-else}\index{if@{\cf{if}}}\index{if-else@{cf{if-else}}}\index{else@{\cf{else}}} statement is slightly more complex than the
if statement introduced in the previous chapter.  The format of an if-else statement is:\\
\codefont{
if(\emph{condition}) \{\\
\hspace*{0.5cm}Execute this block of code 
\hspace*{0.5cm}if the condition is true\\
\}\\
else \{\\
\hspace*{0.5cm}Execute this block of code otherwise\\
\}\\
Always executed\\}
As in the if statement the condition is inside parentheses, following the keyword \codefont{if}, and the blocks of code within each part of the if-else statement are denoted by curly braces and are indented.  



\subsection{Loops}\index{loops}

A \emph{loop} is a block of code that is repeated until a particular stopping condition is met.  
Loops are a critical construct in programming because they allow programs to perform repetitive tasks easily.  All loops have a condition (just like conditional statements) that determines whether or not the code within the loop should be executed again. 
Every time the computer reaches the condition, it checks whether the condition is true or false.  If the condition is \emph{true}, the computer executes the instructions inside the loop again; if the condition is \emph{false}, the computer jumps to the first instruction after the loop.  

There are three common forms of loops in C++:\begin{tight_enumerate}
\item \cf{While} loop
\item \cf{Do-While} loop
\item \cf{For} loop
\end{tight_enumerate}
The first two loops, \cf{while} and \cf{do-while}, are discussed in this chapter.  The third type of loop is introduced in a later chapter.  Section~\ref{appendix:loops} of Appendix A summarizes all three types of loops.  

The simplest loop is the while loop, whose basic structure is\\
\codefont{
while(condition)\{\\
\hspace*{0.5cm} Execute this code while the condition is true\\
\}\\
Jump to the code here when the condition is false\\
}
The structure of loops and conditionals are very similar.  Both have a condition, in parentheses, and a block of code, typically defined with curly braces.  In a \cf{while} loop the condition follows the keyword \codefont{while}, and the condition is written using Boolean expressions, just like in a conditional statement.
In a loop, the code between the two curly braces gets repeated if the condition is true, and all of the code between the beginning of the loop and the end of the loop should be indented.  Lines 19-22 in the NIM program are an example of a \cf{while} loop.

A do-while loop's structure is:\\
\codefont{
do\{\\
\hspace*{0.5cm} Execute this code the first time and \\
\hspace*{0.5cm} while the condition is true\\
\}while(\emph{condition});\\
Jump to the code here when the condition is false\\
}
Notice that the condition comes at the end of the loop.  This means that the code within the loop is always executed at least once.  

\subsection{Random Numbers}\index{Random numbers}

In C++ random numbers are generated using a \emph{function}.  Functions are discussed in more detail in later chapters.  For now think of a function as a separate block of code that is called using the function's name followed by parentheses.  For example, the command \cf{functionname()} will cause the block of code called \cf{functionname} to execute.  

NIM uses a function called \cf{rand()}, line 22, which generates (pseudo)random numbers for the computer's move.  There are two important features to remember about random number generators.  The first is that because computers are strictly deterministic devices, they don't really generate random numbers.  They only generate a sequence of pseudorandom numbers.\footnote{To get truly random numbers generally requires a device  that generates random numbers from a physical process.  For example, a device that listens to static on an empty radio channel and uses the static to generate sequences of random numbers.}  Pseudorandom numbers are numbers whose distribution is similar to random numbers (but sophisticated tests can almost always distinguish between truly random and only pseudorandom numbers).

The second feature of random number generators is that the sequence of the pseudorandom numbers is always identical.  To get difference numbers the sequence must be started from a different position using a \emph{seed} value.  This is discussed in the chapter exercises.

\section{Analysis of the Code}

This section analyzes the code in Listing~\ref{listing:NIM1} line by line.  It explains how the program works and how the statements in the program can be modified or used in other programs.  The goal in analyzing the code is to understand the NIM program and to understand how the statements used in NIM can be adapted for writing other programs.

\mysubsubsection{Lines 1, 2, 5, 7, and others: Comments}
Line 1 is a block comment describing the program.  
Lines 7, 11, and 30 are full line comments using the // format.  They help to break the program into recognizable sections.
Many of the other lines, for example 2, 5, and 13, end with comments that help explain what the particular line does.  It's a good idea to add more comments, or modify the existing comments, to clarify how the program works.

\mysubsubsection{Lines 2-4: \#includes}\index{include}\index{libraries}

\begin{wrapfigure}{r}{0.5\textwidth} \vspace{-0.3cm} \framebox[\linewidth][l]{\parbox{0.96\linewidth}{\codefont{Infinite Loops}\index{infinite loops} \\
A common problem with loops is the accidental creation of infinite loops -- loops that continue forever, keeping the program from ever exiting.  This can happen if the condition for ending the loop is incorrect or if an expected value never occurs.  With the NIM program, an infinite loop often occurs if the player enters a noninteger for his or her move -- a letter or other nondigit.  Pressing \codefont{control-x} will force the program to shut down.}   }
\vspace{-0.5cm} \end{wrapfigure}

This program uses two libraries the same \codefont{iostream} library\index{iostream@{\cf{iostream}}} used in the Fortune Teller program and  the \codefont{cstdlib} library\index{cstdlib@{\cf{cstdlib}}}.  The name \codefont{cstdlib} is short for \codefont{C} \codefont{STanDard} \codefont{LIBrary}.  This library contains code that helps with a number of programming tasks.  In particular, the \codefont{cstdlib} includes the code of the \cf{rand()} function, which NIM  uses  to generate the computer's move.

\mysubsubsection{Lines 5, 6, and 36: Main}\index{main()@{\cf{main()}}}

As always \codefont{int main()} (line 5) marks the beginning of the program. 
Line 6, \{, and the matching \} on line 36, denote the block of code within \codefont{main()}.  The code in Listing~\ref{listing:NIM1}  has numerous other pairs of braces that are used to define other, nested, blocks of code. Note that each block of code is indented so that it is easier to identify.   

\mysubsubsection{Lines 8-10: Variables}\index{variables}

Lines 8-10 declare three variables that are used in the NIM program.  All three variables have the type \cf{int}.  
The variable \codefont{num\_objects} is used to store the number of objects left in the game.  The program begins by setting it equal to 23, which is the starting number of objects in the game.  This can be thought of as putting the value 23 in the ``box'' named \codefont{num\_objects}.  Later in the program, as players take objects away, the value in the box \codefont{num\_objects} is reduced (line 29).  

Similarly, line 9 declares a variable named \codefont{current\_player} of type \codefont{int} and line 10 declares a variable named \codefont{move}  of type \codefont{int}.  Notice that \codefont{current\_player} is assigned the value 1.  In contrast, \codefont{move} is not assigned any value, so its value is undefined\index{variables!undefined}.

\mysubsubsection{Lines 12 and 29: The Game Loop}\index{loops}

Lines 12 and 29 define a \cf{do-while} loop.  In a \cf{do-while}\index{do-while loop@{\cf{do-while loop}}}\index{loops!do-while loop@{\cf{do-while}}} loop the condition comes at the end of the loop (line 29) so the code within the loop is executed at least once before the condition is tested.
The condition at the end of this loop is:\\
\codefont{\}while(num\_objects > 0);}\\
which is true if the value stored in the variable \codefont{num\_objects} is larger than 0 and is false otherwise.  Thus, the code continues looping while the value of \codefont{num\_objects} is larger than 0.

Here's how the loop works: The computer reaches the \codefont{do} statement on line 12 and enters the loop, executing the instructions from line 13 to line 28.  When the computer reaches line 29, it checks whether the condition \codefont{num\_objects $>$ $0$} is \emph{true} or \emph{false}.   If \codefont{num\_objects} is larger than \cf{0}, then the condition is true and the program returns to the beginning of the loop, line 13.  If \codefont{num\_objects} is not larger than \cf{0} (i.e., it is \cf{0} or smaller) then the program continues to line 30.

Lines 21 through 23 define another do-while loop, and lines 16 through 18 define a while loop.  These will be discussed in detail later in the chapter.

\mysubsubsection{Lines 13, 20, and 25: Conditionals}

Lines 13, 20, and 25 define an if-then conditional.  An if-then conditional allows a program to choose between two options.  
Line 13 starts the conditional structure with the condition:\\
\codefont{if(current\_player == 1)}\\
When the computer reaches this line in the program, it compares \codefont{current\_player} to 1.  If they are equal (as denoted by the == sign), then the condition is true and the first block of code (lines 14-19)  is executed.  If they are not equal, then the condition is false and the second block of code (lines 21-24 and starting with the keyword \cf{else}) is executed.  Notice that the beginning and end of both blocks of code are marked by curly braces: \{ and \}.

In this case, the program is checking whether it is player 1's turn or player 2's turn.  Player 1 is the human player, so if it is player 1's turn he or she is asked to enter a legal move (lines 14-19).  Player 2 is the computer, so if it is player 2's turn, the computer generates a legal, random move (lines 21-24).

\mysubsubsection{Lines 16 and 19 and Lines 21 and 23: More Loops}

Lines 21-23 define another do-while loop and lines 16-19 define a while loop\index{loops!while@{\cf{while}}}\index{while loop@{\cf{while loop}}}.  Both loops have the same basic role: to make sure that the selected move is a legal one.  

Note how the do-while loop works.  First, the loop is ``entered'' (line 21).  The beginning of the loop is defined with the keyword \cf{do} and, as usual, all of the code within the loop is indented to make it easier to identify.  Then a value is assigned to the variable \codefont{move} (line 22).  Finally, the conditional is checked to see whether the loop should be repeated (line 23).  
This loop is repeated if the move is \emph{illegal} to give the program a chance to pick a new, legal move.  There are three ways a move could be illegal:
\begin{tight_enumerate}
\item  It could be too small (i.e., less than \cf{1})
\item OR  it could be too large (i.e., greater than \cf{3})
\item OR it could be larger than the number of remaining objects (i.e., if there are only two objects left, then you can't take away three objects).
\end{tight_enumerate}
In C++ OR is represented by \cf{||}, thus, the condition for repeating the loop is written as: \\
\codefont{(move < 1 || move > 3 || move > num\_objects)}\index{OR@{\cf{OR}}}\index{Boolean!OR@{\cf{OR}}}\\
%This condition has three parts, one for each of the possible illegal moves: less than 1, greater than 3, or greater than the remaining objects.  Because the loop should be repeated if the first condition OR the second condition OR the third condition is true, the three conditions are joined by the Boolean operator OR, which is written as $||$.  
The loop can be read as ``repeat the loop and ask for a new move if \codefont{move} is less than 1 OR if  \codefont{move} is greater than 3 OR if  \codefont{move} is greater than the value stored in the box called \codefont{num\_objects}.''  

The major difference between do-while loops and while loops (e.g., lines 16-19) is that in a while loop, the condition is tested at the beginning of the loop instead of at the end of the loop.  On lines 14 and 15, the player is prompted and enters a move. The while loop starts on line 16 by checking if the move is \emph{illegal}.  If the condition is \emph{true} (meaning the player has entered an illegal move), the program goes on to lines 17 and 18, allowing the player to enter a new move.  On line 19 (the closing \} for the while loop), the program jumps back to line 16 and rechecks the condition.  When the condition becomes \emph{false} because the player entered a \emph{valid} move, the program jumps from line 16, where it checked the condition, to line 20, the first line after the loop.  

Note that the condition for a valid move is the same for both the human player and the computer.  So, the condition, in both the while loop (line 16) and the \cf{do-while} loop (line 23) is the same.

Any type of loop can always be substituted for any other type of loop with the proper program changes.  You should never be thinking ``What kind of loop do I \emph{have} to use?'' because it is never necessary to use a specific type of loop.  Simply choose the type of loop that you think best solves a given programming problem.



From the perspective of good programming technique these two loops have the disadvantage that they contain \emph{magic numbers}\index{magic numbers}.  A magic number is simply a number that appears in the program without it being immediately clear why that number is used.  So, in the conditions on lines 16 and 23, the numbers 1 and 3 are magic numbers.  There are two problems with magic numbers.  First, they make the code hard to read.  Using a variable with a name like \codefont{minimum\_allowed\_move} would mean a lot more to someone reading the code than just the number 1.  Second, they make the text hard to change; for example, if the programmer decides that allowed moves should be 1 to 4 instead of 1 to 3, he or she has to find every instance of the ``magic numbers'' and change them.  On the other hand, if those values were stored in a variable, the programmer could just change the value of the variable in one place.  We'll look into fixing these later in the chapter.

\mysubsubsection{Lines 14, 15, 17, 18, 24, 27, and 31-34: Output and Input}
Lines 14, 17, 24, 31, and 33 are output commands.  As discussed in the previous chapter, they send data from the program to somewhere else, in this case to the screen.  The NIM Program has several output commands that are combination of literal strings and variable values.  
For example, line 24 tells the player how many objects the computer removed and line 27 tells the player how many objects remain.  As before the literal strings are in double quotes, the variables are not in double quotes, and both are separated by the pipe operator: $<<$.

On line 24 the \cf{endl} command is used to create a new line, just as it was used in the Fortune Teller program.
However, lines 17, 27, 31, and 33 use a different method to define a new line: the character sequence `\textbackslash n'\index{new line}.  Like \cf{endl} this also inserts a new line into the output, which helps to make the output easier to read.  Sequences consisting of a \textbackslash~followed by another character \emph{escape} sequences\index{escape character}\index{escape sequence}.  Other commonly useful escape sequences are \textbackslash t for tab, \textbackslash ' for a single quote,  \textbackslash\textbackslash~for a backslash, and \textbackslash '' for a double quote.  These can be used to make output easier for a user to read.
% To send double quotes to the output  In that case, you use an escape sequence\index{escape sequence}, a pair of characters where the first character is a \textbackslash.  So, to print a literal string containing double quotes you would use a string like \codefont{``\textbackslash``Here's a quote\textbackslash''''}, which would print \codefont{"Here's a quote"} with one set of double quotes.}  

Lines 15 and 18 are both input commands.  They are defined and work the same as the input commands from the Fortune Teller program.  They begin with the keyword \cf{cin}, followed by a pipe operator (pointing in the opposite direction as in output commands), followed by the variable that is going to store the value the user enters.  Note that input and output can't be mixed in one command.  Statements like:\\
\cf{cout << ``enter a number: '' >> move;}\\
will \textbf{not} work in C++.

Lines 32 and 34 are also input commands, but as discussed in the previous chapter, the input is ignored.   They are there just to make the program wait for the user to press the Enter key and end the program.

\mysubsubsection{Line 22: Selecting the computer's move}
On line 22, the computer decides how many objects it will remove on its turn.  This command includes a tricky, but very useful, bit of mathematics.  First, there is the command \codefont{rand()}.  This is another function, like main.  Functions will be discussed in detail in later chapters, but for now all that we need to know is that the \codefont{rand()}\index{random}
\index{random!rand()@{\cf{rand()}}}\index{rand()@{\cf{rand()}}} function returns a \emph{random} integer between 0 and some very large, system dependent, value.  In this case \cf{rand} is short for random, another example of programmers' (over) use of abbreviations.  

Next is the mathematical operation \cf{\% 3}.  As discussed in the previous chapter, \cf{\%} symbol is the modulus\index{modulus}\index{modulus}\index{operations!modulus} operator, which performs division and returns the \emph{remainder}.   
In this case, the program is taking a random number, dividing it by $3$, and returning the remainder.  Regardless of the value supplied by \cf{rand()} applying \cf{\% 3} will always produce a value between 0 and 2 (inclusive).  So, the command \codefont{rand() \% 3}
gives a random number between 0 and 2.  

Finally, 1 is added to that value to give a random number between 1 and 3, exactly what is needed for the program's move.\footnote{We told you that modulus is a surprisingly useful operation in programming.}  Thus, the program is going to pick random moves, between 1 and 3, with no consideration of strategy, at least for now.\footnote{You might wonder why the conditions on the computer's \cf{do-while} loop include $<$1 or $>$3, given that the random move generator on line 22 can only generate numbers between 1 and 3.  How could a number less than 1 or greater than 3 occur?  \emph{Currently} they can't, but at some point, the code could be changed in a way that introduces an error that allows the computer's move to exceed those bounds, so having the conditions in the loop doesn't hurt and might avoid future errors.}

\mysubsubsection{Line 26: The Move}
Line 26 is one of the most important lines in the entire program.  It handles the actual move by removing the selected number of objects from the current number of objects.  

\mysubsubsection{Lines 32-34: A Graceful Exit}

As in the Fortune Teller program, lines 32-34 make the program exit a bit more gracefully.  It pauses and waits for a final confirmation from the player before closing.  

\mysubsubsection{Line 35: Return}\index{return}
As in the Fortune Teller program, and all of the other programs in this text, line 35 ends the program by returning control to the operating system.  The 0 value lets the operating system know that the program exited successfully.  

\vspace{+0.25cm}
{\color{\mycolor}\noindent\hrulefill}
\section{Exercises: Modifying the Program}
It should now be generally clear how the program works.  However, to really understand the program it helps to modify it and see what effect the changes have on the program's behavior.  The suggested modifications begin with a few simple changes and then move on to more complex and more interesting ones.  Not all of the new code will be given; in many places, only suggestions about how to proceed are provided.


\mysubsubsection{Exercise 1: Modifying the Output }
A simple place to start is changing the program's output.  For example, when someone wins the computer prints:\\
\codefont{Player X wins!!!} \\
where X is the number of the winning player.
This is a nice message, but it is somewhat characterless.  It's simple to change it to something more interesting and personal.  For example:\\
\codefont{Nice going player X, you won.} or \cf{Player X Rocks!!!}\\
 This just requires changing line 31.  Make sure you understand how the line works before changing it.

Now personalize the rest of the program.  Change how the program tells the player whose move it is and how it tells the player how many objects the computer removed.

\mysubsubsection{Exercise 2: Printing the Rules}

Currently, the program doesn't tell the player the rules of the game.  This weakness of the program can be fixed by adding a few output lines. 

As noted in the previous chapter, when making changes to a program, one of the first steps is to decide \emph{where} in the program to make the changes.
If the program is going to tell players the rules of NIM, it needs to do so in the right place.  Telling the player how to play after he or she has already lost isn't much use, and reprinting the rules before every move would be annoying.  So, to begin with, look at the program and try to figure out where the commands to print the rules should go.

Outputting the rules right before the game begins makes sense.  Line 12 is the beginning of the game loop, so the new line (or lines) should be added between lines 6 and 12.   However, typically variables are declared in their own block (this is not necessary for a program to work, but it makes it easy to see what variables have been declared) so the best play to put the instructions is between lines 11 and 12.   It may be necessary to change the lines a few times before the output looks right.  Remember this is where you get to ``own'' the program -- present the rules in a way that reflects your style.

\mysubsubsection{Exercise 3: Objects Removed by the Player}
Currently, the program prints how many objects the computer chose to remove (line 24), but not how many the player removed.  Change the program so that it prints the number of objects the player removed.  

\mysubsubsection{Exercise 4: Truly Random Moves}

If you carefully record the computer's moves, you may notice that while the moves appear to be random, the computer actually makes exactly the same ``random'' moves in each game.  This is because random numbers are actually very difficult for computers.  The \codefont{rand()} function that the NIM program relies on to generate random numbers (line 22) is actually only a pseudorandom\index{pseudorandom number} number generator.  It uses an algorithm for generating a \emph{sequence} of numbers that have statistical properties similar to true random numbers.  Currently, the NIM program always starts the sequence at the same point, so the computer always chooses the same series of ``random'' numbers. 

To avoid this problem, the random number generator can be \emph{seeded} to start at a different point in the sequence.  A common source for the \emph{seed}\index{random!seed} value is the current time, which is presumably different each time the game is played.\footnote{Using the current time as a seed is not a good approach when security is important.  Hackers can often estimate the time when a program runs.  This allows them to limit the number of possible random number seeds that a program might have used.   That information can be used to determine the likely ``random'' numbers the program would pick, for example, to generate security keys.}  

Two lines need to be added to the program to ``seed'' the random number generator.  Somewhere between lines 1 and 4, the new line:\\
\codefont{\#include<ctime>}\\
needs to be added.  Not surprisingly \codefont{ctime}\index{ctime@{\cf{ctime@{\cf{ctime}}}}}
\index{libraries!ctime@{\cf{ctime}}} is a library that contains functions dealing with time.  Then, somewhere after line 5 (the beginning of the actual program) and before line 12 (the beginning of the game loop), the line:\\
\codefont{srand(time(NULL));}\index{srand()@{\cf{srand()}}}
\index{random!srand()@{\cf{srand()}}}\\
needs to be added.  The function \codefont{srand()} seeds the random number generator.  The function \codefont{time()}\index{time()@{\cf{time()}}} gets the current time (in seconds, since January 1, 1970).  For now, don't worry about the keyword \codefont{NULL}.  It's just there to make the \codefont{time()} function work properly.  With this addition the computer will pick different random numbers for every game (unless two games happen to be started within one second of each other).

\mysubsubsection{Exercise 5: Number of Objects}

The game of NIM always begins with 23 objects.   What if you want to have games that begin with a different number of objects?    Clearly, one method is to change the code so that the relevant variable (\codefont{num\_objects}) starts with a different number.  However, for this to work, the code has to be changed and recompiled each time the starting value is changed.  This may be fine for a programmer, but it won't work for anyone who's just playing the game.  
Instead the code needs to be changed so that the player can enter the starting number when the game starts. 

As before, the first step is to figure out \emph{where} the code needs to be changed.  There's no point in asking the player how many objects to start with halfway through the game.  Therefore, the value should be set right after the relevant variable \codefont{num\_objects} is declared, but before the game really starts.  This means around line 11 of the original program.  

The new code should prompt the user to enter the initial number of objects, use an input command to get the user's choice, and store it in the correct variable.  The code also needs to check that the value the user entered is valid.  If the user enters an invalid value, say -23, the program acts in strange ways (you might want to try it and see what happens).

Again, an important advantage of working from an existing program is that parts of the program can be copied, modified, and reused.  The new code needs to perform tasks that are very similar to the tasks performed when the user enters a move: 
\begin{tight_enumerate}
\item Prompt the user for a number.
\item Get the number and check if it's valid. 
\item If the value is not valid, loop back and request another number.  
\end{tight_enumerate}
In this case lines 14-19 of the original program are a good example to work from.  

Remember that those lines can't just be copied -- they have to be modified to meet the new code requirements.  A few of the key modifications are changing the message the user sees (the user prompt), changing the variable name, and changing the values that determine if the entered value is valid.  Don't try to do these all at once.  It's much easier to make changes one small step at a time, making sure that each step works properly before making the next change.

\mysubsubsection{Exercise 6: Smarter Play -- Artificial Intelligence}

Currently the program plays quite poorly.  Its moves are random, and sometimes the computer will lose even when it doesn't have to.  For example, if there are only two items left, the computer could win by only taking away one (forcing the player to remove the last item), but half of the time it will choose to remove both items and lose.  Making the program play more intelligently would give it a (very) primitive form of artificial intelligence.

The basic case just described is fairly easy to handle.  The first task is to figure out when the program should play smarter.  One approach is to make a short list of the obvious cases:
\begin{tight_itemize}
\item 1 object remaining - nothing the program can do; it has to take the last object and lose.
\item 2 objects remaining - the program should remove 1 object, forcing the player to take the last object.
\item Etc.
\end{tight_itemize}
The computer's action for 3 and 4 objects remaining should also be fairly obvious.\footnote{In fact there is a correct move for almost every number of objects, see the next exercise for a discussion of the correct moves in other cases.}
In the code, each of these cases can be handled by a separate if statement.  (Later, another command, \codefont{switch}, will be introduced that can do the same thing using a slightly simpler syntax.)  For example, a section of code like:\\
\codefont{
if(num\_objects == 2)\{ \\
\hspace*{1cm}move = 1;\\
\}\\
}
has the program remove 1 object if exactly 2 are left.

Of course, this code applies only when it's the computer's move (the player can always pick how many to remove).  So, it should go at approximately line 22 in the original code.  What should happen if the number of objects is not 2-4?  In that case, the program can still pick randomly.   It's slightly easier to let the computer pick a random move first, and then to change its move if one of the special conditions (2 objects remaining, etc.) are met.  So, the code should go in that order: first pick a random move, then replace it with a planned move, if appropriate.

Once the suggested changes have been made, the program should no longer make mistakes when there are only a few items remaining.  (One easy way to test these cases is to play several games starting with only 2-4 objects, something that's easy to do if the previous modification allowing the player to pick the number of starting objects was made.)  

\mysubsubsection{Exercise 7: Really Intelligent Play}
It turns out that NIM can be played almost perfectly.  The preceding section shows that if there are 2-4 items left, the program can always win, but there will always be 2-4 items left on the program's turn \emph{if} there were exactly 5 items left on the player's turn.  (The player has to remove 1, 2, or 3 items, so if there were exactly 5 items left before the player's turn, there has to be 4, 3, or 2 items left after the turn.)  So, if possible, the program should force there to be 5 items left on the player's turn.  This is possible if there were 6, 7, or 8 items on the computer's turn, which in turn will occur if there were exactly 9 items on the player's previous turn.  This logic can be traced backwards through the game, showing exactly how many items the program should leave after each of its moves.  The modulus operator, \%, which returns the \emph{remainder}, is useful for this problem.

Rewrite lines 21-23 so the computer plays as close to perfectly as possible.  Under what circumstances does the computer fail to play perfectly?

\mysubsubsection{Exercise 8: Multiple Games and Keeping Score}

Another potential weakness of the NIM game is that as soon as a game is done, the program exits.  Modify the program to play multiple games in a row without having to restart the program each time.    The program should also keep score: how many games the player won versus how many the computer won.  

As noted earlier, before changing the code, it is important to think about where and how the program should be changed.  Each time one game finishes, the program should ask the player if he or she wants to play again.  If the player answers ``no,'' the program exits; if the player answers ``yes,'' the program needs to jump back to the beginning to play another game.  Because the program needs to be able to jump back to the beginning, and because it may do this multiple times (if the player wants to play multiple games in a row), a \emph{loop} is a good solution.   In this case, the section of code to be repeated is nearly the whole program.  The items that don't need to be repeated are the includes (lines 2-4 of the original program), main (lines 5 and 6 of the original program), the variable declarations (lines 8-10 of the original program), and the return statements at the end of the program (line 35 of the original program).  Everything else should probably be part of the new mega-loop.  Note that although the variables \cf{current\_player} and \cf{num\_objects} do not need to be redeclared, they will probably need to be reset to the correct values for starting a new game.

Because the program should play at least once, a \cf{do-while} loop is appropriate.  The program should ask the player if he or she wants to play again and, based on the response, should either jump back to the beginning of the loop or continue to the end of the program and exit.  Again, starting from other player-controlled loops (for example, lines 14-19), can make it easier to set up the loop.

One last issue is what the player should enter to tell the program whether to play again.  For example, if the program prints:\\
\codefont{Do you want to play again?}\\
the player might enter ``Yes'' or ``yes'' or ``y'' or something similar, which means the program has to account for several possibilities.  In addition, to store a value like ``Yes'' or ``yes,'' the program needs to use a new type of variable.  To avoid these problems (at least for now), the program can tell the user what to enter using a prompt like: \\
\codefont{Do you want to play again?}\\
\codefont{Enter 1 for yes; 0 for no.}\\
Although slightly less user friendly than allowing the user to enter words, asking the player to enter a 0 or a 1 simplifies the programming problem by reducing the number of possible inputs and allowing the use of a simple data type (an int to store the 0 or 1).

If the program can play multiple games, it should also keep track of how many games were won by the player and by the computer.  To accomplish this, the program needs two new variables: one to keep track of how many games the computer won and one to keep track of how many games the player won.  Each time a game is finished, the appropriate variables will need to be adjusted.
The program should print the number of wins for both the player and the computer at the end of each game.

\section{Problems}

The potential for adding to and expanding NIM should now be clear.  In addition, many of the new techniques learned in this chapter can be applied to the Fortune Teller program.  
\begin{enumerate}[{\bf 1.}]

\item {\bf Fixing magic numbers and removing different numbers of objects} \\
There's nothing particularly special about the limit of removing 3 objects.  Changing the rules to allow the players to remove a different number of objects requires changing the conditions of the loops that control what is a valid move, and the \codefont{rand()} statement so that the computer picks a number in the correct, new range.  The best way to do this is to replace the current ``magic'' numbers (1 and 3) with variables.  This makes the code easier to read (assuming the variables are given meaningful names like \cf{minimum\_move} and \cf{maximum\_move}) and makes the code easier to change in the future because only the two new variables need to be changed.

Replace the magic numbers in the program with variables and change the code so that players can remove from 1 to 4 objects on their turn.

\item {\bf Different win/loss conditions}\\  Instead of the player who takes the last object losing, change the program so that the player who takes the last object \emph{wins}.

\item {\bf Player versus player}\\ Instead of playing against the computer, change the program so two people can chose to play against each other.  Making the game player versus player game is fairly easy to program: compare lines 17-22 to lines 24-27 of the original program. \\
 {\bf Challenge:} Have the program begin by letting the user chose whether to play against the computer or against another player.

\item {\bf ``Graphical'' output}\\  Have the computer print a row of symbols, like \#'s or *'s, to represent the number of objects remaining.  This requires a loop that prints \codefont{num\_objects} of the symbols in a row.  A \codefont{for} loop, described in Section~\ref{appendix:loops} of Appendix A and in Chapter 5, works well, although a \codefont{do-while} loop can also be made to work.  (A \cf{do-while} loop requires a new variable that ``counts'' from 1 to \codefont{num\_objects} as part of the loop.)

\item {\bf Changing who goes first}\\ Currently the human player always goes first.  Change the program so the user can pick who goes first when the game starts.

\item {\bf Commentary}\\ Add a running commentary during the game.  For example, when there are only a few objects left, the program could print messages like \emph{``It's close to the end now, folks.''}   Include different comments when there are different numbers of remaining objects by using if statements. \\
 {\bf Challenge:} Use the random function (the one that's used to generate the program's moves) to make the program print different, random comments in different games.

\item {\bf Multiple sets of objects}\\  It's common in NIM to play with more than one set of objects.  For example, there might be three sets of objects, each starting with 23 objects.  Change the program to have three or more sets of objects.  This will require additional variables to keep track of the number of items in each set.  Also, on each turn, the player will have to pick which set of objects to take away from and then how many objects to take away.

\item {\bf Player suggestions}\\  Use the AI from Exercise 6 to have the program give the human player hints during the game.

\item {\bf Random Fortunes}\\  Modify the Fortune Teller program so it includes an element of chance.  For each lucky number have 2 or 3 different fortunes that are picked randomly, so that if two users happen to have the same lucky number they won't automatically get the same fortune.

\item {\bf Limited Fortunes}\\ Add two input validation loops to the Fortune Teller program so users have to enter numbers in a particular range, for example, numbers between 1 and 100.  The code should be very similar to the code from the NIM program that checks a player's move (i.e., lines 14-19).  Although the message and the condition will need to be changed.

\item {\bf Repeated Fortunes} \\ Add a loop to the Fortune Teller program so that the program can give multiple fortunes.  After each fortune the program should ask the player if they want to continue playing and, if they do, the program should loop back to the beginning and ask for new input numbers.  Because we have only used integer variables so far, the program should ask something like:\\
\cf{Do you want another fortune? (1 = yes, 0 = no)}\\
using integers (1 and 0) as input from the player, as was suggested in exercise 8.  

\item {\bf Guessing Game}\\ Create a guessing game.  The program should pick a random number in the range 1-100.  The player tries to guess the number.  If the player guesses incorrectly the program tells them whether the number is higher or lower than their guess.  If the player guesses outside of the range 1-100 the program prints an error message and lets them guess again.   The program 
should keep track of the number of guesses and report it when the player guesses correctly.

\item {\bf Other games}\\ Using the basic skeleton of the NIM game, it's not too difficult to create other simple games.  Create a Rock, Paper, Scissors game.   The current NIM moves of 1, 2, 3 can be treated as rock, paper, scissors, where 2 beats 1, 3 beats 2, and 1 beats 3.
\end{enumerate}


%********** End of chapter **********
